
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model TargetScoutFilter
 * 
 */
export type TargetScoutFilter = $Result.DefaultSelection<Prisma.$TargetScoutFilterPayload>
/**
 * Model GithubRepositoryBranch
 * 
 */
export type GithubRepositoryBranch = $Result.DefaultSelection<Prisma.$GithubRepositoryBranchPayload>
/**
 * Model GithubRepositoryCommit
 * 
 */
export type GithubRepositoryCommit = $Result.DefaultSelection<Prisma.$GithubRepositoryCommitPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Whitelist
 * 
 */
export type Whitelist = $Result.DefaultSelection<Prisma.$WhitelistPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model OneTimeCodes
 * 
 */
export type OneTimeCodes = $Result.DefaultSelection<Prisma.$OneTimeCodesPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model TeamAccount
 * 
 */
export type TeamAccount = $Result.DefaultSelection<Prisma.$TeamAccountPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Email
 * 
 */
export type Email = $Result.DefaultSelection<Prisma.$EmailPayload>
/**
 * Model EmailThread
 * 
 */
export type EmailThread = $Result.DefaultSelection<Prisma.$EmailThreadPayload>
/**
 * Model Note
 * 
 */
export type Note = $Result.DefaultSelection<Prisma.$NotePayload>
/**
 * Model TargetScout
 * 
 */
export type TargetScout = $Result.DefaultSelection<Prisma.$TargetScoutPayload>
/**
 * Model CustomField
 * 
 */
export type CustomField = $Result.DefaultSelection<Prisma.$CustomFieldPayload>
/**
 * Model CustomFieldValue
 * 
 */
export type CustomFieldValue = $Result.DefaultSelection<Prisma.$CustomFieldValuePayload>
/**
 * Model TargetContact
 * 
 */
export type TargetContact = $Result.DefaultSelection<Prisma.$TargetContactPayload>
/**
 * Model GithubTarget
 * 
 */
export type GithubTarget = $Result.DefaultSelection<Prisma.$GithubTargetPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model Tracker
 * 
 */
export type Tracker = $Result.DefaultSelection<Prisma.$TrackerPayload>
/**
 * Model Evaluation
 * 
 */
export type Evaluation = $Result.DefaultSelection<Prisma.$EvaluationPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model GithubRepository
 * 
 */
export type GithubRepository = $Result.DefaultSelection<Prisma.$GithubRepositoryPayload>
/**
 * Model ZapierEvent
 * 
 */
export type ZapierEvent = $Result.DefaultSelection<Prisma.$ZapierEventPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.whitelist`: Exposes CRUD operations for the **Whitelist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whitelists
    * const whitelists = await prisma.whitelist.findMany()
    * ```
    */
  get whitelist(): Prisma.WhitelistDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.oneTimeCodes`: Exposes CRUD operations for the **OneTimeCodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OneTimeCodes
    * const oneTimeCodes = await prisma.oneTimeCodes.findMany()
    * ```
    */
  get oneTimeCodes(): Prisma.OneTimeCodesDelegate<ExtArgs>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.teamAccount`: Exposes CRUD operations for the **TeamAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamAccounts
    * const teamAccounts = await prisma.teamAccount.findMany()
    * ```
    */
  get teamAccount(): Prisma.TeamAccountDelegate<ExtArgs>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs>;

  /**
   * `prisma.email`: Exposes CRUD operations for the **Email** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emails
    * const emails = await prisma.email.findMany()
    * ```
    */
  get email(): Prisma.EmailDelegate<ExtArgs>;

  /**
   * `prisma.emailThread`: Exposes CRUD operations for the **EmailThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailThreads
    * const emailThreads = await prisma.emailThread.findMany()
    * ```
    */
  get emailThread(): Prisma.EmailThreadDelegate<ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<ExtArgs>;

  /**
   * `prisma.targetScout`: Exposes CRUD operations for the **TargetScout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TargetScouts
    * const targetScouts = await prisma.targetScout.findMany()
    * ```
    */
  get targetScout(): Prisma.TargetScoutDelegate<ExtArgs>;

  /**
   * `prisma.customField`: Exposes CRUD operations for the **CustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFields
    * const customFields = await prisma.customField.findMany()
    * ```
    */
  get customField(): Prisma.CustomFieldDelegate<ExtArgs>;

  /**
   * `prisma.customFieldValue`: Exposes CRUD operations for the **CustomFieldValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomFieldValues
    * const customFieldValues = await prisma.customFieldValue.findMany()
    * ```
    */
  get customFieldValue(): Prisma.CustomFieldValueDelegate<ExtArgs>;

  /**
   * `prisma.targetContact`: Exposes CRUD operations for the **TargetContact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TargetContacts
    * const targetContacts = await prisma.targetContact.findMany()
    * ```
    */
  get targetContact(): Prisma.TargetContactDelegate<ExtArgs>;

  /**
   * `prisma.githubTarget`: Exposes CRUD operations for the **GithubTarget** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GithubTargets
    * const githubTargets = await prisma.githubTarget.findMany()
    * ```
    */
  get githubTarget(): Prisma.GithubTargetDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.tracker`: Exposes CRUD operations for the **Tracker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trackers
    * const trackers = await prisma.tracker.findMany()
    * ```
    */
  get tracker(): Prisma.TrackerDelegate<ExtArgs>;

  /**
   * `prisma.evaluation`: Exposes CRUD operations for the **Evaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluations
    * const evaluations = await prisma.evaluation.findMany()
    * ```
    */
  get evaluation(): Prisma.EvaluationDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.githubRepository`: Exposes CRUD operations for the **GithubRepository** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GithubRepositories
    * const githubRepositories = await prisma.githubRepository.findMany()
    * ```
    */
  get githubRepository(): Prisma.GithubRepositoryDelegate<ExtArgs>;

  /**
   * `prisma.zapierEvent`: Exposes CRUD operations for the **ZapierEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZapierEvents
    * const zapierEvents = await prisma.zapierEvent.findMany()
    * ```
    */
  get zapierEvent(): Prisma.ZapierEventDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.7.1
   * Query Engine version: 0ca5ccbcfa6bdc81c003cf549abe4269f59c41e5
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Whitelist: 'Whitelist',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    OneTimeCodes: 'OneTimeCodes',
    Subscription: 'Subscription',
    TeamAccount: 'TeamAccount',
    Contact: 'Contact',
    Email: 'Email',
    EmailThread: 'EmailThread',
    Note: 'Note',
    TargetScout: 'TargetScout',
    CustomField: 'CustomField',
    CustomFieldValue: 'CustomFieldValue',
    TargetContact: 'TargetContact',
    GithubTarget: 'GithubTarget',
    Campaign: 'Campaign',
    Tracker: 'Tracker',
    Evaluation: 'Evaluation',
    Report: 'Report',
    GithubRepository: 'GithubRepository',
    ZapierEvent: 'ZapierEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'account' | 'whitelist' | 'session' | 'user' | 'verificationToken' | 'oneTimeCodes' | 'subscription' | 'teamAccount' | 'contact' | 'email' | 'emailThread' | 'note' | 'targetScout' | 'customField' | 'customFieldValue' | 'targetContact' | 'githubTarget' | 'campaign' | 'tracker' | 'evaluation' | 'report' | 'githubRepository' | 'zapierEvent'
      txIsolationLevel: never
    },
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AccountFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AccountAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>,
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Whitelist: {
        payload: Prisma.$WhitelistPayload<ExtArgs>
        fields: Prisma.WhitelistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhitelistFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhitelistFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>
          }
          findFirst: {
            args: Prisma.WhitelistFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhitelistFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>
          }
          findMany: {
            args: Prisma.WhitelistFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>[]
          }
          create: {
            args: Prisma.WhitelistCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>
          }
          createMany: {
            args: Prisma.WhitelistCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.WhitelistDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>
          }
          update: {
            args: Prisma.WhitelistUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>
          }
          deleteMany: {
            args: Prisma.WhitelistDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.WhitelistUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.WhitelistUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$WhitelistPayload>
          }
          aggregate: {
            args: Prisma.WhitelistAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateWhitelist>
          }
          groupBy: {
            args: Prisma.WhitelistGroupByArgs<ExtArgs>,
            result: $Utils.Optional<WhitelistGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WhitelistFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.WhitelistAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.WhitelistCountArgs<ExtArgs>,
            result: $Utils.Optional<WhitelistCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VerificationTokenFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.VerificationTokenAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>,
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      OneTimeCodes: {
        payload: Prisma.$OneTimeCodesPayload<ExtArgs>
        fields: Prisma.OneTimeCodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OneTimeCodesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OneTimeCodesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>
          }
          findFirst: {
            args: Prisma.OneTimeCodesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OneTimeCodesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>
          }
          findMany: {
            args: Prisma.OneTimeCodesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>[]
          }
          create: {
            args: Prisma.OneTimeCodesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>
          }
          createMany: {
            args: Prisma.OneTimeCodesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OneTimeCodesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>
          }
          update: {
            args: Prisma.OneTimeCodesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>
          }
          deleteMany: {
            args: Prisma.OneTimeCodesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OneTimeCodesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OneTimeCodesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OneTimeCodesPayload>
          }
          aggregate: {
            args: Prisma.OneTimeCodesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOneTimeCodes>
          }
          groupBy: {
            args: Prisma.OneTimeCodesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OneTimeCodesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OneTimeCodesFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.OneTimeCodesAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.OneTimeCodesCountArgs<ExtArgs>,
            result: $Utils.Optional<OneTimeCodesCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SubscriptionFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.SubscriptionAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>,
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      TeamAccount: {
        payload: Prisma.$TeamAccountPayload<ExtArgs>
        fields: Prisma.TeamAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamAccountFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamAccountFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>
          }
          findFirst: {
            args: Prisma.TeamAccountFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamAccountFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>
          }
          findMany: {
            args: Prisma.TeamAccountFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>[]
          }
          create: {
            args: Prisma.TeamAccountCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>
          }
          createMany: {
            args: Prisma.TeamAccountCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TeamAccountDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>
          }
          update: {
            args: Prisma.TeamAccountUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>
          }
          deleteMany: {
            args: Prisma.TeamAccountDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TeamAccountUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TeamAccountUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TeamAccountPayload>
          }
          aggregate: {
            args: Prisma.TeamAccountAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTeamAccount>
          }
          groupBy: {
            args: Prisma.TeamAccountGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TeamAccountGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TeamAccountFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.TeamAccountAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.TeamAccountCountArgs<ExtArgs>,
            result: $Utils.Optional<TeamAccountCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ContactFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ContactAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>,
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Email: {
        payload: Prisma.$EmailPayload<ExtArgs>
        fields: Prisma.EmailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findFirst: {
            args: Prisma.EmailFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          findMany: {
            args: Prisma.EmailFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>[]
          }
          create: {
            args: Prisma.EmailCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          createMany: {
            args: Prisma.EmailCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          update: {
            args: Prisma.EmailUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          deleteMany: {
            args: Prisma.EmailDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailPayload>
          }
          aggregate: {
            args: Prisma.EmailAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmail>
          }
          groupBy: {
            args: Prisma.EmailGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EmailFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.EmailAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.EmailCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailCountAggregateOutputType> | number
          }
        }
      }
      EmailThread: {
        payload: Prisma.$EmailThreadPayload<ExtArgs>
        fields: Prisma.EmailThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailThreadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailThreadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          findFirst: {
            args: Prisma.EmailThreadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailThreadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          findMany: {
            args: Prisma.EmailThreadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>[]
          }
          create: {
            args: Prisma.EmailThreadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          createMany: {
            args: Prisma.EmailThreadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmailThreadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          update: {
            args: Prisma.EmailThreadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          deleteMany: {
            args: Prisma.EmailThreadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmailThreadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmailThreadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmailThreadPayload>
          }
          aggregate: {
            args: Prisma.EmailThreadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmailThread>
          }
          groupBy: {
            args: Prisma.EmailThreadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmailThreadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EmailThreadFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.EmailThreadAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.EmailThreadCountArgs<ExtArgs>,
            result: $Utils.Optional<EmailThreadCountAggregateOutputType> | number
          }
        }
      }
      Note: {
        payload: Prisma.$NotePayload<ExtArgs>
        fields: Prisma.NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findFirst: {
            args: Prisma.NoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          findMany: {
            args: Prisma.NoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>[]
          }
          create: {
            args: Prisma.NoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          createMany: {
            args: Prisma.NoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.NoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          update: {
            args: Prisma.NoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          deleteMany: {
            args: Prisma.NoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.NoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.NoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$NotePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.NoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NoteFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.NoteAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.NoteCountArgs<ExtArgs>,
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      TargetScout: {
        payload: Prisma.$TargetScoutPayload<ExtArgs>
        fields: Prisma.TargetScoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TargetScoutFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TargetScoutFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>
          }
          findFirst: {
            args: Prisma.TargetScoutFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TargetScoutFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>
          }
          findMany: {
            args: Prisma.TargetScoutFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>[]
          }
          create: {
            args: Prisma.TargetScoutCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>
          }
          createMany: {
            args: Prisma.TargetScoutCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TargetScoutDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>
          }
          update: {
            args: Prisma.TargetScoutUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>
          }
          deleteMany: {
            args: Prisma.TargetScoutDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TargetScoutUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TargetScoutUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetScoutPayload>
          }
          aggregate: {
            args: Prisma.TargetScoutAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTargetScout>
          }
          groupBy: {
            args: Prisma.TargetScoutGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TargetScoutGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TargetScoutFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.TargetScoutAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.TargetScoutCountArgs<ExtArgs>,
            result: $Utils.Optional<TargetScoutCountAggregateOutputType> | number
          }
        }
      }
      CustomField: {
        payload: Prisma.$CustomFieldPayload<ExtArgs>
        fields: Prisma.CustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findFirst: {
            args: Prisma.CustomFieldFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          findMany: {
            args: Prisma.CustomFieldFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
          }
          create: {
            args: Prisma.CustomFieldCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          createMany: {
            args: Prisma.CustomFieldCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomFieldDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          update: {
            args: Prisma.CustomFieldUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomFieldUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldPayload>
          }
          aggregate: {
            args: Prisma.CustomFieldAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomField>
          }
          groupBy: {
            args: Prisma.CustomFieldGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomFieldGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomFieldFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomFieldAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CustomFieldCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomFieldCountAggregateOutputType> | number
          }
        }
      }
      CustomFieldValue: {
        payload: Prisma.$CustomFieldValuePayload<ExtArgs>
        fields: Prisma.CustomFieldValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomFieldValueFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          findFirst: {
            args: Prisma.CustomFieldValueFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomFieldValueFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          findMany: {
            args: Prisma.CustomFieldValueFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>[]
          }
          create: {
            args: Prisma.CustomFieldValueCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          createMany: {
            args: Prisma.CustomFieldValueCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomFieldValueDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          update: {
            args: Prisma.CustomFieldValueUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          deleteMany: {
            args: Prisma.CustomFieldValueDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomFieldValueUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomFieldValueUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomFieldValuePayload>
          }
          aggregate: {
            args: Prisma.CustomFieldValueAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomFieldValue>
          }
          groupBy: {
            args: Prisma.CustomFieldValueGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomFieldValueGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CustomFieldValueFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CustomFieldValueAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CustomFieldValueCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomFieldValueCountAggregateOutputType> | number
          }
        }
      }
      TargetContact: {
        payload: Prisma.$TargetContactPayload<ExtArgs>
        fields: Prisma.TargetContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TargetContactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TargetContactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>
          }
          findFirst: {
            args: Prisma.TargetContactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TargetContactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>
          }
          findMany: {
            args: Prisma.TargetContactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>[]
          }
          create: {
            args: Prisma.TargetContactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>
          }
          createMany: {
            args: Prisma.TargetContactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TargetContactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>
          }
          update: {
            args: Prisma.TargetContactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>
          }
          deleteMany: {
            args: Prisma.TargetContactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TargetContactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TargetContactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TargetContactPayload>
          }
          aggregate: {
            args: Prisma.TargetContactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTargetContact>
          }
          groupBy: {
            args: Prisma.TargetContactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TargetContactGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TargetContactFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.TargetContactAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.TargetContactCountArgs<ExtArgs>,
            result: $Utils.Optional<TargetContactCountAggregateOutputType> | number
          }
        }
      }
      GithubTarget: {
        payload: Prisma.$GithubTargetPayload<ExtArgs>
        fields: Prisma.GithubTargetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GithubTargetFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GithubTargetFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>
          }
          findFirst: {
            args: Prisma.GithubTargetFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GithubTargetFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>
          }
          findMany: {
            args: Prisma.GithubTargetFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>[]
          }
          create: {
            args: Prisma.GithubTargetCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>
          }
          createMany: {
            args: Prisma.GithubTargetCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GithubTargetDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>
          }
          update: {
            args: Prisma.GithubTargetUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>
          }
          deleteMany: {
            args: Prisma.GithubTargetDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GithubTargetUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GithubTargetUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubTargetPayload>
          }
          aggregate: {
            args: Prisma.GithubTargetAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGithubTarget>
          }
          groupBy: {
            args: Prisma.GithubTargetGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GithubTargetGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GithubTargetFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.GithubTargetAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.GithubTargetCountArgs<ExtArgs>,
            result: $Utils.Optional<GithubTargetCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CampaignFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CampaignAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>,
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      Tracker: {
        payload: Prisma.$TrackerPayload<ExtArgs>
        fields: Prisma.TrackerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrackerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrackerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>
          }
          findFirst: {
            args: Prisma.TrackerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrackerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>
          }
          findMany: {
            args: Prisma.TrackerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>[]
          }
          create: {
            args: Prisma.TrackerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>
          }
          createMany: {
            args: Prisma.TrackerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TrackerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>
          }
          update: {
            args: Prisma.TrackerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>
          }
          deleteMany: {
            args: Prisma.TrackerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TrackerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TrackerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TrackerPayload>
          }
          aggregate: {
            args: Prisma.TrackerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTracker>
          }
          groupBy: {
            args: Prisma.TrackerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TrackerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TrackerFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.TrackerAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.TrackerCountArgs<ExtArgs>,
            result: $Utils.Optional<TrackerCountAggregateOutputType> | number
          }
        }
      }
      Evaluation: {
        payload: Prisma.$EvaluationPayload<ExtArgs>
        fields: Prisma.EvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findFirst: {
            args: Prisma.EvaluationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          findMany: {
            args: Prisma.EvaluationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>[]
          }
          create: {
            args: Prisma.EvaluationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          createMany: {
            args: Prisma.EvaluationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EvaluationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          update: {
            args: Prisma.EvaluationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          deleteMany: {
            args: Prisma.EvaluationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EvaluationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EvaluationPayload>
          }
          aggregate: {
            args: Prisma.EvaluationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEvaluation>
          }
          groupBy: {
            args: Prisma.EvaluationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.EvaluationFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.EvaluationAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.EvaluationCountArgs<ExtArgs>,
            result: $Utils.Optional<EvaluationCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReportFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReportAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      GithubRepository: {
        payload: Prisma.$GithubRepositoryPayload<ExtArgs>
        fields: Prisma.GithubRepositoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GithubRepositoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GithubRepositoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>
          }
          findFirst: {
            args: Prisma.GithubRepositoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GithubRepositoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>
          }
          findMany: {
            args: Prisma.GithubRepositoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>[]
          }
          create: {
            args: Prisma.GithubRepositoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>
          }
          createMany: {
            args: Prisma.GithubRepositoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.GithubRepositoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>
          }
          update: {
            args: Prisma.GithubRepositoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>
          }
          deleteMany: {
            args: Prisma.GithubRepositoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.GithubRepositoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.GithubRepositoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$GithubRepositoryPayload>
          }
          aggregate: {
            args: Prisma.GithubRepositoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateGithubRepository>
          }
          groupBy: {
            args: Prisma.GithubRepositoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<GithubRepositoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.GithubRepositoryFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.GithubRepositoryAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.GithubRepositoryCountArgs<ExtArgs>,
            result: $Utils.Optional<GithubRepositoryCountAggregateOutputType> | number
          }
        }
      }
      ZapierEvent: {
        payload: Prisma.$ZapierEventPayload<ExtArgs>
        fields: Prisma.ZapierEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZapierEventFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZapierEventFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>
          }
          findFirst: {
            args: Prisma.ZapierEventFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZapierEventFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>
          }
          findMany: {
            args: Prisma.ZapierEventFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>[]
          }
          create: {
            args: Prisma.ZapierEventCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>
          }
          createMany: {
            args: Prisma.ZapierEventCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ZapierEventDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>
          }
          update: {
            args: Prisma.ZapierEventUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>
          }
          deleteMany: {
            args: Prisma.ZapierEventDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ZapierEventUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ZapierEventUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ZapierEventPayload>
          }
          aggregate: {
            args: Prisma.ZapierEventAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateZapierEvent>
          }
          groupBy: {
            args: Prisma.ZapierEventGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ZapierEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ZapierEventFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ZapierEventAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ZapierEventCountArgs<ExtArgs>,
            result: $Utils.Optional<ZapierEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    Evaluation: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Evaluation?: boolean | AccountCountOutputTypeCountEvaluationArgs
  }

  // Custom InputTypes

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }



  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    ownedTeamAccounts: number
    teamAccounts: number
    notes: number
    evaluation: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    ownedTeamAccounts?: boolean | UserCountOutputTypeCountOwnedTeamAccountsArgs
    teamAccounts?: boolean | UserCountOutputTypeCountTeamAccountsArgs
    notes?: boolean | UserCountOutputTypeCountNotesArgs
    evaluation?: boolean | UserCountOutputTypeCountEvaluationArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedTeamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAccountWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }



  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    teamAccounts: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamAccounts?: boolean | SubscriptionCountOutputTypeCountTeamAccountsArgs
  }

  // Custom InputTypes

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountTeamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAccountWhereInput
  }



  /**
   * Count Type TeamAccountCountOutputType
   */

  export type TeamAccountCountOutputType = {
    inviteCodes: number
    teamAccountUsers: number
    contacts: number
    emails: number
    owners: number
    emailThreads: number
    campaigns: number
    notes: number
    targetContact: number
    evaluation: number
  }

  export type TeamAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviteCodes?: boolean | TeamAccountCountOutputTypeCountInviteCodesArgs
    teamAccountUsers?: boolean | TeamAccountCountOutputTypeCountTeamAccountUsersArgs
    contacts?: boolean | TeamAccountCountOutputTypeCountContactsArgs
    emails?: boolean | TeamAccountCountOutputTypeCountEmailsArgs
    owners?: boolean | TeamAccountCountOutputTypeCountOwnersArgs
    emailThreads?: boolean | TeamAccountCountOutputTypeCountEmailThreadsArgs
    campaigns?: boolean | TeamAccountCountOutputTypeCountCampaignsArgs
    notes?: boolean | TeamAccountCountOutputTypeCountNotesArgs
    targetContact?: boolean | TeamAccountCountOutputTypeCountTargetContactArgs
    evaluation?: boolean | TeamAccountCountOutputTypeCountEvaluationArgs
  }

  // Custom InputTypes

  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccountCountOutputType
     */
    select?: TeamAccountCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountInviteCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneTimeCodesWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountTeamAccountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountOwnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountEmailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountTargetContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetContactWhereInput
  }


  /**
   * TeamAccountCountOutputType without action
   */
  export type TeamAccountCountOutputTypeCountEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }



  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    emails: number
    emailThreads: number
    githubTargets: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | ContactCountOutputTypeCountEmailsArgs
    emailThreads?: boolean | ContactCountOutputTypeCountEmailThreadsArgs
    githubTargets?: boolean | ContactCountOutputTypeCountGithubTargetsArgs
  }

  // Custom InputTypes

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountEmailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }


  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountGithubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubTargetWhereInput
  }



  /**
   * Count Type EmailCountOutputType
   */

  export type EmailCountOutputType = {
    contacts: number
  }

  export type EmailCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | EmailCountOutputTypeCountContactsArgs
  }

  // Custom InputTypes

  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailCountOutputType
     */
    select?: EmailCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailCountOutputType without action
   */
  export type EmailCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }



  /**
   * Count Type EmailThreadCountOutputType
   */

  export type EmailThreadCountOutputType = {
    emails: number
    contacts: number
    githubTargets: number
  }

  export type EmailThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | EmailThreadCountOutputTypeCountEmailsArgs
    contacts?: boolean | EmailThreadCountOutputTypeCountContactsArgs
    githubTargets?: boolean | EmailThreadCountOutputTypeCountGithubTargetsArgs
  }

  // Custom InputTypes

  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThreadCountOutputType
     */
    select?: EmailThreadCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeCountEmailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
  }


  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * EmailThreadCountOutputType without action
   */
  export type EmailThreadCountOutputTypeCountGithubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubTargetWhereInput
  }



  /**
   * Count Type CustomFieldCountOutputType
   */

  export type CustomFieldCountOutputType = {
    customFieldValues: number
  }

  export type CustomFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customFieldValues?: boolean | CustomFieldCountOutputTypeCountCustomFieldValuesArgs
  }

  // Custom InputTypes

  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldCountOutputType
     */
    select?: CustomFieldCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomFieldCountOutputType without action
   */
  export type CustomFieldCountOutputTypeCountCustomFieldValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
  }



  /**
   * Count Type TargetContactCountOutputType
   */

  export type TargetContactCountOutputType = {
    campaigns: number
    customFieldValue: number
  }

  export type TargetContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | TargetContactCountOutputTypeCountCampaignsArgs
    customFieldValue?: boolean | TargetContactCountOutputTypeCountCustomFieldValueArgs
  }

  // Custom InputTypes

  /**
   * TargetContactCountOutputType without action
   */
  export type TargetContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContactCountOutputType
     */
    select?: TargetContactCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TargetContactCountOutputType without action
   */
  export type TargetContactCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * TargetContactCountOutputType without action
   */
  export type TargetContactCountOutputTypeCountCustomFieldValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
  }



  /**
   * Count Type GithubTargetCountOutputType
   */

  export type GithubTargetCountOutputType = {
    campaigns: number
    reports: number
    evaluations: number
    contacts: number
    targetContacts: number
    notes: number
    emailThreads: number
  }

  export type GithubTargetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | GithubTargetCountOutputTypeCountCampaignsArgs
    reports?: boolean | GithubTargetCountOutputTypeCountReportsArgs
    evaluations?: boolean | GithubTargetCountOutputTypeCountEvaluationsArgs
    contacts?: boolean | GithubTargetCountOutputTypeCountContactsArgs
    targetContacts?: boolean | GithubTargetCountOutputTypeCountTargetContactsArgs
    notes?: boolean | GithubTargetCountOutputTypeCountNotesArgs
    emailThreads?: boolean | GithubTargetCountOutputTypeCountEmailThreadsArgs
  }

  // Custom InputTypes

  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTargetCountOutputType
     */
    select?: GithubTargetCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountTargetContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetContactWhereInput
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * GithubTargetCountOutputType without action
   */
  export type GithubTargetCountOutputTypeCountEmailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
  }



  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    githubTargets: number
    teamAccounts: number
    targetScouts: number
    trackers: number
    evaluation: number
    targetContacts: number
    customFields: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    githubTargets?: boolean | CampaignCountOutputTypeCountGithubTargetsArgs
    teamAccounts?: boolean | CampaignCountOutputTypeCountTeamAccountsArgs
    targetScouts?: boolean | CampaignCountOutputTypeCountTargetScoutsArgs
    trackers?: boolean | CampaignCountOutputTypeCountTrackersArgs
    evaluation?: boolean | CampaignCountOutputTypeCountEvaluationArgs
    targetContacts?: boolean | CampaignCountOutputTypeCountTargetContactsArgs
    customFields?: boolean | CampaignCountOutputTypeCountCustomFieldsArgs
  }

  // Custom InputTypes

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountGithubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubTargetWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTeamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAccountWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTargetScoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetScoutWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTrackersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackerWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTargetContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetContactWhereInput
  }


  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
  }



  /**
   * Count Type TrackerCountOutputType
   */

  export type TrackerCountOutputType = {
    evaluations: number
  }

  export type TrackerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluations?: boolean | TrackerCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes

  /**
   * TrackerCountOutputType without action
   */
  export type TrackerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrackerCountOutputType
     */
    select?: TrackerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * TrackerCountOutputType without action
   */
  export type TrackerCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }



  /**
   * Count Type EvaluationCountOutputType
   */

  export type EvaluationCountOutputType = {
    children: number
  }

  export type EvaluationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | EvaluationCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes

  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvaluationCountOutputType
     */
    select?: EvaluationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EvaluationCountOutputType without action
   */
  export type EvaluationCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
  }



  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    githubTargets: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    githubTargets?: boolean | ReportCountOutputTypeCountGithubTargetsArgs
  }

  // Custom InputTypes

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountGithubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubTargetWhereInput
  }



  /**
   * Models
   */

  /**
   * Model TargetScoutFilter
   */





  export type TargetScoutFilterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    repoOwners?: boolean
    repoCreatedDate?: boolean
    repoStars?: boolean
    repoForks?: boolean
    userLocation?: boolean
    userFollowers?: boolean
    userRepositories?: boolean
    userLanguages?: boolean
  }, ExtArgs["result"]["targetScoutFilter"]>

  export type TargetScoutFilterSelectScalar = {
    repoOwners?: boolean
    repoCreatedDate?: boolean
    repoStars?: boolean
    repoForks?: boolean
    userLocation?: boolean
    userFollowers?: boolean
    userRepositories?: boolean
    userLanguages?: boolean
  }


  export type $TargetScoutFilterPayload = {
    name: "TargetScoutFilter"
    objects: {}
    scalars: {
      repoOwners: string | null
      repoCreatedDate: string | null
      repoStars: string | null
      repoForks: string | null
      userLocation: string | null
      userFollowers: string | null
      userRepositories: string | null
      userLanguages: string | null
    }
    composites: {}
  }


  type TargetScoutFilterGetPayload<S extends boolean | null | undefined | TargetScoutFilterDefaultArgs> = $Result.GetResult<Prisma.$TargetScoutFilterPayload, S>





  /**
   * Fields of the TargetScoutFilter model
   */ 
  interface TargetScoutFilterFieldRefs {
    readonly repoOwners: FieldRef<"TargetScoutFilter", 'String'>
    readonly repoCreatedDate: FieldRef<"TargetScoutFilter", 'String'>
    readonly repoStars: FieldRef<"TargetScoutFilter", 'String'>
    readonly repoForks: FieldRef<"TargetScoutFilter", 'String'>
    readonly userLocation: FieldRef<"TargetScoutFilter", 'String'>
    readonly userFollowers: FieldRef<"TargetScoutFilter", 'String'>
    readonly userRepositories: FieldRef<"TargetScoutFilter", 'String'>
    readonly userLanguages: FieldRef<"TargetScoutFilter", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TargetScoutFilter without action
   */
  export type TargetScoutFilterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScoutFilter
     */
    select?: TargetScoutFilterSelect<ExtArgs> | null
  }



  /**
   * Model GithubRepositoryBranch
   */





  export type GithubRepositoryBranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    isDefault?: boolean
    commits?: boolean | GithubRepositoryCommitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["githubRepositoryBranch"]>

  export type GithubRepositoryBranchSelectScalar = {
    name?: boolean
    isDefault?: boolean
  }

  export type GithubRepositoryBranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $GithubRepositoryBranchPayload = {
    name: "GithubRepositoryBranch"
    objects: {}
    scalars: {
      name: string
      isDefault: boolean
    }
    composites: {
      commits: Prisma.$GithubRepositoryCommitPayload[]
    }
  }


  type GithubRepositoryBranchGetPayload<S extends boolean | null | undefined | GithubRepositoryBranchDefaultArgs> = $Result.GetResult<Prisma.$GithubRepositoryBranchPayload, S>





  /**
   * Fields of the GithubRepositoryBranch model
   */ 
  interface GithubRepositoryBranchFieldRefs {
    readonly name: FieldRef<"GithubRepositoryBranch", 'String'>
    readonly isDefault: FieldRef<"GithubRepositoryBranch", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * GithubRepositoryBranch without action
   */
  export type GithubRepositoryBranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepositoryBranch
     */
    select?: GithubRepositoryBranchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryBranchInclude<ExtArgs> | null
  }



  /**
   * Model GithubRepositoryCommit
   */





  export type GithubRepositoryCommitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    hash?: boolean
    date?: boolean
    message?: boolean
    additions?: boolean
    deletions?: boolean
    filesChanged?: boolean
    authorName?: boolean
    authorEmail?: boolean
  }, ExtArgs["result"]["githubRepositoryCommit"]>

  export type GithubRepositoryCommitSelectScalar = {
    hash?: boolean
    date?: boolean
    message?: boolean
    additions?: boolean
    deletions?: boolean
    filesChanged?: boolean
    authorName?: boolean
    authorEmail?: boolean
  }


  export type $GithubRepositoryCommitPayload = {
    name: "GithubRepositoryCommit"
    objects: {}
    scalars: {
      hash: string
      date: string
      message: string
      additions: number
      deletions: number
      filesChanged: number
      authorName: string
      authorEmail: string
    }
    composites: {}
  }


  type GithubRepositoryCommitGetPayload<S extends boolean | null | undefined | GithubRepositoryCommitDefaultArgs> = $Result.GetResult<Prisma.$GithubRepositoryCommitPayload, S>





  /**
   * Fields of the GithubRepositoryCommit model
   */ 
  interface GithubRepositoryCommitFieldRefs {
    readonly hash: FieldRef<"GithubRepositoryCommit", 'String'>
    readonly date: FieldRef<"GithubRepositoryCommit", 'String'>
    readonly message: FieldRef<"GithubRepositoryCommit", 'String'>
    readonly additions: FieldRef<"GithubRepositoryCommit", 'Int'>
    readonly deletions: FieldRef<"GithubRepositoryCommit", 'Int'>
    readonly filesChanged: FieldRef<"GithubRepositoryCommit", 'Int'>
    readonly authorName: FieldRef<"GithubRepositoryCommit", 'String'>
    readonly authorEmail: FieldRef<"GithubRepositoryCommit", 'String'>
  }
    

  // Custom InputTypes

  /**
   * GithubRepositoryCommit without action
   */
  export type GithubRepositoryCommitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepositoryCommit
     */
    select?: GithubRepositoryCommitSelect<ExtArgs> | null
  }



  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    refresh_token_expires_in: number | null
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    refresh_token_expires_in: number | null
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refresh_token_expires_in: number | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    refresh_token_expires_in: number | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    refresh_token_expires_in: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    refresh_token_expires_in?: true
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    refresh_token_expires_in?: true
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    refresh_token_expires_in?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    refresh_token_expires_in?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    refresh_token_expires_in?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    refresh_token_expires_in: number | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refresh_token_expires_in?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    Evaluation?: boolean | Account$EvaluationArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    refresh_token_expires_in?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    Evaluation?: boolean | Account$EvaluationArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      Evaluation: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      refresh_token_expires_in: number | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }


  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends AccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountCreateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accounts.
     *     @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     *     @example
     *     // Create many Accounts
     *     const account = await prisma.account.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends AccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends AccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>
    ): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * @param {AccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const account = await prisma.account.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AccountFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Account.
     * @param {AccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const account = await prisma.account.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AccountAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    Evaluation<T extends Account$EvaluationArgs<ExtArgs> = {}>(args?: Subset<T, Account$EvaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly refresh_token_expires_in: FieldRef<"Account", 'Int'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }


  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }


  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }


  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }


  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }


  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }


  /**
   * Account findRaw
   */
  export type AccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Account aggregateRaw
   */
  export type AccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Account.Evaluation
   */
  export type Account$EvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
  }



  /**
   * Model Whitelist
   */

  export type AggregateWhitelist = {
    _count: WhitelistCountAggregateOutputType | null
    _avg: WhitelistAvgAggregateOutputType | null
    _sum: WhitelistSumAggregateOutputType | null
    _min: WhitelistMinAggregateOutputType | null
    _max: WhitelistMaxAggregateOutputType | null
  }

  export type WhitelistAvgAggregateOutputType = {
    quantity: number | null
  }

  export type WhitelistSumAggregateOutputType = {
    quantity: number | null
  }

  export type WhitelistMinAggregateOutputType = {
    id: string | null
    githubName: string | null
    quantity: number | null
    createdAt: Date | null
    teamAccountId: string | null
  }

  export type WhitelistMaxAggregateOutputType = {
    id: string | null
    githubName: string | null
    quantity: number | null
    createdAt: Date | null
    teamAccountId: string | null
  }

  export type WhitelistCountAggregateOutputType = {
    id: number
    githubName: number
    quantity: number
    createdAt: number
    teamAccountId: number
    _all: number
  }


  export type WhitelistAvgAggregateInputType = {
    quantity?: true
  }

  export type WhitelistSumAggregateInputType = {
    quantity?: true
  }

  export type WhitelistMinAggregateInputType = {
    id?: true
    githubName?: true
    quantity?: true
    createdAt?: true
    teamAccountId?: true
  }

  export type WhitelistMaxAggregateInputType = {
    id?: true
    githubName?: true
    quantity?: true
    createdAt?: true
    teamAccountId?: true
  }

  export type WhitelistCountAggregateInputType = {
    id?: true
    githubName?: true
    quantity?: true
    createdAt?: true
    teamAccountId?: true
    _all?: true
  }

  export type WhitelistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whitelist to aggregate.
     */
    where?: WhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whitelists to fetch.
     */
    orderBy?: WhitelistOrderByWithRelationInput | WhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Whitelists
    **/
    _count?: true | WhitelistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WhitelistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WhitelistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhitelistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhitelistMaxAggregateInputType
  }

  export type GetWhitelistAggregateType<T extends WhitelistAggregateArgs> = {
        [P in keyof T & keyof AggregateWhitelist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhitelist[P]>
      : GetScalarType<T[P], AggregateWhitelist[P]>
  }




  export type WhitelistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhitelistWhereInput
    orderBy?: WhitelistOrderByWithAggregationInput | WhitelistOrderByWithAggregationInput[]
    by: WhitelistScalarFieldEnum[] | WhitelistScalarFieldEnum
    having?: WhitelistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhitelistCountAggregateInputType | true
    _avg?: WhitelistAvgAggregateInputType
    _sum?: WhitelistSumAggregateInputType
    _min?: WhitelistMinAggregateInputType
    _max?: WhitelistMaxAggregateInputType
  }

  export type WhitelistGroupByOutputType = {
    id: string
    githubName: string
    quantity: number
    createdAt: Date | null
    teamAccountId: string | null
    _count: WhitelistCountAggregateOutputType | null
    _avg: WhitelistAvgAggregateOutputType | null
    _sum: WhitelistSumAggregateOutputType | null
    _min: WhitelistMinAggregateOutputType | null
    _max: WhitelistMaxAggregateOutputType | null
  }

  type GetWhitelistGroupByPayload<T extends WhitelistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhitelistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhitelistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhitelistGroupByOutputType[P]>
            : GetScalarType<T[P], WhitelistGroupByOutputType[P]>
        }
      >
    >


  export type WhitelistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    githubName?: boolean
    quantity?: boolean
    createdAt?: boolean
    teamAccountId?: boolean
    teamAccount?: boolean | Whitelist$teamAccountArgs<ExtArgs>
  }, ExtArgs["result"]["whitelist"]>

  export type WhitelistSelectScalar = {
    id?: boolean
    githubName?: boolean
    quantity?: boolean
    createdAt?: boolean
    teamAccountId?: boolean
  }

  export type WhitelistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamAccount?: boolean | Whitelist$teamAccountArgs<ExtArgs>
  }


  export type $WhitelistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Whitelist"
    objects: {
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      githubName: string
      quantity: number
      createdAt: Date | null
      teamAccountId: string | null
    }, ExtArgs["result"]["whitelist"]>
    composites: {}
  }


  type WhitelistGetPayload<S extends boolean | null | undefined | WhitelistDefaultArgs> = $Result.GetResult<Prisma.$WhitelistPayload, S>

  type WhitelistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhitelistFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: WhitelistCountAggregateInputType | true
    }

  export interface WhitelistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Whitelist'], meta: { name: 'Whitelist' } }
    /**
     * Find zero or one Whitelist that matches the filter.
     * @param {WhitelistFindUniqueArgs} args - Arguments to find a Whitelist
     * @example
     * // Get one Whitelist
     * const whitelist = await prisma.whitelist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WhitelistFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, WhitelistFindUniqueArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Whitelist that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WhitelistFindUniqueOrThrowArgs} args - Arguments to find a Whitelist
     * @example
     * // Get one Whitelist
     * const whitelist = await prisma.whitelist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WhitelistFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WhitelistFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Whitelist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistFindFirstArgs} args - Arguments to find a Whitelist
     * @example
     * // Get one Whitelist
     * const whitelist = await prisma.whitelist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WhitelistFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, WhitelistFindFirstArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Whitelist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistFindFirstOrThrowArgs} args - Arguments to find a Whitelist
     * @example
     * // Get one Whitelist
     * const whitelist = await prisma.whitelist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WhitelistFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WhitelistFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Whitelists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whitelists
     * const whitelists = await prisma.whitelist.findMany()
     * 
     * // Get first 10 Whitelists
     * const whitelists = await prisma.whitelist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whitelistWithIdOnly = await prisma.whitelist.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WhitelistFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WhitelistFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Whitelist.
     * @param {WhitelistCreateArgs} args - Arguments to create a Whitelist.
     * @example
     * // Create one Whitelist
     * const Whitelist = await prisma.whitelist.create({
     *   data: {
     *     // ... data to create a Whitelist
     *   }
     * })
     * 
    **/
    create<T extends WhitelistCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WhitelistCreateArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Whitelists.
     *     @param {WhitelistCreateManyArgs} args - Arguments to create many Whitelists.
     *     @example
     *     // Create many Whitelists
     *     const whitelist = await prisma.whitelist.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WhitelistCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WhitelistCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Whitelist.
     * @param {WhitelistDeleteArgs} args - Arguments to delete one Whitelist.
     * @example
     * // Delete one Whitelist
     * const Whitelist = await prisma.whitelist.delete({
     *   where: {
     *     // ... filter to delete one Whitelist
     *   }
     * })
     * 
    **/
    delete<T extends WhitelistDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WhitelistDeleteArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Whitelist.
     * @param {WhitelistUpdateArgs} args - Arguments to update one Whitelist.
     * @example
     * // Update one Whitelist
     * const whitelist = await prisma.whitelist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WhitelistUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WhitelistUpdateArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Whitelists.
     * @param {WhitelistDeleteManyArgs} args - Arguments to filter Whitelists to delete.
     * @example
     * // Delete a few Whitelists
     * const { count } = await prisma.whitelist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WhitelistDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WhitelistDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whitelists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whitelists
     * const whitelist = await prisma.whitelist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WhitelistUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WhitelistUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Whitelist.
     * @param {WhitelistUpsertArgs} args - Arguments to update or create a Whitelist.
     * @example
     * // Update or create a Whitelist
     * const whitelist = await prisma.whitelist.upsert({
     *   create: {
     *     // ... data to create a Whitelist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whitelist we want to update
     *   }
     * })
    **/
    upsert<T extends WhitelistUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WhitelistUpsertArgs<ExtArgs>>
    ): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Whitelists that matches the filter.
     * @param {WhitelistFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const whitelist = await prisma.whitelist.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: WhitelistFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Whitelist.
     * @param {WhitelistAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const whitelist = await prisma.whitelist.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: WhitelistAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Whitelists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistCountArgs} args - Arguments to filter Whitelists to count.
     * @example
     * // Count the number of Whitelists
     * const count = await prisma.whitelist.count({
     *   where: {
     *     // ... the filter for the Whitelists we want to count
     *   }
     * })
    **/
    count<T extends WhitelistCountArgs>(
      args?: Subset<T, WhitelistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhitelistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whitelist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhitelistAggregateArgs>(args: Subset<T, WhitelistAggregateArgs>): Prisma.PrismaPromise<GetWhitelistAggregateType<T>>

    /**
     * Group by Whitelist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhitelistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhitelistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhitelistGroupByArgs['orderBy'] }
        : { orderBy?: WhitelistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhitelistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhitelistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Whitelist model
   */
  readonly fields: WhitelistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Whitelist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhitelistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teamAccount<T extends Whitelist$teamAccountArgs<ExtArgs> = {}>(args?: Subset<T, Whitelist$teamAccountArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Whitelist model
   */ 
  interface WhitelistFieldRefs {
    readonly id: FieldRef<"Whitelist", 'String'>
    readonly githubName: FieldRef<"Whitelist", 'String'>
    readonly quantity: FieldRef<"Whitelist", 'Int'>
    readonly createdAt: FieldRef<"Whitelist", 'DateTime'>
    readonly teamAccountId: FieldRef<"Whitelist", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Whitelist findUnique
   */
  export type WhitelistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * Filter, which Whitelist to fetch.
     */
    where: WhitelistWhereUniqueInput
  }


  /**
   * Whitelist findUniqueOrThrow
   */
  export type WhitelistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * Filter, which Whitelist to fetch.
     */
    where: WhitelistWhereUniqueInput
  }


  /**
   * Whitelist findFirst
   */
  export type WhitelistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * Filter, which Whitelist to fetch.
     */
    where?: WhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whitelists to fetch.
     */
    orderBy?: WhitelistOrderByWithRelationInput | WhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whitelists.
     */
    cursor?: WhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whitelists.
     */
    distinct?: WhitelistScalarFieldEnum | WhitelistScalarFieldEnum[]
  }


  /**
   * Whitelist findFirstOrThrow
   */
  export type WhitelistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * Filter, which Whitelist to fetch.
     */
    where?: WhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whitelists to fetch.
     */
    orderBy?: WhitelistOrderByWithRelationInput | WhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Whitelists.
     */
    cursor?: WhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whitelists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Whitelists.
     */
    distinct?: WhitelistScalarFieldEnum | WhitelistScalarFieldEnum[]
  }


  /**
   * Whitelist findMany
   */
  export type WhitelistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * Filter, which Whitelists to fetch.
     */
    where?: WhitelistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Whitelists to fetch.
     */
    orderBy?: WhitelistOrderByWithRelationInput | WhitelistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Whitelists.
     */
    cursor?: WhitelistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Whitelists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Whitelists.
     */
    skip?: number
    distinct?: WhitelistScalarFieldEnum | WhitelistScalarFieldEnum[]
  }


  /**
   * Whitelist create
   */
  export type WhitelistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * The data needed to create a Whitelist.
     */
    data: XOR<WhitelistCreateInput, WhitelistUncheckedCreateInput>
  }


  /**
   * Whitelist createMany
   */
  export type WhitelistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Whitelists.
     */
    data: WhitelistCreateManyInput | WhitelistCreateManyInput[]
  }


  /**
   * Whitelist update
   */
  export type WhitelistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * The data needed to update a Whitelist.
     */
    data: XOR<WhitelistUpdateInput, WhitelistUncheckedUpdateInput>
    /**
     * Choose, which Whitelist to update.
     */
    where: WhitelistWhereUniqueInput
  }


  /**
   * Whitelist updateMany
   */
  export type WhitelistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Whitelists.
     */
    data: XOR<WhitelistUpdateManyMutationInput, WhitelistUncheckedUpdateManyInput>
    /**
     * Filter which Whitelists to update
     */
    where?: WhitelistWhereInput
  }


  /**
   * Whitelist upsert
   */
  export type WhitelistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * The filter to search for the Whitelist to update in case it exists.
     */
    where: WhitelistWhereUniqueInput
    /**
     * In case the Whitelist found by the `where` argument doesn't exist, create a new Whitelist with this data.
     */
    create: XOR<WhitelistCreateInput, WhitelistUncheckedCreateInput>
    /**
     * In case the Whitelist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhitelistUpdateInput, WhitelistUncheckedUpdateInput>
  }


  /**
   * Whitelist delete
   */
  export type WhitelistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    /**
     * Filter which Whitelist to delete.
     */
    where: WhitelistWhereUniqueInput
  }


  /**
   * Whitelist deleteMany
   */
  export type WhitelistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Whitelists to delete
     */
    where?: WhitelistWhereInput
  }


  /**
   * Whitelist findRaw
   */
  export type WhitelistFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Whitelist aggregateRaw
   */
  export type WhitelistAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Whitelist.teamAccount
   */
  export type Whitelist$teamAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    where?: TeamAccountWhereInput
  }


  /**
   * Whitelist without action
   */
  export type WhitelistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
  }



  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }


  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends SessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionCreateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends SessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends SessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>
    ): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SessionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SessionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }


  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }


  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }


  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }


  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }


  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }


  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
  }



  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    email: string | null
    emailVerified: Date | null
    contactEmail: string | null
    image: string | null
    firstName: string | null
    lastName: string | null
    lastSeen: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    role: string | null
    email: string | null
    emailVerified: Date | null
    contactEmail: string | null
    image: string | null
    firstName: string | null
    lastName: string | null
    lastSeen: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    role: number
    email: number
    emailVerified: number
    contactEmail: number
    image: number
    firstName: number
    lastName: number
    lastSeen: number
    ownedTeamAccountIds: number
    teamAccountIds: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    role?: true
    email?: true
    emailVerified?: true
    contactEmail?: true
    image?: true
    firstName?: true
    lastName?: true
    lastSeen?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    role?: true
    email?: true
    emailVerified?: true
    contactEmail?: true
    image?: true
    firstName?: true
    lastName?: true
    lastSeen?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    role?: true
    email?: true
    emailVerified?: true
    contactEmail?: true
    image?: true
    firstName?: true
    lastName?: true
    lastSeen?: true
    ownedTeamAccountIds?: true
    teamAccountIds?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    role: string
    email: string
    emailVerified: Date | null
    contactEmail: string | null
    image: string | null
    firstName: string
    lastName: string
    lastSeen: Date
    ownedTeamAccountIds: string[]
    teamAccountIds: string[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    emailVerified?: boolean
    contactEmail?: boolean
    image?: boolean
    firstName?: boolean
    lastName?: boolean
    lastSeen?: boolean
    ownedTeamAccountIds?: boolean
    teamAccountIds?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    ownedTeamAccounts?: boolean | User$ownedTeamAccountsArgs<ExtArgs>
    teamAccounts?: boolean | User$teamAccountsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    evaluation?: boolean | User$evaluationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    role?: boolean
    email?: boolean
    emailVerified?: boolean
    contactEmail?: boolean
    image?: boolean
    firstName?: boolean
    lastName?: boolean
    lastSeen?: boolean
    ownedTeamAccountIds?: boolean
    teamAccountIds?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    ownedTeamAccounts?: boolean | User$ownedTeamAccountsArgs<ExtArgs>
    teamAccounts?: boolean | User$teamAccountsArgs<ExtArgs>
    notes?: boolean | User$notesArgs<ExtArgs>
    evaluation?: boolean | User$evaluationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      ownedTeamAccounts: Prisma.$TeamAccountPayload<ExtArgs>[]
      teamAccounts: Prisma.$TeamAccountPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      evaluation: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      role: string
      email: string
      emailVerified: Date | null
      contactEmail: string | null
      image: string | null
      firstName: string
      lastName: string
      lastSeen: Date
      ownedTeamAccountIds: string[]
      teamAccountIds: string[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    ownedTeamAccounts<T extends User$ownedTeamAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedTeamAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    teamAccounts<T extends User$teamAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends User$notesArgs<ExtArgs> = {}>(args?: Subset<T, User$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluation<T extends User$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, User$evaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly contactEmail: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly lastSeen: FieldRef<"User", 'DateTime'>
    readonly ownedTeamAccountIds: FieldRef<"User", 'String[]'>
    readonly teamAccountIds: FieldRef<"User", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }


  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * User.ownedTeamAccounts
   */
  export type User$ownedTeamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    where?: TeamAccountWhereInput
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    cursor?: TeamAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * User.teamAccounts
   */
  export type User$teamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    where?: TeamAccountWhereInput
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    cursor?: TeamAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * User.notes
   */
  export type User$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }


  /**
   * User.evaluation
   */
  export type User$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }


  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VerificationTokenFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VerificationTokenFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
    **/
    findMany<T extends VerificationTokenFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
    **/
    create<T extends VerificationTokenCreateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     *     @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     *     @example
     *     // Create many VerificationTokens
     *     const verificationToken = await prisma.verificationToken.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VerificationTokenCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
    **/
    delete<T extends VerificationTokenDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VerificationTokenUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VerificationTokenDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VerificationTokenUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
    **/
    upsert<T extends VerificationTokenUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>
    ): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * @param {VerificationTokenFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const verificationToken = await prisma.verificationToken.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: VerificationTokenFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VerificationToken.
     * @param {VerificationTokenAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const verificationToken = await prisma.verificationToken.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: VerificationTokenAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }


  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }


  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }


  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }


  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }


  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }


  /**
   * VerificationToken findRaw
   */
  export type VerificationTokenFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * VerificationToken aggregateRaw
   */
  export type VerificationTokenAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }



  /**
   * Model OneTimeCodes
   */

  export type AggregateOneTimeCodes = {
    _count: OneTimeCodesCountAggregateOutputType | null
    _min: OneTimeCodesMinAggregateOutputType | null
    _max: OneTimeCodesMaxAggregateOutputType | null
  }

  export type OneTimeCodesMinAggregateOutputType = {
    id: string | null
    code: string | null
    expires: Date | null
    type: string | null
    email: string | null
    createdAt: Date | null
    teamAccountId: string | null
  }

  export type OneTimeCodesMaxAggregateOutputType = {
    id: string | null
    code: string | null
    expires: Date | null
    type: string | null
    email: string | null
    createdAt: Date | null
    teamAccountId: string | null
  }

  export type OneTimeCodesCountAggregateOutputType = {
    id: number
    code: number
    expires: number
    type: number
    email: number
    createdAt: number
    teamAccountId: number
    _all: number
  }


  export type OneTimeCodesMinAggregateInputType = {
    id?: true
    code?: true
    expires?: true
    type?: true
    email?: true
    createdAt?: true
    teamAccountId?: true
  }

  export type OneTimeCodesMaxAggregateInputType = {
    id?: true
    code?: true
    expires?: true
    type?: true
    email?: true
    createdAt?: true
    teamAccountId?: true
  }

  export type OneTimeCodesCountAggregateInputType = {
    id?: true
    code?: true
    expires?: true
    type?: true
    email?: true
    createdAt?: true
    teamAccountId?: true
    _all?: true
  }

  export type OneTimeCodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneTimeCodes to aggregate.
     */
    where?: OneTimeCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeCodes to fetch.
     */
    orderBy?: OneTimeCodesOrderByWithRelationInput | OneTimeCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OneTimeCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OneTimeCodes
    **/
    _count?: true | OneTimeCodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OneTimeCodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OneTimeCodesMaxAggregateInputType
  }

  export type GetOneTimeCodesAggregateType<T extends OneTimeCodesAggregateArgs> = {
        [P in keyof T & keyof AggregateOneTimeCodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOneTimeCodes[P]>
      : GetScalarType<T[P], AggregateOneTimeCodes[P]>
  }




  export type OneTimeCodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OneTimeCodesWhereInput
    orderBy?: OneTimeCodesOrderByWithAggregationInput | OneTimeCodesOrderByWithAggregationInput[]
    by: OneTimeCodesScalarFieldEnum[] | OneTimeCodesScalarFieldEnum
    having?: OneTimeCodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OneTimeCodesCountAggregateInputType | true
    _min?: OneTimeCodesMinAggregateInputType
    _max?: OneTimeCodesMaxAggregateInputType
  }

  export type OneTimeCodesGroupByOutputType = {
    id: string
    code: string
    expires: Date
    type: string
    email: string
    createdAt: Date
    teamAccountId: string
    _count: OneTimeCodesCountAggregateOutputType | null
    _min: OneTimeCodesMinAggregateOutputType | null
    _max: OneTimeCodesMaxAggregateOutputType | null
  }

  type GetOneTimeCodesGroupByPayload<T extends OneTimeCodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OneTimeCodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OneTimeCodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OneTimeCodesGroupByOutputType[P]>
            : GetScalarType<T[P], OneTimeCodesGroupByOutputType[P]>
        }
      >
    >


  export type OneTimeCodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    expires?: boolean
    type?: boolean
    email?: boolean
    createdAt?: boolean
    teamAccountId?: boolean
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["oneTimeCodes"]>

  export type OneTimeCodesSelectScalar = {
    id?: boolean
    code?: boolean
    expires?: boolean
    type?: boolean
    email?: boolean
    createdAt?: boolean
    teamAccountId?: boolean
  }

  export type OneTimeCodesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
  }


  export type $OneTimeCodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OneTimeCodes"
    objects: {
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      expires: Date
      type: string
      email: string
      createdAt: Date
      teamAccountId: string
    }, ExtArgs["result"]["oneTimeCodes"]>
    composites: {}
  }


  type OneTimeCodesGetPayload<S extends boolean | null | undefined | OneTimeCodesDefaultArgs> = $Result.GetResult<Prisma.$OneTimeCodesPayload, S>

  type OneTimeCodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OneTimeCodesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: OneTimeCodesCountAggregateInputType | true
    }

  export interface OneTimeCodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OneTimeCodes'], meta: { name: 'OneTimeCodes' } }
    /**
     * Find zero or one OneTimeCodes that matches the filter.
     * @param {OneTimeCodesFindUniqueArgs} args - Arguments to find a OneTimeCodes
     * @example
     * // Get one OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OneTimeCodesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OneTimeCodesFindUniqueArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one OneTimeCodes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OneTimeCodesFindUniqueOrThrowArgs} args - Arguments to find a OneTimeCodes
     * @example
     * // Get one OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OneTimeCodesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OneTimeCodesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first OneTimeCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesFindFirstArgs} args - Arguments to find a OneTimeCodes
     * @example
     * // Get one OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OneTimeCodesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OneTimeCodesFindFirstArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first OneTimeCodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesFindFirstOrThrowArgs} args - Arguments to find a OneTimeCodes
     * @example
     * // Get one OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OneTimeCodesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OneTimeCodesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more OneTimeCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.findMany()
     * 
     * // Get first 10 OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oneTimeCodesWithIdOnly = await prisma.oneTimeCodes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OneTimeCodesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OneTimeCodesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a OneTimeCodes.
     * @param {OneTimeCodesCreateArgs} args - Arguments to create a OneTimeCodes.
     * @example
     * // Create one OneTimeCodes
     * const OneTimeCodes = await prisma.oneTimeCodes.create({
     *   data: {
     *     // ... data to create a OneTimeCodes
     *   }
     * })
     * 
    **/
    create<T extends OneTimeCodesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OneTimeCodesCreateArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many OneTimeCodes.
     *     @param {OneTimeCodesCreateManyArgs} args - Arguments to create many OneTimeCodes.
     *     @example
     *     // Create many OneTimeCodes
     *     const oneTimeCodes = await prisma.oneTimeCodes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OneTimeCodesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OneTimeCodesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OneTimeCodes.
     * @param {OneTimeCodesDeleteArgs} args - Arguments to delete one OneTimeCodes.
     * @example
     * // Delete one OneTimeCodes
     * const OneTimeCodes = await prisma.oneTimeCodes.delete({
     *   where: {
     *     // ... filter to delete one OneTimeCodes
     *   }
     * })
     * 
    **/
    delete<T extends OneTimeCodesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OneTimeCodesDeleteArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one OneTimeCodes.
     * @param {OneTimeCodesUpdateArgs} args - Arguments to update one OneTimeCodes.
     * @example
     * // Update one OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OneTimeCodesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OneTimeCodesUpdateArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more OneTimeCodes.
     * @param {OneTimeCodesDeleteManyArgs} args - Arguments to filter OneTimeCodes to delete.
     * @example
     * // Delete a few OneTimeCodes
     * const { count } = await prisma.oneTimeCodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OneTimeCodesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OneTimeCodesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OneTimeCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OneTimeCodesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OneTimeCodesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OneTimeCodes.
     * @param {OneTimeCodesUpsertArgs} args - Arguments to update or create a OneTimeCodes.
     * @example
     * // Update or create a OneTimeCodes
     * const oneTimeCodes = await prisma.oneTimeCodes.upsert({
     *   create: {
     *     // ... data to create a OneTimeCodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OneTimeCodes we want to update
     *   }
     * })
    **/
    upsert<T extends OneTimeCodesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OneTimeCodesUpsertArgs<ExtArgs>>
    ): Prisma__OneTimeCodesClient<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more OneTimeCodes that matches the filter.
     * @param {OneTimeCodesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const oneTimeCodes = await prisma.oneTimeCodes.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OneTimeCodesFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a OneTimeCodes.
     * @param {OneTimeCodesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const oneTimeCodes = await prisma.oneTimeCodes.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OneTimeCodesAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of OneTimeCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesCountArgs} args - Arguments to filter OneTimeCodes to count.
     * @example
     * // Count the number of OneTimeCodes
     * const count = await prisma.oneTimeCodes.count({
     *   where: {
     *     // ... the filter for the OneTimeCodes we want to count
     *   }
     * })
    **/
    count<T extends OneTimeCodesCountArgs>(
      args?: Subset<T, OneTimeCodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OneTimeCodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OneTimeCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OneTimeCodesAggregateArgs>(args: Subset<T, OneTimeCodesAggregateArgs>): Prisma.PrismaPromise<GetOneTimeCodesAggregateType<T>>

    /**
     * Group by OneTimeCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OneTimeCodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OneTimeCodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OneTimeCodesGroupByArgs['orderBy'] }
        : { orderBy?: OneTimeCodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OneTimeCodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOneTimeCodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OneTimeCodes model
   */
  readonly fields: OneTimeCodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OneTimeCodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OneTimeCodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the OneTimeCodes model
   */ 
  interface OneTimeCodesFieldRefs {
    readonly id: FieldRef<"OneTimeCodes", 'String'>
    readonly code: FieldRef<"OneTimeCodes", 'String'>
    readonly expires: FieldRef<"OneTimeCodes", 'DateTime'>
    readonly type: FieldRef<"OneTimeCodes", 'String'>
    readonly email: FieldRef<"OneTimeCodes", 'String'>
    readonly createdAt: FieldRef<"OneTimeCodes", 'DateTime'>
    readonly teamAccountId: FieldRef<"OneTimeCodes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * OneTimeCodes findUnique
   */
  export type OneTimeCodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeCodes to fetch.
     */
    where: OneTimeCodesWhereUniqueInput
  }


  /**
   * OneTimeCodes findUniqueOrThrow
   */
  export type OneTimeCodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeCodes to fetch.
     */
    where: OneTimeCodesWhereUniqueInput
  }


  /**
   * OneTimeCodes findFirst
   */
  export type OneTimeCodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeCodes to fetch.
     */
    where?: OneTimeCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeCodes to fetch.
     */
    orderBy?: OneTimeCodesOrderByWithRelationInput | OneTimeCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneTimeCodes.
     */
    cursor?: OneTimeCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneTimeCodes.
     */
    distinct?: OneTimeCodesScalarFieldEnum | OneTimeCodesScalarFieldEnum[]
  }


  /**
   * OneTimeCodes findFirstOrThrow
   */
  export type OneTimeCodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeCodes to fetch.
     */
    where?: OneTimeCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeCodes to fetch.
     */
    orderBy?: OneTimeCodesOrderByWithRelationInput | OneTimeCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OneTimeCodes.
     */
    cursor?: OneTimeCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OneTimeCodes.
     */
    distinct?: OneTimeCodesScalarFieldEnum | OneTimeCodesScalarFieldEnum[]
  }


  /**
   * OneTimeCodes findMany
   */
  export type OneTimeCodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * Filter, which OneTimeCodes to fetch.
     */
    where?: OneTimeCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OneTimeCodes to fetch.
     */
    orderBy?: OneTimeCodesOrderByWithRelationInput | OneTimeCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OneTimeCodes.
     */
    cursor?: OneTimeCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OneTimeCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OneTimeCodes.
     */
    skip?: number
    distinct?: OneTimeCodesScalarFieldEnum | OneTimeCodesScalarFieldEnum[]
  }


  /**
   * OneTimeCodes create
   */
  export type OneTimeCodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * The data needed to create a OneTimeCodes.
     */
    data: XOR<OneTimeCodesCreateInput, OneTimeCodesUncheckedCreateInput>
  }


  /**
   * OneTimeCodes createMany
   */
  export type OneTimeCodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OneTimeCodes.
     */
    data: OneTimeCodesCreateManyInput | OneTimeCodesCreateManyInput[]
  }


  /**
   * OneTimeCodes update
   */
  export type OneTimeCodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * The data needed to update a OneTimeCodes.
     */
    data: XOR<OneTimeCodesUpdateInput, OneTimeCodesUncheckedUpdateInput>
    /**
     * Choose, which OneTimeCodes to update.
     */
    where: OneTimeCodesWhereUniqueInput
  }


  /**
   * OneTimeCodes updateMany
   */
  export type OneTimeCodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OneTimeCodes.
     */
    data: XOR<OneTimeCodesUpdateManyMutationInput, OneTimeCodesUncheckedUpdateManyInput>
    /**
     * Filter which OneTimeCodes to update
     */
    where?: OneTimeCodesWhereInput
  }


  /**
   * OneTimeCodes upsert
   */
  export type OneTimeCodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * The filter to search for the OneTimeCodes to update in case it exists.
     */
    where: OneTimeCodesWhereUniqueInput
    /**
     * In case the OneTimeCodes found by the `where` argument doesn't exist, create a new OneTimeCodes with this data.
     */
    create: XOR<OneTimeCodesCreateInput, OneTimeCodesUncheckedCreateInput>
    /**
     * In case the OneTimeCodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OneTimeCodesUpdateInput, OneTimeCodesUncheckedUpdateInput>
  }


  /**
   * OneTimeCodes delete
   */
  export type OneTimeCodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    /**
     * Filter which OneTimeCodes to delete.
     */
    where: OneTimeCodesWhereUniqueInput
  }


  /**
   * OneTimeCodes deleteMany
   */
  export type OneTimeCodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OneTimeCodes to delete
     */
    where?: OneTimeCodesWhereInput
  }


  /**
   * OneTimeCodes findRaw
   */
  export type OneTimeCodesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OneTimeCodes aggregateRaw
   */
  export type OneTimeCodesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * OneTimeCodes without action
   */
  export type OneTimeCodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
  }



  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    featureList: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    featureList?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    featureList: string[]
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    featureList?: boolean
    teamAccounts?: boolean | Subscription$teamAccountsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    featureList?: boolean
  }

  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamAccounts?: boolean | Subscription$teamAccountsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      teamAccounts: Prisma.$TeamAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      featureList: string[]
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }


  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SubscriptionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Subscription that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SubscriptionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SubscriptionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
    **/
    create<T extends SubscriptionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Subscriptions.
     *     @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     *     @example
     *     // Create many Subscriptions
     *     const subscription = await prisma.subscription.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SubscriptionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
    **/
    delete<T extends SubscriptionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SubscriptionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SubscriptionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SubscriptionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
    **/
    upsert<T extends SubscriptionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * @param {SubscriptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const subscription = await prisma.subscription.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SubscriptionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Subscription.
     * @param {SubscriptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const subscription = await prisma.subscription.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SubscriptionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teamAccounts<T extends Subscription$teamAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$teamAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Subscription model
   */ 
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly featureList: FieldRef<"Subscription", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }


  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data?: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }


  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
  }


  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }


  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }


  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
  }


  /**
   * Subscription findRaw
   */
  export type SubscriptionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Subscription aggregateRaw
   */
  export type SubscriptionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Subscription.teamAccounts
   */
  export type Subscription$teamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    where?: TeamAccountWhereInput
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    cursor?: TeamAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }



  /**
   * Model TeamAccount
   */

  export type AggregateTeamAccount = {
    _count: TeamAccountCountAggregateOutputType | null
    _min: TeamAccountMinAggregateOutputType | null
    _max: TeamAccountMaxAggregateOutputType | null
  }

  export type TeamAccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    aliasEmail: string | null
    subscriptionId: string | null
  }

  export type TeamAccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    aliasEmail: string | null
    subscriptionId: string | null
  }

  export type TeamAccountCountAggregateOutputType = {
    id: number
    name: number
    aliasEmail: number
    verifiedEmailAddresses: number
    teamAccountUserIds: number
    ownerIds: number
    campaignIds: number
    subscriptionId: number
    _all: number
  }


  export type TeamAccountMinAggregateInputType = {
    id?: true
    name?: true
    aliasEmail?: true
    subscriptionId?: true
  }

  export type TeamAccountMaxAggregateInputType = {
    id?: true
    name?: true
    aliasEmail?: true
    subscriptionId?: true
  }

  export type TeamAccountCountAggregateInputType = {
    id?: true
    name?: true
    aliasEmail?: true
    verifiedEmailAddresses?: true
    teamAccountUserIds?: true
    ownerIds?: true
    campaignIds?: true
    subscriptionId?: true
    _all?: true
  }

  export type TeamAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamAccount to aggregate.
     */
    where?: TeamAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAccounts to fetch.
     */
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamAccounts
    **/
    _count?: true | TeamAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamAccountMaxAggregateInputType
  }

  export type GetTeamAccountAggregateType<T extends TeamAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamAccount[P]>
      : GetScalarType<T[P], AggregateTeamAccount[P]>
  }




  export type TeamAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamAccountWhereInput
    orderBy?: TeamAccountOrderByWithAggregationInput | TeamAccountOrderByWithAggregationInput[]
    by: TeamAccountScalarFieldEnum[] | TeamAccountScalarFieldEnum
    having?: TeamAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamAccountCountAggregateInputType | true
    _min?: TeamAccountMinAggregateInputType
    _max?: TeamAccountMaxAggregateInputType
  }

  export type TeamAccountGroupByOutputType = {
    id: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses: string[]
    teamAccountUserIds: string[]
    ownerIds: string[]
    campaignIds: string[]
    subscriptionId: string | null
    _count: TeamAccountCountAggregateOutputType | null
    _min: TeamAccountMinAggregateOutputType | null
    _max: TeamAccountMaxAggregateOutputType | null
  }

  type GetTeamAccountGroupByPayload<T extends TeamAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamAccountGroupByOutputType[P]>
            : GetScalarType<T[P], TeamAccountGroupByOutputType[P]>
        }
      >
    >


  export type TeamAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    aliasEmail?: boolean
    verifiedEmailAddresses?: boolean
    teamAccountUserIds?: boolean
    ownerIds?: boolean
    campaignIds?: boolean
    subscriptionId?: boolean
    inviteCodes?: boolean | TeamAccount$inviteCodesArgs<ExtArgs>
    teamAccountUsers?: boolean | TeamAccount$teamAccountUsersArgs<ExtArgs>
    contacts?: boolean | TeamAccount$contactsArgs<ExtArgs>
    emails?: boolean | TeamAccount$emailsArgs<ExtArgs>
    owners?: boolean | TeamAccount$ownersArgs<ExtArgs>
    emailThreads?: boolean | TeamAccount$emailThreadsArgs<ExtArgs>
    campaigns?: boolean | TeamAccount$campaignsArgs<ExtArgs>
    notes?: boolean | TeamAccount$notesArgs<ExtArgs>
    targetContact?: boolean | TeamAccount$targetContactArgs<ExtArgs>
    evaluation?: boolean | TeamAccount$evaluationArgs<ExtArgs>
    subscription?: boolean | TeamAccount$subscriptionArgs<ExtArgs>
    whitelist?: boolean | TeamAccount$whitelistArgs<ExtArgs>
    _count?: boolean | TeamAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamAccount"]>

  export type TeamAccountSelectScalar = {
    id?: boolean
    name?: boolean
    aliasEmail?: boolean
    verifiedEmailAddresses?: boolean
    teamAccountUserIds?: boolean
    ownerIds?: boolean
    campaignIds?: boolean
    subscriptionId?: boolean
  }

  export type TeamAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inviteCodes?: boolean | TeamAccount$inviteCodesArgs<ExtArgs>
    teamAccountUsers?: boolean | TeamAccount$teamAccountUsersArgs<ExtArgs>
    contacts?: boolean | TeamAccount$contactsArgs<ExtArgs>
    emails?: boolean | TeamAccount$emailsArgs<ExtArgs>
    owners?: boolean | TeamAccount$ownersArgs<ExtArgs>
    emailThreads?: boolean | TeamAccount$emailThreadsArgs<ExtArgs>
    campaigns?: boolean | TeamAccount$campaignsArgs<ExtArgs>
    notes?: boolean | TeamAccount$notesArgs<ExtArgs>
    targetContact?: boolean | TeamAccount$targetContactArgs<ExtArgs>
    evaluation?: boolean | TeamAccount$evaluationArgs<ExtArgs>
    subscription?: boolean | TeamAccount$subscriptionArgs<ExtArgs>
    whitelist?: boolean | TeamAccount$whitelistArgs<ExtArgs>
    _count?: boolean | TeamAccountCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TeamAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamAccount"
    objects: {
      inviteCodes: Prisma.$OneTimeCodesPayload<ExtArgs>[]
      teamAccountUsers: Prisma.$UserPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      emails: Prisma.$EmailPayload<ExtArgs>[]
      owners: Prisma.$UserPayload<ExtArgs>[]
      emailThreads: Prisma.$EmailThreadPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      targetContact: Prisma.$TargetContactPayload<ExtArgs>[]
      evaluation: Prisma.$EvaluationPayload<ExtArgs>[]
      subscription: Prisma.$SubscriptionPayload<ExtArgs> | null
      whitelist: Prisma.$WhitelistPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      aliasEmail: string
      verifiedEmailAddresses: string[]
      teamAccountUserIds: string[]
      ownerIds: string[]
      campaignIds: string[]
      subscriptionId: string | null
    }, ExtArgs["result"]["teamAccount"]>
    composites: {}
  }


  type TeamAccountGetPayload<S extends boolean | null | undefined | TeamAccountDefaultArgs> = $Result.GetResult<Prisma.$TeamAccountPayload, S>

  type TeamAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamAccountFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TeamAccountCountAggregateInputType | true
    }

  export interface TeamAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamAccount'], meta: { name: 'TeamAccount' } }
    /**
     * Find zero or one TeamAccount that matches the filter.
     * @param {TeamAccountFindUniqueArgs} args - Arguments to find a TeamAccount
     * @example
     * // Get one TeamAccount
     * const teamAccount = await prisma.teamAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TeamAccountFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TeamAccountFindUniqueArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TeamAccount that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TeamAccountFindUniqueOrThrowArgs} args - Arguments to find a TeamAccount
     * @example
     * // Get one TeamAccount
     * const teamAccount = await prisma.teamAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TeamAccountFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamAccountFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TeamAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountFindFirstArgs} args - Arguments to find a TeamAccount
     * @example
     * // Get one TeamAccount
     * const teamAccount = await prisma.teamAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TeamAccountFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamAccountFindFirstArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TeamAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountFindFirstOrThrowArgs} args - Arguments to find a TeamAccount
     * @example
     * // Get one TeamAccount
     * const teamAccount = await prisma.teamAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TeamAccountFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamAccountFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TeamAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamAccounts
     * const teamAccounts = await prisma.teamAccount.findMany()
     * 
     * // Get first 10 TeamAccounts
     * const teamAccounts = await prisma.teamAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamAccountWithIdOnly = await prisma.teamAccount.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TeamAccountFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamAccountFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TeamAccount.
     * @param {TeamAccountCreateArgs} args - Arguments to create a TeamAccount.
     * @example
     * // Create one TeamAccount
     * const TeamAccount = await prisma.teamAccount.create({
     *   data: {
     *     // ... data to create a TeamAccount
     *   }
     * })
     * 
    **/
    create<T extends TeamAccountCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamAccountCreateArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TeamAccounts.
     *     @param {TeamAccountCreateManyArgs} args - Arguments to create many TeamAccounts.
     *     @example
     *     // Create many TeamAccounts
     *     const teamAccount = await prisma.teamAccount.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TeamAccountCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamAccountCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamAccount.
     * @param {TeamAccountDeleteArgs} args - Arguments to delete one TeamAccount.
     * @example
     * // Delete one TeamAccount
     * const TeamAccount = await prisma.teamAccount.delete({
     *   where: {
     *     // ... filter to delete one TeamAccount
     *   }
     * })
     * 
    **/
    delete<T extends TeamAccountDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TeamAccountDeleteArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TeamAccount.
     * @param {TeamAccountUpdateArgs} args - Arguments to update one TeamAccount.
     * @example
     * // Update one TeamAccount
     * const teamAccount = await prisma.teamAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TeamAccountUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TeamAccountUpdateArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TeamAccounts.
     * @param {TeamAccountDeleteManyArgs} args - Arguments to filter TeamAccounts to delete.
     * @example
     * // Delete a few TeamAccounts
     * const { count } = await prisma.teamAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TeamAccountDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TeamAccountDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamAccounts
     * const teamAccount = await prisma.teamAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TeamAccountUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TeamAccountUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamAccount.
     * @param {TeamAccountUpsertArgs} args - Arguments to update or create a TeamAccount.
     * @example
     * // Update or create a TeamAccount
     * const teamAccount = await prisma.teamAccount.upsert({
     *   create: {
     *     // ... data to create a TeamAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamAccount we want to update
     *   }
     * })
    **/
    upsert<T extends TeamAccountUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TeamAccountUpsertArgs<ExtArgs>>
    ): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more TeamAccounts that matches the filter.
     * @param {TeamAccountFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const teamAccount = await prisma.teamAccount.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TeamAccountFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TeamAccount.
     * @param {TeamAccountAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const teamAccount = await prisma.teamAccount.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TeamAccountAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TeamAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountCountArgs} args - Arguments to filter TeamAccounts to count.
     * @example
     * // Count the number of TeamAccounts
     * const count = await prisma.teamAccount.count({
     *   where: {
     *     // ... the filter for the TeamAccounts we want to count
     *   }
     * })
    **/
    count<T extends TeamAccountCountArgs>(
      args?: Subset<T, TeamAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAccountAggregateArgs>(args: Subset<T, TeamAccountAggregateArgs>): Prisma.PrismaPromise<GetTeamAccountAggregateType<T>>

    /**
     * Group by TeamAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamAccountGroupByArgs['orderBy'] }
        : { orderBy?: TeamAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamAccount model
   */
  readonly fields: TeamAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    inviteCodes<T extends TeamAccount$inviteCodesArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$inviteCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OneTimeCodesPayload<ExtArgs>, T, 'findMany'> | Null>;

    teamAccountUsers<T extends TeamAccount$teamAccountUsersArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$teamAccountUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    contacts<T extends TeamAccount$contactsArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    emails<T extends TeamAccount$emailsArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'> | Null>;

    owners<T extends TeamAccount$ownersArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$ownersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    emailThreads<T extends TeamAccount$emailThreadsArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$emailThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findMany'> | Null>;

    campaigns<T extends TeamAccount$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends TeamAccount$notesArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findMany'> | Null>;

    targetContact<T extends TeamAccount$targetContactArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$targetContactArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluation<T extends TeamAccount$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$evaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    subscription<T extends TeamAccount$subscriptionArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$subscriptionArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    whitelist<T extends TeamAccount$whitelistArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccount$whitelistArgs<ExtArgs>>): Prisma__WhitelistClient<$Result.GetResult<Prisma.$WhitelistPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TeamAccount model
   */ 
  interface TeamAccountFieldRefs {
    readonly id: FieldRef<"TeamAccount", 'String'>
    readonly name: FieldRef<"TeamAccount", 'String'>
    readonly aliasEmail: FieldRef<"TeamAccount", 'String'>
    readonly verifiedEmailAddresses: FieldRef<"TeamAccount", 'String[]'>
    readonly teamAccountUserIds: FieldRef<"TeamAccount", 'String[]'>
    readonly ownerIds: FieldRef<"TeamAccount", 'String[]'>
    readonly campaignIds: FieldRef<"TeamAccount", 'String[]'>
    readonly subscriptionId: FieldRef<"TeamAccount", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TeamAccount findUnique
   */
  export type TeamAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * Filter, which TeamAccount to fetch.
     */
    where: TeamAccountWhereUniqueInput
  }


  /**
   * TeamAccount findUniqueOrThrow
   */
  export type TeamAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * Filter, which TeamAccount to fetch.
     */
    where: TeamAccountWhereUniqueInput
  }


  /**
   * TeamAccount findFirst
   */
  export type TeamAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * Filter, which TeamAccount to fetch.
     */
    where?: TeamAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAccounts to fetch.
     */
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamAccounts.
     */
    cursor?: TeamAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamAccounts.
     */
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * TeamAccount findFirstOrThrow
   */
  export type TeamAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * Filter, which TeamAccount to fetch.
     */
    where?: TeamAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAccounts to fetch.
     */
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamAccounts.
     */
    cursor?: TeamAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamAccounts.
     */
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * TeamAccount findMany
   */
  export type TeamAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * Filter, which TeamAccounts to fetch.
     */
    where?: TeamAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamAccounts to fetch.
     */
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamAccounts.
     */
    cursor?: TeamAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamAccounts.
     */
    skip?: number
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * TeamAccount create
   */
  export type TeamAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamAccount.
     */
    data: XOR<TeamAccountCreateInput, TeamAccountUncheckedCreateInput>
  }


  /**
   * TeamAccount createMany
   */
  export type TeamAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamAccounts.
     */
    data: TeamAccountCreateManyInput | TeamAccountCreateManyInput[]
  }


  /**
   * TeamAccount update
   */
  export type TeamAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamAccount.
     */
    data: XOR<TeamAccountUpdateInput, TeamAccountUncheckedUpdateInput>
    /**
     * Choose, which TeamAccount to update.
     */
    where: TeamAccountWhereUniqueInput
  }


  /**
   * TeamAccount updateMany
   */
  export type TeamAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamAccounts.
     */
    data: XOR<TeamAccountUpdateManyMutationInput, TeamAccountUncheckedUpdateManyInput>
    /**
     * Filter which TeamAccounts to update
     */
    where?: TeamAccountWhereInput
  }


  /**
   * TeamAccount upsert
   */
  export type TeamAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamAccount to update in case it exists.
     */
    where: TeamAccountWhereUniqueInput
    /**
     * In case the TeamAccount found by the `where` argument doesn't exist, create a new TeamAccount with this data.
     */
    create: XOR<TeamAccountCreateInput, TeamAccountUncheckedCreateInput>
    /**
     * In case the TeamAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamAccountUpdateInput, TeamAccountUncheckedUpdateInput>
  }


  /**
   * TeamAccount delete
   */
  export type TeamAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    /**
     * Filter which TeamAccount to delete.
     */
    where: TeamAccountWhereUniqueInput
  }


  /**
   * TeamAccount deleteMany
   */
  export type TeamAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamAccounts to delete
     */
    where?: TeamAccountWhereInput
  }


  /**
   * TeamAccount findRaw
   */
  export type TeamAccountFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TeamAccount aggregateRaw
   */
  export type TeamAccountAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TeamAccount.inviteCodes
   */
  export type TeamAccount$inviteCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OneTimeCodes
     */
    select?: OneTimeCodesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OneTimeCodesInclude<ExtArgs> | null
    where?: OneTimeCodesWhereInput
    orderBy?: OneTimeCodesOrderByWithRelationInput | OneTimeCodesOrderByWithRelationInput[]
    cursor?: OneTimeCodesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OneTimeCodesScalarFieldEnum | OneTimeCodesScalarFieldEnum[]
  }


  /**
   * TeamAccount.teamAccountUsers
   */
  export type TeamAccount$teamAccountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * TeamAccount.contacts
   */
  export type TeamAccount$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * TeamAccount.emails
   */
  export type TeamAccount$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * TeamAccount.owners
   */
  export type TeamAccount$ownersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * TeamAccount.emailThreads
   */
  export type TeamAccount$emailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }


  /**
   * TeamAccount.campaigns
   */
  export type TeamAccount$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * TeamAccount.notes
   */
  export type TeamAccount$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }


  /**
   * TeamAccount.targetContact
   */
  export type TeamAccount$targetContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    where?: TargetContactWhereInput
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    cursor?: TargetContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetContactScalarFieldEnum | TargetContactScalarFieldEnum[]
  }


  /**
   * TeamAccount.evaluation
   */
  export type TeamAccount$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * TeamAccount.subscription
   */
  export type TeamAccount$subscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
  }


  /**
   * TeamAccount.whitelist
   */
  export type TeamAccount$whitelistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whitelist
     */
    select?: WhitelistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WhitelistInclude<ExtArgs> | null
    where?: WhitelistWhereInput
  }


  /**
   * TeamAccount without action
   */
  export type TeamAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
  }



  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    email: string | null
    teamAccountId: string | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    email: string | null
    teamAccountId: string | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    email: number
    contactEmails: number
    teamAccountId: number
    emailIds: number
    emailThreadIds: number
    targetIds: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    email?: true
    teamAccountId?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    email?: true
    teamAccountId?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    email?: true
    contactEmails?: true
    teamAccountId?: true
    emailIds?: true
    emailThreadIds?: true
    targetIds?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    email: string | null
    contactEmails: string[]
    teamAccountId: string
    emailIds: string[]
    emailThreadIds: string[]
    targetIds: string[]
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    email?: boolean
    contactEmails?: boolean
    teamAccountId?: boolean
    emailIds?: boolean
    emailThreadIds?: boolean
    targetIds?: boolean
    creatingTeamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    emails?: boolean | Contact$emailsArgs<ExtArgs>
    emailThreads?: boolean | Contact$emailThreadsArgs<ExtArgs>
    githubTargets?: boolean | Contact$githubTargetsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    email?: boolean
    contactEmails?: boolean
    teamAccountId?: boolean
    emailIds?: boolean
    emailThreadIds?: boolean
    targetIds?: boolean
  }

  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creatingTeamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    emails?: boolean | Contact$emailsArgs<ExtArgs>
    emailThreads?: boolean | Contact$emailThreadsArgs<ExtArgs>
    githubTargets?: boolean | Contact$githubTargetsArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      creatingTeamAccount: Prisma.$TeamAccountPayload<ExtArgs>
      emails: Prisma.$EmailPayload<ExtArgs>[]
      emailThreads: Prisma.$EmailThreadPayload<ExtArgs>[]
      githubTargets: Prisma.$GithubTargetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      email: string | null
      contactEmails: string[]
      teamAccountId: string
      emailIds: string[]
      emailThreadIds: string[]
      targetIds: string[]
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }


  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContactFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Contact that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContactFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
    **/
    create<T extends ContactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactCreateArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Contacts.
     *     @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     *     @example
     *     // Create many Contacts
     *     const contact = await prisma.contact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
    **/
    delete<T extends ContactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
    **/
    upsert<T extends ContactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>
    ): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Contacts that matches the filter.
     * @param {ContactFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contact = await prisma.contact.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ContactFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Contact.
     * @param {ContactAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contact = await prisma.contact.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ContactAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    creatingTeamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    emails<T extends Contact$emailsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'> | Null>;

    emailThreads<T extends Contact$emailThreadsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$emailThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findMany'> | Null>;

    githubTargets<T extends Contact$githubTargetsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$githubTargetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Contact model
   */ 
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly name: FieldRef<"Contact", 'String'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly contactEmails: FieldRef<"Contact", 'String[]'>
    readonly teamAccountId: FieldRef<"Contact", 'String'>
    readonly emailIds: FieldRef<"Contact", 'String[]'>
    readonly emailThreadIds: FieldRef<"Contact", 'String[]'>
    readonly targetIds: FieldRef<"Contact", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }


  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
  }


  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
  }


  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }


  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }


  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
  }


  /**
   * Contact findRaw
   */
  export type ContactFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Contact aggregateRaw
   */
  export type ContactAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Contact.emails
   */
  export type Contact$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Contact.emailThreads
   */
  export type Contact$emailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }


  /**
   * Contact.githubTargets
   */
  export type Contact$githubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    where?: GithubTargetWhereInput
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    cursor?: GithubTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
  }



  /**
   * Model Email
   */

  export type AggregateEmail = {
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  export type EmailMinAggregateOutputType = {
    id: string | null
    from: string | null
    subject: string | null
    text: string | null
    sentByUser: boolean | null
    sentAt: Date | null
    teamAccountId: string | null
    messageId: string | null
    emailThreadId: string | null
  }

  export type EmailMaxAggregateOutputType = {
    id: string | null
    from: string | null
    subject: string | null
    text: string | null
    sentByUser: boolean | null
    sentAt: Date | null
    teamAccountId: string | null
    messageId: string | null
    emailThreadId: string | null
  }

  export type EmailCountAggregateOutputType = {
    id: number
    to: number
    bcc: number
    cc: number
    from: number
    subject: number
    text: number
    sentByUser: number
    sentAt: number
    contactIds: number
    teamAccountId: number
    messageId: number
    emailThreadId: number
    _all: number
  }


  export type EmailMinAggregateInputType = {
    id?: true
    from?: true
    subject?: true
    text?: true
    sentByUser?: true
    sentAt?: true
    teamAccountId?: true
    messageId?: true
    emailThreadId?: true
  }

  export type EmailMaxAggregateInputType = {
    id?: true
    from?: true
    subject?: true
    text?: true
    sentByUser?: true
    sentAt?: true
    teamAccountId?: true
    messageId?: true
    emailThreadId?: true
  }

  export type EmailCountAggregateInputType = {
    id?: true
    to?: true
    bcc?: true
    cc?: true
    from?: true
    subject?: true
    text?: true
    sentByUser?: true
    sentAt?: true
    contactIds?: true
    teamAccountId?: true
    messageId?: true
    emailThreadId?: true
    _all?: true
  }

  export type EmailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Email to aggregate.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emails
    **/
    _count?: true | EmailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailMaxAggregateInputType
  }

  export type GetEmailAggregateType<T extends EmailAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail[P]>
      : GetScalarType<T[P], AggregateEmail[P]>
  }




  export type EmailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithAggregationInput | EmailOrderByWithAggregationInput[]
    by: EmailScalarFieldEnum[] | EmailScalarFieldEnum
    having?: EmailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailCountAggregateInputType | true
    _min?: EmailMinAggregateInputType
    _max?: EmailMaxAggregateInputType
  }

  export type EmailGroupByOutputType = {
    id: string
    to: string[]
    bcc: string[]
    cc: string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt: Date
    contactIds: string[]
    teamAccountId: string
    messageId: string
    emailThreadId: string
    _count: EmailCountAggregateOutputType | null
    _min: EmailMinAggregateOutputType | null
    _max: EmailMaxAggregateOutputType | null
  }

  type GetEmailGroupByPayload<T extends EmailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailGroupByOutputType[P]>
            : GetScalarType<T[P], EmailGroupByOutputType[P]>
        }
      >
    >


  export type EmailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    to?: boolean
    bcc?: boolean
    cc?: boolean
    from?: boolean
    subject?: boolean
    text?: boolean
    sentByUser?: boolean
    sentAt?: boolean
    contactIds?: boolean
    teamAccountId?: boolean
    messageId?: boolean
    emailThreadId?: boolean
    contacts?: boolean | Email$contactsArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    emailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["email"]>

  export type EmailSelectScalar = {
    id?: boolean
    to?: boolean
    bcc?: boolean
    cc?: boolean
    from?: boolean
    subject?: boolean
    text?: boolean
    sentByUser?: boolean
    sentAt?: boolean
    contactIds?: boolean
    teamAccountId?: boolean
    messageId?: boolean
    emailThreadId?: boolean
  }

  export type EmailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contacts?: boolean | Email$contactsArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    emailThread?: boolean | EmailThreadDefaultArgs<ExtArgs>
    _count?: boolean | EmailCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Email"
    objects: {
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs>
      emailThread: Prisma.$EmailThreadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      to: string[]
      bcc: string[]
      cc: string[]
      from: string
      subject: string
      text: string
      sentByUser: boolean
      sentAt: Date
      contactIds: string[]
      teamAccountId: string
      messageId: string
      emailThreadId: string
    }, ExtArgs["result"]["email"]>
    composites: {}
  }


  type EmailGetPayload<S extends boolean | null | undefined | EmailDefaultArgs> = $Result.GetResult<Prisma.$EmailPayload, S>

  type EmailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmailCountAggregateInputType | true
    }

  export interface EmailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Email'], meta: { name: 'Email' } }
    /**
     * Find zero or one Email that matches the filter.
     * @param {EmailFindUniqueArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Email that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailFindUniqueOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Email that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindFirstArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Email that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindFirstOrThrowArgs} args - Arguments to find a Email
     * @example
     * // Get one Email
     * const email = await prisma.email.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Emails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emails
     * const emails = await prisma.email.findMany()
     * 
     * // Get first 10 Emails
     * const emails = await prisma.email.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailWithIdOnly = await prisma.email.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Email.
     * @param {EmailCreateArgs} args - Arguments to create a Email.
     * @example
     * // Create one Email
     * const Email = await prisma.email.create({
     *   data: {
     *     // ... data to create a Email
     *   }
     * })
     * 
    **/
    create<T extends EmailCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailCreateArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Emails.
     *     @param {EmailCreateManyArgs} args - Arguments to create many Emails.
     *     @example
     *     // Create many Emails
     *     const email = await prisma.email.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Email.
     * @param {EmailDeleteArgs} args - Arguments to delete one Email.
     * @example
     * // Delete one Email
     * const Email = await prisma.email.delete({
     *   where: {
     *     // ... filter to delete one Email
     *   }
     * })
     * 
    **/
    delete<T extends EmailDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailDeleteArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Email.
     * @param {EmailUpdateArgs} args - Arguments to update one Email.
     * @example
     * // Update one Email
     * const email = await prisma.email.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpdateArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Emails.
     * @param {EmailDeleteManyArgs} args - Arguments to filter Emails to delete.
     * @example
     * // Delete a few Emails
     * const { count } = await prisma.email.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emails
     * const email = await prisma.email.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Email.
     * @param {EmailUpsertArgs} args - Arguments to update or create a Email.
     * @example
     * // Update or create a Email
     * const email = await prisma.email.upsert({
     *   create: {
     *     // ... data to create a Email
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email we want to update
     *   }
     * })
    **/
    upsert<T extends EmailUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailUpsertArgs<ExtArgs>>
    ): Prisma__EmailClient<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Emails that matches the filter.
     * @param {EmailFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const email = await prisma.email.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: EmailFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Email.
     * @param {EmailAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const email = await prisma.email.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: EmailAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Emails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailCountArgs} args - Arguments to filter Emails to count.
     * @example
     * // Count the number of Emails
     * const count = await prisma.email.count({
     *   where: {
     *     // ... the filter for the Emails we want to count
     *   }
     * })
    **/
    count<T extends EmailCountArgs>(
      args?: Subset<T, EmailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAggregateArgs>(args: Subset<T, EmailAggregateArgs>): Prisma.PrismaPromise<GetEmailAggregateType<T>>

    /**
     * Group by Email.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailGroupByArgs['orderBy'] }
        : { orderBy?: EmailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Email model
   */
  readonly fields: EmailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Email.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    contacts<T extends Email$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Email$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    teamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    emailThread<T extends EmailThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailThreadDefaultArgs<ExtArgs>>): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Email model
   */ 
  interface EmailFieldRefs {
    readonly id: FieldRef<"Email", 'String'>
    readonly to: FieldRef<"Email", 'String[]'>
    readonly bcc: FieldRef<"Email", 'String[]'>
    readonly cc: FieldRef<"Email", 'String[]'>
    readonly from: FieldRef<"Email", 'String'>
    readonly subject: FieldRef<"Email", 'String'>
    readonly text: FieldRef<"Email", 'String'>
    readonly sentByUser: FieldRef<"Email", 'Boolean'>
    readonly sentAt: FieldRef<"Email", 'DateTime'>
    readonly contactIds: FieldRef<"Email", 'String[]'>
    readonly teamAccountId: FieldRef<"Email", 'String'>
    readonly messageId: FieldRef<"Email", 'String'>
    readonly emailThreadId: FieldRef<"Email", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Email findUnique
   */
  export type EmailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email findUniqueOrThrow
   */
  export type EmailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email findFirst
   */
  export type EmailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Email findFirstOrThrow
   */
  export type EmailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Email to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emails.
     */
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Email findMany
   */
  export type EmailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter, which Emails to fetch.
     */
    where?: EmailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emails to fetch.
     */
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emails.
     */
    cursor?: EmailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emails.
     */
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * Email create
   */
  export type EmailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to create a Email.
     */
    data: XOR<EmailCreateInput, EmailUncheckedCreateInput>
  }


  /**
   * Email createMany
   */
  export type EmailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emails.
     */
    data: EmailCreateManyInput | EmailCreateManyInput[]
  }


  /**
   * Email update
   */
  export type EmailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The data needed to update a Email.
     */
    data: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
    /**
     * Choose, which Email to update.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email updateMany
   */
  export type EmailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emails.
     */
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyInput>
    /**
     * Filter which Emails to update
     */
    where?: EmailWhereInput
  }


  /**
   * Email upsert
   */
  export type EmailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * The filter to search for the Email to update in case it exists.
     */
    where: EmailWhereUniqueInput
    /**
     * In case the Email found by the `where` argument doesn't exist, create a new Email with this data.
     */
    create: XOR<EmailCreateInput, EmailUncheckedCreateInput>
    /**
     * In case the Email was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailUpdateInput, EmailUncheckedUpdateInput>
  }


  /**
   * Email delete
   */
  export type EmailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    /**
     * Filter which Email to delete.
     */
    where: EmailWhereUniqueInput
  }


  /**
   * Email deleteMany
   */
  export type EmailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emails to delete
     */
    where?: EmailWhereInput
  }


  /**
   * Email findRaw
   */
  export type EmailFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Email aggregateRaw
   */
  export type EmailAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Email.contacts
   */
  export type Email$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * Email without action
   */
  export type EmailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
  }



  /**
   * Model EmailThread
   */

  export type AggregateEmailThread = {
    _count: EmailThreadCountAggregateOutputType | null
    _min: EmailThreadMinAggregateOutputType | null
    _max: EmailThreadMaxAggregateOutputType | null
  }

  export type EmailThreadMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamAccountId: string | null
  }

  export type EmailThreadMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamAccountId: string | null
  }

  export type EmailThreadCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    contactIds: number
    teamAccountId: number
    targetIds: number
    _all: number
  }


  export type EmailThreadMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamAccountId?: true
  }

  export type EmailThreadMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamAccountId?: true
  }

  export type EmailThreadCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    contactIds?: true
    teamAccountId?: true
    targetIds?: true
    _all?: true
  }

  export type EmailThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailThread to aggregate.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailThreads
    **/
    _count?: true | EmailThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailThreadMaxAggregateInputType
  }

  export type GetEmailThreadAggregateType<T extends EmailThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailThread[P]>
      : GetScalarType<T[P], AggregateEmailThread[P]>
  }




  export type EmailThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithAggregationInput | EmailThreadOrderByWithAggregationInput[]
    by: EmailThreadScalarFieldEnum[] | EmailThreadScalarFieldEnum
    having?: EmailThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailThreadCountAggregateInputType | true
    _min?: EmailThreadMinAggregateInputType
    _max?: EmailThreadMaxAggregateInputType
  }

  export type EmailThreadGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    contactIds: string[]
    teamAccountId: string
    targetIds: string[]
    _count: EmailThreadCountAggregateOutputType | null
    _min: EmailThreadMinAggregateOutputType | null
    _max: EmailThreadMaxAggregateOutputType | null
  }

  type GetEmailThreadGroupByPayload<T extends EmailThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailThreadGroupByOutputType[P]>
            : GetScalarType<T[P], EmailThreadGroupByOutputType[P]>
        }
      >
    >


  export type EmailThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactIds?: boolean
    teamAccountId?: boolean
    targetIds?: boolean
    emails?: boolean | EmailThread$emailsArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    contacts?: boolean | EmailThread$contactsArgs<ExtArgs>
    githubTargets?: boolean | EmailThread$githubTargetsArgs<ExtArgs>
    _count?: boolean | EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailThread"]>

  export type EmailThreadSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactIds?: boolean
    teamAccountId?: boolean
    targetIds?: boolean
  }

  export type EmailThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    emails?: boolean | EmailThread$emailsArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    contacts?: boolean | EmailThread$contactsArgs<ExtArgs>
    githubTargets?: boolean | EmailThread$githubTargetsArgs<ExtArgs>
    _count?: boolean | EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EmailThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailThread"
    objects: {
      emails: Prisma.$EmailPayload<ExtArgs>[]
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs>
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      githubTargets: Prisma.$GithubTargetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      contactIds: string[]
      teamAccountId: string
      targetIds: string[]
    }, ExtArgs["result"]["emailThread"]>
    composites: {}
  }


  type EmailThreadGetPayload<S extends boolean | null | undefined | EmailThreadDefaultArgs> = $Result.GetResult<Prisma.$EmailThreadPayload, S>

  type EmailThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailThreadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmailThreadCountAggregateInputType | true
    }

  export interface EmailThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailThread'], meta: { name: 'EmailThread' } }
    /**
     * Find zero or one EmailThread that matches the filter.
     * @param {EmailThreadFindUniqueArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmailThreadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmailThreadFindUniqueArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one EmailThread that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmailThreadFindUniqueOrThrowArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmailThreadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailThreadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first EmailThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindFirstArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmailThreadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailThreadFindFirstArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first EmailThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindFirstOrThrowArgs} args - Arguments to find a EmailThread
     * @example
     * // Get one EmailThread
     * const emailThread = await prisma.emailThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmailThreadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailThreadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more EmailThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailThreads
     * const emailThreads = await prisma.emailThread.findMany()
     * 
     * // Get first 10 EmailThreads
     * const emailThreads = await prisma.emailThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailThreadWithIdOnly = await prisma.emailThread.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmailThreadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailThreadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a EmailThread.
     * @param {EmailThreadCreateArgs} args - Arguments to create a EmailThread.
     * @example
     * // Create one EmailThread
     * const EmailThread = await prisma.emailThread.create({
     *   data: {
     *     // ... data to create a EmailThread
     *   }
     * })
     * 
    **/
    create<T extends EmailThreadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailThreadCreateArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many EmailThreads.
     *     @param {EmailThreadCreateManyArgs} args - Arguments to create many EmailThreads.
     *     @example
     *     // Create many EmailThreads
     *     const emailThread = await prisma.emailThread.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmailThreadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailThreadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailThread.
     * @param {EmailThreadDeleteArgs} args - Arguments to delete one EmailThread.
     * @example
     * // Delete one EmailThread
     * const EmailThread = await prisma.emailThread.delete({
     *   where: {
     *     // ... filter to delete one EmailThread
     *   }
     * })
     * 
    **/
    delete<T extends EmailThreadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmailThreadDeleteArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one EmailThread.
     * @param {EmailThreadUpdateArgs} args - Arguments to update one EmailThread.
     * @example
     * // Update one EmailThread
     * const emailThread = await prisma.emailThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmailThreadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmailThreadUpdateArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more EmailThreads.
     * @param {EmailThreadDeleteManyArgs} args - Arguments to filter EmailThreads to delete.
     * @example
     * // Delete a few EmailThreads
     * const { count } = await prisma.emailThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmailThreadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmailThreadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailThreads
     * const emailThread = await prisma.emailThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmailThreadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmailThreadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailThread.
     * @param {EmailThreadUpsertArgs} args - Arguments to update or create a EmailThread.
     * @example
     * // Update or create a EmailThread
     * const emailThread = await prisma.emailThread.upsert({
     *   create: {
     *     // ... data to create a EmailThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailThread we want to update
     *   }
     * })
    **/
    upsert<T extends EmailThreadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmailThreadUpsertArgs<ExtArgs>>
    ): Prisma__EmailThreadClient<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more EmailThreads that matches the filter.
     * @param {EmailThreadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const emailThread = await prisma.emailThread.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: EmailThreadFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a EmailThread.
     * @param {EmailThreadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const emailThread = await prisma.emailThread.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: EmailThreadAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of EmailThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadCountArgs} args - Arguments to filter EmailThreads to count.
     * @example
     * // Count the number of EmailThreads
     * const count = await prisma.emailThread.count({
     *   where: {
     *     // ... the filter for the EmailThreads we want to count
     *   }
     * })
    **/
    count<T extends EmailThreadCountArgs>(
      args?: Subset<T, EmailThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailThreadAggregateArgs>(args: Subset<T, EmailThreadAggregateArgs>): Prisma.PrismaPromise<GetEmailThreadAggregateType<T>>

    /**
     * Group by EmailThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailThreadGroupByArgs['orderBy'] }
        : { orderBy?: EmailThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailThread model
   */
  readonly fields: EmailThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    emails<T extends EmailThread$emailsArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$emailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailPayload<ExtArgs>, T, 'findMany'> | Null>;

    teamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    contacts<T extends EmailThread$contactsArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    githubTargets<T extends EmailThread$githubTargetsArgs<ExtArgs> = {}>(args?: Subset<T, EmailThread$githubTargetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the EmailThread model
   */ 
  interface EmailThreadFieldRefs {
    readonly id: FieldRef<"EmailThread", 'String'>
    readonly createdAt: FieldRef<"EmailThread", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailThread", 'DateTime'>
    readonly contactIds: FieldRef<"EmailThread", 'String[]'>
    readonly teamAccountId: FieldRef<"EmailThread", 'String'>
    readonly targetIds: FieldRef<"EmailThread", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * EmailThread findUnique
   */
  export type EmailThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where: EmailThreadWhereUniqueInput
  }


  /**
   * EmailThread findUniqueOrThrow
   */
  export type EmailThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where: EmailThreadWhereUniqueInput
  }


  /**
   * EmailThread findFirst
   */
  export type EmailThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailThreads.
     */
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }


  /**
   * EmailThread findFirstOrThrow
   */
  export type EmailThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThread to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailThreads.
     */
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }


  /**
   * EmailThread findMany
   */
  export type EmailThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter, which EmailThreads to fetch.
     */
    where?: EmailThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailThreads to fetch.
     */
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailThreads.
     */
    cursor?: EmailThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailThreads.
     */
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }


  /**
   * EmailThread create
   */
  export type EmailThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailThread.
     */
    data: XOR<EmailThreadCreateInput, EmailThreadUncheckedCreateInput>
  }


  /**
   * EmailThread createMany
   */
  export type EmailThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailThreads.
     */
    data: EmailThreadCreateManyInput | EmailThreadCreateManyInput[]
  }


  /**
   * EmailThread update
   */
  export type EmailThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailThread.
     */
    data: XOR<EmailThreadUpdateInput, EmailThreadUncheckedUpdateInput>
    /**
     * Choose, which EmailThread to update.
     */
    where: EmailThreadWhereUniqueInput
  }


  /**
   * EmailThread updateMany
   */
  export type EmailThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailThreads.
     */
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyInput>
    /**
     * Filter which EmailThreads to update
     */
    where?: EmailThreadWhereInput
  }


  /**
   * EmailThread upsert
   */
  export type EmailThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailThread to update in case it exists.
     */
    where: EmailThreadWhereUniqueInput
    /**
     * In case the EmailThread found by the `where` argument doesn't exist, create a new EmailThread with this data.
     */
    create: XOR<EmailThreadCreateInput, EmailThreadUncheckedCreateInput>
    /**
     * In case the EmailThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailThreadUpdateInput, EmailThreadUncheckedUpdateInput>
  }


  /**
   * EmailThread delete
   */
  export type EmailThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    /**
     * Filter which EmailThread to delete.
     */
    where: EmailThreadWhereUniqueInput
  }


  /**
   * EmailThread deleteMany
   */
  export type EmailThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailThreads to delete
     */
    where?: EmailThreadWhereInput
  }


  /**
   * EmailThread findRaw
   */
  export type EmailThreadFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * EmailThread aggregateRaw
   */
  export type EmailThreadAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * EmailThread.emails
   */
  export type EmailThread$emailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Email
     */
    select?: EmailSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailInclude<ExtArgs> | null
    where?: EmailWhereInput
    orderBy?: EmailOrderByWithRelationInput | EmailOrderByWithRelationInput[]
    cursor?: EmailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailScalarFieldEnum | EmailScalarFieldEnum[]
  }


  /**
   * EmailThread.contacts
   */
  export type EmailThread$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * EmailThread.githubTargets
   */
  export type EmailThread$githubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    where?: GithubTargetWhereInput
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    cursor?: GithubTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * EmailThread without action
   */
  export type EmailThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
  }



  /**
   * Model Note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamAccountId: string | null
    subject: string | null
    text: string | null
    teamAccountUserId: string | null
    githubTargetId: string | null
  }

  export type NoteMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    teamAccountId: string | null
    subject: string | null
    text: string | null
    teamAccountUserId: string | null
    githubTargetId: string | null
  }

  export type NoteCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    teamAccountId: number
    subject: number
    text: number
    teamAccountUserId: number
    githubTargetId: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamAccountId?: true
    subject?: true
    text?: true
    teamAccountUserId?: true
    githubTargetId?: true
  }

  export type NoteMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamAccountId?: true
    subject?: true
    text?: true
    teamAccountUserId?: true
    githubTargetId?: true
  }

  export type NoteCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    teamAccountId?: true
    subject?: true
    text?: true
    teamAccountUserId?: true
    githubTargetId?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithAggregationInput | NoteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    teamAccountId: string
    subject: string
    text: string
    teamAccountUserId: string
    githubTargetId: string | null
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamAccountId?: boolean
    subject?: boolean
    text?: boolean
    teamAccountUserId?: boolean
    githubTargetId?: boolean
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    teamAccountUser?: boolean | UserDefaultArgs<ExtArgs>
    githubTarget?: boolean | Note$githubTargetArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamAccountId?: boolean
    subject?: boolean
    text?: boolean
    teamAccountUserId?: boolean
    githubTargetId?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    teamAccountUser?: boolean | UserDefaultArgs<ExtArgs>
    githubTarget?: boolean | Note$githubTargetArgs<ExtArgs>
  }


  export type $NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Note"
    objects: {
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs>
      teamAccountUser: Prisma.$UserPayload<ExtArgs>
      githubTarget: Prisma.$GithubTargetPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      teamAccountId: string
      subject: string
      text: string
      teamAccountUserId: string
      githubTargetId: string | null
    }, ExtArgs["result"]["note"]>
    composites: {}
  }


  type NoteGetPayload<S extends boolean | null | undefined | NoteDefaultArgs> = $Result.GetResult<Prisma.$NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noteWithIdOnly = await prisma.note.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
    **/
    create<T extends NoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NoteCreateArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Notes.
     *     @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     *     @example
     *     // Create many Notes
     *     const note = await prisma.note.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
    **/
    delete<T extends NoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
    **/
    upsert<T extends NoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>
    ): Prisma__NoteClient<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * @param {NoteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const note = await prisma.note.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: NoteFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Note.
     * @param {NoteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const note = await prisma.note.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: NoteAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Note model
   */
  readonly fields: NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    teamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    teamAccountUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    githubTarget<T extends Note$githubTargetArgs<ExtArgs> = {}>(args?: Subset<T, Note$githubTargetArgs<ExtArgs>>): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Note model
   */ 
  interface NoteFieldRefs {
    readonly id: FieldRef<"Note", 'String'>
    readonly createdAt: FieldRef<"Note", 'DateTime'>
    readonly updatedAt: FieldRef<"Note", 'DateTime'>
    readonly teamAccountId: FieldRef<"Note", 'String'>
    readonly subject: FieldRef<"Note", 'String'>
    readonly text: FieldRef<"Note", 'String'>
    readonly teamAccountUserId: FieldRef<"Note", 'String'>
    readonly githubTargetId: FieldRef<"Note", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Note findUnique
   */
  export type NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note findFirst
   */
  export type NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }


  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }


  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }


  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }


  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: NoteCreateManyInput | NoteCreateManyInput[]
  }


  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }


  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }


  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }


  /**
   * Note findRaw
   */
  export type NoteFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Note aggregateRaw
   */
  export type NoteAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Note.githubTarget
   */
  export type Note$githubTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    where?: GithubTargetWhereInput
  }


  /**
   * Note without action
   */
  export type NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
  }



  /**
   * Model TargetScout
   */

  export type AggregateTargetScout = {
    _count: TargetScoutCountAggregateOutputType | null
    _min: TargetScoutMinAggregateOutputType | null
    _max: TargetScoutMaxAggregateOutputType | null
  }

  export type TargetScoutMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    dependencyName: string | null
    dependencyFilename: string | null
  }

  export type TargetScoutMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    dependencyName: string | null
    dependencyFilename: string | null
  }

  export type TargetScoutCountAggregateOutputType = {
    id: number
    campaignId: number
    dependencyName: number
    dependencyFilename: number
    _all: number
  }


  export type TargetScoutMinAggregateInputType = {
    id?: true
    campaignId?: true
    dependencyName?: true
    dependencyFilename?: true
  }

  export type TargetScoutMaxAggregateInputType = {
    id?: true
    campaignId?: true
    dependencyName?: true
    dependencyFilename?: true
  }

  export type TargetScoutCountAggregateInputType = {
    id?: true
    campaignId?: true
    dependencyName?: true
    dependencyFilename?: true
    _all?: true
  }

  export type TargetScoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetScout to aggregate.
     */
    where?: TargetScoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetScouts to fetch.
     */
    orderBy?: TargetScoutOrderByWithRelationInput | TargetScoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TargetScoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetScouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetScouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TargetScouts
    **/
    _count?: true | TargetScoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TargetScoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TargetScoutMaxAggregateInputType
  }

  export type GetTargetScoutAggregateType<T extends TargetScoutAggregateArgs> = {
        [P in keyof T & keyof AggregateTargetScout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTargetScout[P]>
      : GetScalarType<T[P], AggregateTargetScout[P]>
  }




  export type TargetScoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetScoutWhereInput
    orderBy?: TargetScoutOrderByWithAggregationInput | TargetScoutOrderByWithAggregationInput[]
    by: TargetScoutScalarFieldEnum[] | TargetScoutScalarFieldEnum
    having?: TargetScoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TargetScoutCountAggregateInputType | true
    _min?: TargetScoutMinAggregateInputType
    _max?: TargetScoutMaxAggregateInputType
  }

  export type TargetScoutGroupByOutputType = {
    id: string
    campaignId: string
    dependencyName: string
    dependencyFilename: string
    _count: TargetScoutCountAggregateOutputType | null
    _min: TargetScoutMinAggregateOutputType | null
    _max: TargetScoutMaxAggregateOutputType | null
  }

  type GetTargetScoutGroupByPayload<T extends TargetScoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TargetScoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TargetScoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TargetScoutGroupByOutputType[P]>
            : GetScalarType<T[P], TargetScoutGroupByOutputType[P]>
        }
      >
    >


  export type TargetScoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    dependencyName?: boolean
    dependencyFilename?: boolean
    filter?: boolean | TargetScoutFilterDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["targetScout"]>

  export type TargetScoutSelectScalar = {
    id?: boolean
    campaignId?: boolean
    dependencyName?: boolean
    dependencyFilename?: boolean
  }

  export type TargetScoutInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }


  export type $TargetScoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TargetScout"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      dependencyName: string
      dependencyFilename: string
    }, ExtArgs["result"]["targetScout"]>
    composites: {
      filter: Prisma.$TargetScoutFilterPayload | null
    }
  }


  type TargetScoutGetPayload<S extends boolean | null | undefined | TargetScoutDefaultArgs> = $Result.GetResult<Prisma.$TargetScoutPayload, S>

  type TargetScoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TargetScoutFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TargetScoutCountAggregateInputType | true
    }

  export interface TargetScoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TargetScout'], meta: { name: 'TargetScout' } }
    /**
     * Find zero or one TargetScout that matches the filter.
     * @param {TargetScoutFindUniqueArgs} args - Arguments to find a TargetScout
     * @example
     * // Get one TargetScout
     * const targetScout = await prisma.targetScout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TargetScoutFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TargetScoutFindUniqueArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TargetScout that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TargetScoutFindUniqueOrThrowArgs} args - Arguments to find a TargetScout
     * @example
     * // Get one TargetScout
     * const targetScout = await prisma.targetScout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TargetScoutFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetScoutFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TargetScout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutFindFirstArgs} args - Arguments to find a TargetScout
     * @example
     * // Get one TargetScout
     * const targetScout = await prisma.targetScout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TargetScoutFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetScoutFindFirstArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TargetScout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutFindFirstOrThrowArgs} args - Arguments to find a TargetScout
     * @example
     * // Get one TargetScout
     * const targetScout = await prisma.targetScout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TargetScoutFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetScoutFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TargetScouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TargetScouts
     * const targetScouts = await prisma.targetScout.findMany()
     * 
     * // Get first 10 TargetScouts
     * const targetScouts = await prisma.targetScout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const targetScoutWithIdOnly = await prisma.targetScout.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TargetScoutFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetScoutFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TargetScout.
     * @param {TargetScoutCreateArgs} args - Arguments to create a TargetScout.
     * @example
     * // Create one TargetScout
     * const TargetScout = await prisma.targetScout.create({
     *   data: {
     *     // ... data to create a TargetScout
     *   }
     * })
     * 
    **/
    create<T extends TargetScoutCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TargetScoutCreateArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TargetScouts.
     *     @param {TargetScoutCreateManyArgs} args - Arguments to create many TargetScouts.
     *     @example
     *     // Create many TargetScouts
     *     const targetScout = await prisma.targetScout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TargetScoutCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetScoutCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TargetScout.
     * @param {TargetScoutDeleteArgs} args - Arguments to delete one TargetScout.
     * @example
     * // Delete one TargetScout
     * const TargetScout = await prisma.targetScout.delete({
     *   where: {
     *     // ... filter to delete one TargetScout
     *   }
     * })
     * 
    **/
    delete<T extends TargetScoutDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TargetScoutDeleteArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TargetScout.
     * @param {TargetScoutUpdateArgs} args - Arguments to update one TargetScout.
     * @example
     * // Update one TargetScout
     * const targetScout = await prisma.targetScout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TargetScoutUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TargetScoutUpdateArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TargetScouts.
     * @param {TargetScoutDeleteManyArgs} args - Arguments to filter TargetScouts to delete.
     * @example
     * // Delete a few TargetScouts
     * const { count } = await prisma.targetScout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TargetScoutDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetScoutDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TargetScouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TargetScouts
     * const targetScout = await prisma.targetScout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TargetScoutUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TargetScoutUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TargetScout.
     * @param {TargetScoutUpsertArgs} args - Arguments to update or create a TargetScout.
     * @example
     * // Update or create a TargetScout
     * const targetScout = await prisma.targetScout.upsert({
     *   create: {
     *     // ... data to create a TargetScout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TargetScout we want to update
     *   }
     * })
    **/
    upsert<T extends TargetScoutUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TargetScoutUpsertArgs<ExtArgs>>
    ): Prisma__TargetScoutClient<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more TargetScouts that matches the filter.
     * @param {TargetScoutFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const targetScout = await prisma.targetScout.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TargetScoutFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TargetScout.
     * @param {TargetScoutAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const targetScout = await prisma.targetScout.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TargetScoutAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TargetScouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutCountArgs} args - Arguments to filter TargetScouts to count.
     * @example
     * // Count the number of TargetScouts
     * const count = await prisma.targetScout.count({
     *   where: {
     *     // ... the filter for the TargetScouts we want to count
     *   }
     * })
    **/
    count<T extends TargetScoutCountArgs>(
      args?: Subset<T, TargetScoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TargetScoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TargetScout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TargetScoutAggregateArgs>(args: Subset<T, TargetScoutAggregateArgs>): Prisma.PrismaPromise<GetTargetScoutAggregateType<T>>

    /**
     * Group by TargetScout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetScoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TargetScoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TargetScoutGroupByArgs['orderBy'] }
        : { orderBy?: TargetScoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TargetScoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTargetScoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TargetScout model
   */
  readonly fields: TargetScoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TargetScout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TargetScoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TargetScout model
   */ 
  interface TargetScoutFieldRefs {
    readonly id: FieldRef<"TargetScout", 'String'>
    readonly campaignId: FieldRef<"TargetScout", 'String'>
    readonly dependencyName: FieldRef<"TargetScout", 'String'>
    readonly dependencyFilename: FieldRef<"TargetScout", 'String'>
  }
    

  // Custom InputTypes

  /**
   * TargetScout findUnique
   */
  export type TargetScoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * Filter, which TargetScout to fetch.
     */
    where: TargetScoutWhereUniqueInput
  }


  /**
   * TargetScout findUniqueOrThrow
   */
  export type TargetScoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * Filter, which TargetScout to fetch.
     */
    where: TargetScoutWhereUniqueInput
  }


  /**
   * TargetScout findFirst
   */
  export type TargetScoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * Filter, which TargetScout to fetch.
     */
    where?: TargetScoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetScouts to fetch.
     */
    orderBy?: TargetScoutOrderByWithRelationInput | TargetScoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetScouts.
     */
    cursor?: TargetScoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetScouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetScouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetScouts.
     */
    distinct?: TargetScoutScalarFieldEnum | TargetScoutScalarFieldEnum[]
  }


  /**
   * TargetScout findFirstOrThrow
   */
  export type TargetScoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * Filter, which TargetScout to fetch.
     */
    where?: TargetScoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetScouts to fetch.
     */
    orderBy?: TargetScoutOrderByWithRelationInput | TargetScoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetScouts.
     */
    cursor?: TargetScoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetScouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetScouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetScouts.
     */
    distinct?: TargetScoutScalarFieldEnum | TargetScoutScalarFieldEnum[]
  }


  /**
   * TargetScout findMany
   */
  export type TargetScoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * Filter, which TargetScouts to fetch.
     */
    where?: TargetScoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetScouts to fetch.
     */
    orderBy?: TargetScoutOrderByWithRelationInput | TargetScoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TargetScouts.
     */
    cursor?: TargetScoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetScouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetScouts.
     */
    skip?: number
    distinct?: TargetScoutScalarFieldEnum | TargetScoutScalarFieldEnum[]
  }


  /**
   * TargetScout create
   */
  export type TargetScoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * The data needed to create a TargetScout.
     */
    data: XOR<TargetScoutCreateInput, TargetScoutUncheckedCreateInput>
  }


  /**
   * TargetScout createMany
   */
  export type TargetScoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TargetScouts.
     */
    data: TargetScoutCreateManyInput | TargetScoutCreateManyInput[]
  }


  /**
   * TargetScout update
   */
  export type TargetScoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * The data needed to update a TargetScout.
     */
    data: XOR<TargetScoutUpdateInput, TargetScoutUncheckedUpdateInput>
    /**
     * Choose, which TargetScout to update.
     */
    where: TargetScoutWhereUniqueInput
  }


  /**
   * TargetScout updateMany
   */
  export type TargetScoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TargetScouts.
     */
    data: XOR<TargetScoutUpdateManyMutationInput, TargetScoutUncheckedUpdateManyInput>
    /**
     * Filter which TargetScouts to update
     */
    where?: TargetScoutWhereInput
  }


  /**
   * TargetScout upsert
   */
  export type TargetScoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * The filter to search for the TargetScout to update in case it exists.
     */
    where: TargetScoutWhereUniqueInput
    /**
     * In case the TargetScout found by the `where` argument doesn't exist, create a new TargetScout with this data.
     */
    create: XOR<TargetScoutCreateInput, TargetScoutUncheckedCreateInput>
    /**
     * In case the TargetScout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TargetScoutUpdateInput, TargetScoutUncheckedUpdateInput>
  }


  /**
   * TargetScout delete
   */
  export type TargetScoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    /**
     * Filter which TargetScout to delete.
     */
    where: TargetScoutWhereUniqueInput
  }


  /**
   * TargetScout deleteMany
   */
  export type TargetScoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetScouts to delete
     */
    where?: TargetScoutWhereInput
  }


  /**
   * TargetScout findRaw
   */
  export type TargetScoutFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TargetScout aggregateRaw
   */
  export type TargetScoutAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TargetScout without action
   */
  export type TargetScoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
  }



  /**
   * Model CustomField
   */

  export type AggregateCustomField = {
    _count: CustomFieldCountAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  export type CustomFieldMinAggregateOutputType = {
    id: string | null
    key: string | null
    bgColor: string | null
    type: string | null
    targetType: string | null
    campaignId: string | null
  }

  export type CustomFieldMaxAggregateOutputType = {
    id: string | null
    key: string | null
    bgColor: string | null
    type: string | null
    targetType: string | null
    campaignId: string | null
  }

  export type CustomFieldCountAggregateOutputType = {
    id: number
    key: number
    bgColor: number
    type: number
    targetType: number
    campaignId: number
    _all: number
  }


  export type CustomFieldMinAggregateInputType = {
    id?: true
    key?: true
    bgColor?: true
    type?: true
    targetType?: true
    campaignId?: true
  }

  export type CustomFieldMaxAggregateInputType = {
    id?: true
    key?: true
    bgColor?: true
    type?: true
    targetType?: true
    campaignId?: true
  }

  export type CustomFieldCountAggregateInputType = {
    id?: true
    key?: true
    bgColor?: true
    type?: true
    targetType?: true
    campaignId?: true
    _all?: true
  }

  export type CustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomField to aggregate.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFields
    **/
    _count?: true | CustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldMaxAggregateInputType
  }

  export type GetCustomFieldAggregateType<T extends CustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomField[P]>
      : GetScalarType<T[P], AggregateCustomField[P]>
  }




  export type CustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithAggregationInput | CustomFieldOrderByWithAggregationInput[]
    by: CustomFieldScalarFieldEnum[] | CustomFieldScalarFieldEnum
    having?: CustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldCountAggregateInputType | true
    _min?: CustomFieldMinAggregateInputType
    _max?: CustomFieldMaxAggregateInputType
  }

  export type CustomFieldGroupByOutputType = {
    id: string
    key: string
    bgColor: string | null
    type: string
    targetType: string
    campaignId: string
    _count: CustomFieldCountAggregateOutputType | null
    _min: CustomFieldMinAggregateOutputType | null
    _max: CustomFieldMaxAggregateOutputType | null
  }

  type GetCustomFieldGroupByPayload<T extends CustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    bgColor?: boolean
    type?: boolean
    targetType?: boolean
    campaignId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    customFieldValues?: boolean | CustomField$customFieldValuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customField"]>

  export type CustomFieldSelectScalar = {
    id?: boolean
    key?: boolean
    bgColor?: boolean
    type?: boolean
    targetType?: boolean
    campaignId?: boolean
  }

  export type CustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    customFieldValues?: boolean | CustomField$customFieldValuesArgs<ExtArgs>
    _count?: boolean | CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomField"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      customFieldValues: Prisma.$CustomFieldValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      bgColor: string | null
      type: string
      targetType: string
      campaignId: string
    }, ExtArgs["result"]["customField"]>
    composites: {}
  }


  type CustomFieldGetPayload<S extends boolean | null | undefined | CustomFieldDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldPayload, S>

  type CustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomFieldFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CustomFieldCountAggregateInputType | true
    }

  export interface CustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomField'], meta: { name: 'CustomField' } }
    /**
     * Find zero or one CustomField that matches the filter.
     * @param {CustomFieldFindUniqueArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomFieldFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CustomField that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomFieldFindUniqueOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomFieldFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomFieldFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldFindFirstArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindFirstOrThrowArgs} args - Arguments to find a CustomField
     * @example
     * // Get one CustomField
     * const customField = await prisma.customField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomFieldFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFields
     * const customFields = await prisma.customField.findMany()
     * 
     * // Get first 10 CustomFields
     * const customFields = await prisma.customField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldWithIdOnly = await prisma.customField.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomFieldFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CustomField.
     * @param {CustomFieldCreateArgs} args - Arguments to create a CustomField.
     * @example
     * // Create one CustomField
     * const CustomField = await prisma.customField.create({
     *   data: {
     *     // ... data to create a CustomField
     *   }
     * })
     * 
    **/
    create<T extends CustomFieldCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldCreateArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CustomFields.
     *     @param {CustomFieldCreateManyArgs} args - Arguments to create many CustomFields.
     *     @example
     *     // Create many CustomFields
     *     const customField = await prisma.customField.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomFieldCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomField.
     * @param {CustomFieldDeleteArgs} args - Arguments to delete one CustomField.
     * @example
     * // Delete one CustomField
     * const CustomField = await prisma.customField.delete({
     *   where: {
     *     // ... filter to delete one CustomField
     *   }
     * })
     * 
    **/
    delete<T extends CustomFieldDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldDeleteArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CustomField.
     * @param {CustomFieldUpdateArgs} args - Arguments to update one CustomField.
     * @example
     * // Update one CustomField
     * const customField = await prisma.customField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomFieldUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldUpdateArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CustomFields.
     * @param {CustomFieldDeleteManyArgs} args - Arguments to filter CustomFields to delete.
     * @example
     * // Delete a few CustomFields
     * const { count } = await prisma.customField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomFieldDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFields
     * const customField = await prisma.customField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomFieldUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomField.
     * @param {CustomFieldUpsertArgs} args - Arguments to update or create a CustomField.
     * @example
     * // Update or create a CustomField
     * const customField = await prisma.customField.upsert({
     *   create: {
     *     // ... data to create a CustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomField we want to update
     *   }
     * })
    **/
    upsert<T extends CustomFieldUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldUpsertArgs<ExtArgs>>
    ): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more CustomFields that matches the filter.
     * @param {CustomFieldFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customField = await prisma.customField.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CustomFieldFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CustomField.
     * @param {CustomFieldAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customField = await prisma.customField.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CustomFieldAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of CustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldCountArgs} args - Arguments to filter CustomFields to count.
     * @example
     * // Count the number of CustomFields
     * const count = await prisma.customField.count({
     *   where: {
     *     // ... the filter for the CustomFields we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldCountArgs>(
      args?: Subset<T, CustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldAggregateArgs>(args: Subset<T, CustomFieldAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldAggregateType<T>>

    /**
     * Group by CustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomField model
   */
  readonly fields: CustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    customFieldValues<T extends CustomField$customFieldValuesArgs<ExtArgs> = {}>(args?: Subset<T, CustomField$customFieldValuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CustomField model
   */ 
  interface CustomFieldFieldRefs {
    readonly id: FieldRef<"CustomField", 'String'>
    readonly key: FieldRef<"CustomField", 'String'>
    readonly bgColor: FieldRef<"CustomField", 'String'>
    readonly type: FieldRef<"CustomField", 'String'>
    readonly targetType: FieldRef<"CustomField", 'String'>
    readonly campaignId: FieldRef<"CustomField", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CustomField findUnique
   */
  export type CustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }


  /**
   * CustomField findUniqueOrThrow
   */
  export type CustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where: CustomFieldWhereUniqueInput
  }


  /**
   * CustomField findFirst
   */
  export type CustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }


  /**
   * CustomField findFirstOrThrow
   */
  export type CustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomField to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFields.
     */
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }


  /**
   * CustomField findMany
   */
  export type CustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which CustomFields to fetch.
     */
    where?: CustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFields to fetch.
     */
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFields.
     */
    cursor?: CustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFields.
     */
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }


  /**
   * CustomField create
   */
  export type CustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomField.
     */
    data: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
  }


  /**
   * CustomField createMany
   */
  export type CustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFields.
     */
    data: CustomFieldCreateManyInput | CustomFieldCreateManyInput[]
  }


  /**
   * CustomField update
   */
  export type CustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomField.
     */
    data: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
    /**
     * Choose, which CustomField to update.
     */
    where: CustomFieldWhereUniqueInput
  }


  /**
   * CustomField updateMany
   */
  export type CustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFields.
     */
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which CustomFields to update
     */
    where?: CustomFieldWhereInput
  }


  /**
   * CustomField upsert
   */
  export type CustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomField to update in case it exists.
     */
    where: CustomFieldWhereUniqueInput
    /**
     * In case the CustomField found by the `where` argument doesn't exist, create a new CustomField with this data.
     */
    create: XOR<CustomFieldCreateInput, CustomFieldUncheckedCreateInput>
    /**
     * In case the CustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldUpdateInput, CustomFieldUncheckedUpdateInput>
  }


  /**
   * CustomField delete
   */
  export type CustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    /**
     * Filter which CustomField to delete.
     */
    where: CustomFieldWhereUniqueInput
  }


  /**
   * CustomField deleteMany
   */
  export type CustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFields to delete
     */
    where?: CustomFieldWhereInput
  }


  /**
   * CustomField findRaw
   */
  export type CustomFieldFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CustomField aggregateRaw
   */
  export type CustomFieldAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CustomField.customFieldValues
   */
  export type CustomField$customFieldValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    cursor?: CustomFieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }


  /**
   * CustomField without action
   */
  export type CustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
  }



  /**
   * Model CustomFieldValue
   */

  export type AggregateCustomFieldValue = {
    _count: CustomFieldValueCountAggregateOutputType | null
    _avg: CustomFieldValueAvgAggregateOutputType | null
    _sum: CustomFieldValueSumAggregateOutputType | null
    _min: CustomFieldValueMinAggregateOutputType | null
    _max: CustomFieldValueMaxAggregateOutputType | null
  }

  export type CustomFieldValueAvgAggregateOutputType = {
    value_number: number | null
  }

  export type CustomFieldValueSumAggregateOutputType = {
    value_number: number | null
  }

  export type CustomFieldValueMinAggregateOutputType = {
    id: string | null
    value_string: string | null
    value_number: number | null
    value_date: Date | null
    value_boolean: boolean | null
    customFieldId: string | null
    targetContactId: string | null
  }

  export type CustomFieldValueMaxAggregateOutputType = {
    id: string | null
    value_string: string | null
    value_number: number | null
    value_date: Date | null
    value_boolean: boolean | null
    customFieldId: string | null
    targetContactId: string | null
  }

  export type CustomFieldValueCountAggregateOutputType = {
    id: number
    value_string: number
    value_number: number
    value_date: number
    value_boolean: number
    customFieldId: number
    targetContactId: number
    _all: number
  }


  export type CustomFieldValueAvgAggregateInputType = {
    value_number?: true
  }

  export type CustomFieldValueSumAggregateInputType = {
    value_number?: true
  }

  export type CustomFieldValueMinAggregateInputType = {
    id?: true
    value_string?: true
    value_number?: true
    value_date?: true
    value_boolean?: true
    customFieldId?: true
    targetContactId?: true
  }

  export type CustomFieldValueMaxAggregateInputType = {
    id?: true
    value_string?: true
    value_number?: true
    value_date?: true
    value_boolean?: true
    customFieldId?: true
    targetContactId?: true
  }

  export type CustomFieldValueCountAggregateInputType = {
    id?: true
    value_string?: true
    value_number?: true
    value_date?: true
    value_boolean?: true
    customFieldId?: true
    targetContactId?: true
    _all?: true
  }

  export type CustomFieldValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFieldValue to aggregate.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomFieldValues
    **/
    _count?: true | CustomFieldValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomFieldValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomFieldValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomFieldValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomFieldValueMaxAggregateInputType
  }

  export type GetCustomFieldValueAggregateType<T extends CustomFieldValueAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomFieldValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomFieldValue[P]>
      : GetScalarType<T[P], AggregateCustomFieldValue[P]>
  }




  export type CustomFieldValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithAggregationInput | CustomFieldValueOrderByWithAggregationInput[]
    by: CustomFieldValueScalarFieldEnum[] | CustomFieldValueScalarFieldEnum
    having?: CustomFieldValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomFieldValueCountAggregateInputType | true
    _avg?: CustomFieldValueAvgAggregateInputType
    _sum?: CustomFieldValueSumAggregateInputType
    _min?: CustomFieldValueMinAggregateInputType
    _max?: CustomFieldValueMaxAggregateInputType
  }

  export type CustomFieldValueGroupByOutputType = {
    id: string
    value_string: string
    value_number: number
    value_date: Date
    value_boolean: boolean
    customFieldId: string
    targetContactId: string
    _count: CustomFieldValueCountAggregateOutputType | null
    _avg: CustomFieldValueAvgAggregateOutputType | null
    _sum: CustomFieldValueSumAggregateOutputType | null
    _min: CustomFieldValueMinAggregateOutputType | null
    _max: CustomFieldValueMaxAggregateOutputType | null
  }

  type GetCustomFieldValueGroupByPayload<T extends CustomFieldValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomFieldValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomFieldValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomFieldValueGroupByOutputType[P]>
            : GetScalarType<T[P], CustomFieldValueGroupByOutputType[P]>
        }
      >
    >


  export type CustomFieldValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value_string?: boolean
    value_number?: boolean
    value_date?: boolean
    value_boolean?: boolean
    customFieldId?: boolean
    targetContactId?: boolean
    customField?: boolean | CustomFieldValue$customFieldArgs<ExtArgs>
    targetContact?: boolean | TargetContactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customFieldValue"]>

  export type CustomFieldValueSelectScalar = {
    id?: boolean
    value_string?: boolean
    value_number?: boolean
    value_date?: boolean
    value_boolean?: boolean
    customFieldId?: boolean
    targetContactId?: boolean
  }

  export type CustomFieldValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customField?: boolean | CustomFieldValue$customFieldArgs<ExtArgs>
    targetContact?: boolean | TargetContactDefaultArgs<ExtArgs>
  }


  export type $CustomFieldValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomFieldValue"
    objects: {
      customField: Prisma.$CustomFieldPayload<ExtArgs> | null
      targetContact: Prisma.$TargetContactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      value_string: string
      value_number: number
      value_date: Date
      value_boolean: boolean
      customFieldId: string
      targetContactId: string
    }, ExtArgs["result"]["customFieldValue"]>
    composites: {}
  }


  type CustomFieldValueGetPayload<S extends boolean | null | undefined | CustomFieldValueDefaultArgs> = $Result.GetResult<Prisma.$CustomFieldValuePayload, S>

  type CustomFieldValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomFieldValueFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CustomFieldValueCountAggregateInputType | true
    }

  export interface CustomFieldValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomFieldValue'], meta: { name: 'CustomFieldValue' } }
    /**
     * Find zero or one CustomFieldValue that matches the filter.
     * @param {CustomFieldValueFindUniqueArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomFieldValueFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldValueFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one CustomFieldValue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomFieldValueFindUniqueOrThrowArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldValueFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first CustomFieldValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindFirstArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomFieldValueFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldValueFindFirstArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first CustomFieldValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindFirstOrThrowArgs} args - Arguments to find a CustomFieldValue
     * @example
     * // Get one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomFieldValueFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldValueFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more CustomFieldValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomFieldValues
     * const customFieldValues = await prisma.customFieldValue.findMany()
     * 
     * // Get first 10 CustomFieldValues
     * const customFieldValues = await prisma.customFieldValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customFieldValueWithIdOnly = await prisma.customFieldValue.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomFieldValueFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldValueFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a CustomFieldValue.
     * @param {CustomFieldValueCreateArgs} args - Arguments to create a CustomFieldValue.
     * @example
     * // Create one CustomFieldValue
     * const CustomFieldValue = await prisma.customFieldValue.create({
     *   data: {
     *     // ... data to create a CustomFieldValue
     *   }
     * })
     * 
    **/
    create<T extends CustomFieldValueCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldValueCreateArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many CustomFieldValues.
     *     @param {CustomFieldValueCreateManyArgs} args - Arguments to create many CustomFieldValues.
     *     @example
     *     // Create many CustomFieldValues
     *     const customFieldValue = await prisma.customFieldValue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomFieldValueCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldValueCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CustomFieldValue.
     * @param {CustomFieldValueDeleteArgs} args - Arguments to delete one CustomFieldValue.
     * @example
     * // Delete one CustomFieldValue
     * const CustomFieldValue = await prisma.customFieldValue.delete({
     *   where: {
     *     // ... filter to delete one CustomFieldValue
     *   }
     * })
     * 
    **/
    delete<T extends CustomFieldValueDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldValueDeleteArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one CustomFieldValue.
     * @param {CustomFieldValueUpdateArgs} args - Arguments to update one CustomFieldValue.
     * @example
     * // Update one CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomFieldValueUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldValueUpdateArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more CustomFieldValues.
     * @param {CustomFieldValueDeleteManyArgs} args - Arguments to filter CustomFieldValues to delete.
     * @example
     * // Delete a few CustomFieldValues
     * const { count } = await prisma.customFieldValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomFieldValueDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomFieldValueDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomFieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomFieldValues
     * const customFieldValue = await prisma.customFieldValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomFieldValueUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldValueUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomFieldValue.
     * @param {CustomFieldValueUpsertArgs} args - Arguments to update or create a CustomFieldValue.
     * @example
     * // Update or create a CustomFieldValue
     * const customFieldValue = await prisma.customFieldValue.upsert({
     *   create: {
     *     // ... data to create a CustomFieldValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomFieldValue we want to update
     *   }
     * })
    **/
    upsert<T extends CustomFieldValueUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomFieldValueUpsertArgs<ExtArgs>>
    ): Prisma__CustomFieldValueClient<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more CustomFieldValues that matches the filter.
     * @param {CustomFieldValueFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customFieldValue = await prisma.customFieldValue.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CustomFieldValueFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a CustomFieldValue.
     * @param {CustomFieldValueAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customFieldValue = await prisma.customFieldValue.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CustomFieldValueAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of CustomFieldValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueCountArgs} args - Arguments to filter CustomFieldValues to count.
     * @example
     * // Count the number of CustomFieldValues
     * const count = await prisma.customFieldValue.count({
     *   where: {
     *     // ... the filter for the CustomFieldValues we want to count
     *   }
     * })
    **/
    count<T extends CustomFieldValueCountArgs>(
      args?: Subset<T, CustomFieldValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomFieldValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomFieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomFieldValueAggregateArgs>(args: Subset<T, CustomFieldValueAggregateArgs>): Prisma.PrismaPromise<GetCustomFieldValueAggregateType<T>>

    /**
     * Group by CustomFieldValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomFieldValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomFieldValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomFieldValueGroupByArgs['orderBy'] }
        : { orderBy?: CustomFieldValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomFieldValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomFieldValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomFieldValue model
   */
  readonly fields: CustomFieldValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomFieldValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomFieldValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customField<T extends CustomFieldValue$customFieldArgs<ExtArgs> = {}>(args?: Subset<T, CustomFieldValue$customFieldArgs<ExtArgs>>): Prisma__CustomFieldClient<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    targetContact<T extends TargetContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TargetContactDefaultArgs<ExtArgs>>): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the CustomFieldValue model
   */ 
  interface CustomFieldValueFieldRefs {
    readonly id: FieldRef<"CustomFieldValue", 'String'>
    readonly value_string: FieldRef<"CustomFieldValue", 'String'>
    readonly value_number: FieldRef<"CustomFieldValue", 'Float'>
    readonly value_date: FieldRef<"CustomFieldValue", 'DateTime'>
    readonly value_boolean: FieldRef<"CustomFieldValue", 'Boolean'>
    readonly customFieldId: FieldRef<"CustomFieldValue", 'String'>
    readonly targetContactId: FieldRef<"CustomFieldValue", 'String'>
  }
    

  // Custom InputTypes

  /**
   * CustomFieldValue findUnique
   */
  export type CustomFieldValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where: CustomFieldValueWhereUniqueInput
  }


  /**
   * CustomFieldValue findUniqueOrThrow
   */
  export type CustomFieldValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where: CustomFieldValueWhereUniqueInput
  }


  /**
   * CustomFieldValue findFirst
   */
  export type CustomFieldValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFieldValues.
     */
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }


  /**
   * CustomFieldValue findFirstOrThrow
   */
  export type CustomFieldValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValue to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomFieldValues.
     */
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }


  /**
   * CustomFieldValue findMany
   */
  export type CustomFieldValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter, which CustomFieldValues to fetch.
     */
    where?: CustomFieldValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomFieldValues to fetch.
     */
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomFieldValues.
     */
    cursor?: CustomFieldValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomFieldValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomFieldValues.
     */
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }


  /**
   * CustomFieldValue create
   */
  export type CustomFieldValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomFieldValue.
     */
    data: XOR<CustomFieldValueCreateInput, CustomFieldValueUncheckedCreateInput>
  }


  /**
   * CustomFieldValue createMany
   */
  export type CustomFieldValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomFieldValues.
     */
    data: CustomFieldValueCreateManyInput | CustomFieldValueCreateManyInput[]
  }


  /**
   * CustomFieldValue update
   */
  export type CustomFieldValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomFieldValue.
     */
    data: XOR<CustomFieldValueUpdateInput, CustomFieldValueUncheckedUpdateInput>
    /**
     * Choose, which CustomFieldValue to update.
     */
    where: CustomFieldValueWhereUniqueInput
  }


  /**
   * CustomFieldValue updateMany
   */
  export type CustomFieldValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomFieldValues.
     */
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyInput>
    /**
     * Filter which CustomFieldValues to update
     */
    where?: CustomFieldValueWhereInput
  }


  /**
   * CustomFieldValue upsert
   */
  export type CustomFieldValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomFieldValue to update in case it exists.
     */
    where: CustomFieldValueWhereUniqueInput
    /**
     * In case the CustomFieldValue found by the `where` argument doesn't exist, create a new CustomFieldValue with this data.
     */
    create: XOR<CustomFieldValueCreateInput, CustomFieldValueUncheckedCreateInput>
    /**
     * In case the CustomFieldValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomFieldValueUpdateInput, CustomFieldValueUncheckedUpdateInput>
  }


  /**
   * CustomFieldValue delete
   */
  export type CustomFieldValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    /**
     * Filter which CustomFieldValue to delete.
     */
    where: CustomFieldValueWhereUniqueInput
  }


  /**
   * CustomFieldValue deleteMany
   */
  export type CustomFieldValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomFieldValues to delete
     */
    where?: CustomFieldValueWhereInput
  }


  /**
   * CustomFieldValue findRaw
   */
  export type CustomFieldValueFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CustomFieldValue aggregateRaw
   */
  export type CustomFieldValueAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * CustomFieldValue.customField
   */
  export type CustomFieldValue$customFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    where?: CustomFieldWhereInput
  }


  /**
   * CustomFieldValue without action
   */
  export type CustomFieldValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
  }



  /**
   * Model TargetContact
   */

  export type AggregateTargetContact = {
    _count: TargetContactCountAggregateOutputType | null
    _min: TargetContactMinAggregateOutputType | null
    _max: TargetContactMaxAggregateOutputType | null
  }

  export type TargetContactMinAggregateOutputType = {
    id: string | null
    githubTargetId: string | null
    industry: string | null
    projectOwner: string | null
    projectName: string | null
    type: string | null
    location: string | null
    teamAccountId: string | null
    status: string | null
  }

  export type TargetContactMaxAggregateOutputType = {
    id: string | null
    githubTargetId: string | null
    industry: string | null
    projectOwner: string | null
    projectName: string | null
    type: string | null
    location: string | null
    teamAccountId: string | null
    status: string | null
  }

  export type TargetContactCountAggregateOutputType = {
    id: number
    githubTargetId: number
    industry: number
    projectOwner: number
    projectName: number
    type: number
    location: number
    teamAccountId: number
    status: number
    campaignIds: number
    _all: number
  }


  export type TargetContactMinAggregateInputType = {
    id?: true
    githubTargetId?: true
    industry?: true
    projectOwner?: true
    projectName?: true
    type?: true
    location?: true
    teamAccountId?: true
    status?: true
  }

  export type TargetContactMaxAggregateInputType = {
    id?: true
    githubTargetId?: true
    industry?: true
    projectOwner?: true
    projectName?: true
    type?: true
    location?: true
    teamAccountId?: true
    status?: true
  }

  export type TargetContactCountAggregateInputType = {
    id?: true
    githubTargetId?: true
    industry?: true
    projectOwner?: true
    projectName?: true
    type?: true
    location?: true
    teamAccountId?: true
    status?: true
    campaignIds?: true
    _all?: true
  }

  export type TargetContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetContact to aggregate.
     */
    where?: TargetContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetContacts to fetch.
     */
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TargetContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TargetContacts
    **/
    _count?: true | TargetContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TargetContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TargetContactMaxAggregateInputType
  }

  export type GetTargetContactAggregateType<T extends TargetContactAggregateArgs> = {
        [P in keyof T & keyof AggregateTargetContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTargetContact[P]>
      : GetScalarType<T[P], AggregateTargetContact[P]>
  }




  export type TargetContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TargetContactWhereInput
    orderBy?: TargetContactOrderByWithAggregationInput | TargetContactOrderByWithAggregationInput[]
    by: TargetContactScalarFieldEnum[] | TargetContactScalarFieldEnum
    having?: TargetContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TargetContactCountAggregateInputType | true
    _min?: TargetContactMinAggregateInputType
    _max?: TargetContactMaxAggregateInputType
  }

  export type TargetContactGroupByOutputType = {
    id: string
    githubTargetId: string | null
    industry: string | null
    projectOwner: string | null
    projectName: string | null
    type: string
    location: string | null
    teamAccountId: string
    status: string | null
    campaignIds: string[]
    _count: TargetContactCountAggregateOutputType | null
    _min: TargetContactMinAggregateOutputType | null
    _max: TargetContactMaxAggregateOutputType | null
  }

  type GetTargetContactGroupByPayload<T extends TargetContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TargetContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TargetContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TargetContactGroupByOutputType[P]>
            : GetScalarType<T[P], TargetContactGroupByOutputType[P]>
        }
      >
    >


  export type TargetContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    githubTargetId?: boolean
    industry?: boolean
    projectOwner?: boolean
    projectName?: boolean
    type?: boolean
    location?: boolean
    teamAccountId?: boolean
    status?: boolean
    campaignIds?: boolean
    githubTarget?: boolean | TargetContact$githubTargetArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    campaigns?: boolean | TargetContact$campaignsArgs<ExtArgs>
    customFieldValue?: boolean | TargetContact$customFieldValueArgs<ExtArgs>
    _count?: boolean | TargetContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["targetContact"]>

  export type TargetContactSelectScalar = {
    id?: boolean
    githubTargetId?: boolean
    industry?: boolean
    projectOwner?: boolean
    projectName?: boolean
    type?: boolean
    location?: boolean
    teamAccountId?: boolean
    status?: boolean
    campaignIds?: boolean
  }

  export type TargetContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    githubTarget?: boolean | TargetContact$githubTargetArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    campaigns?: boolean | TargetContact$campaignsArgs<ExtArgs>
    customFieldValue?: boolean | TargetContact$customFieldValueArgs<ExtArgs>
    _count?: boolean | TargetContactCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TargetContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TargetContact"
    objects: {
      githubTarget: Prisma.$GithubTargetPayload<ExtArgs> | null
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      customFieldValue: Prisma.$CustomFieldValuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      githubTargetId: string | null
      industry: string | null
      projectOwner: string | null
      projectName: string | null
      type: string
      location: string | null
      teamAccountId: string
      status: string | null
      campaignIds: string[]
    }, ExtArgs["result"]["targetContact"]>
    composites: {}
  }


  type TargetContactGetPayload<S extends boolean | null | undefined | TargetContactDefaultArgs> = $Result.GetResult<Prisma.$TargetContactPayload, S>

  type TargetContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TargetContactFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TargetContactCountAggregateInputType | true
    }

  export interface TargetContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TargetContact'], meta: { name: 'TargetContact' } }
    /**
     * Find zero or one TargetContact that matches the filter.
     * @param {TargetContactFindUniqueArgs} args - Arguments to find a TargetContact
     * @example
     * // Get one TargetContact
     * const targetContact = await prisma.targetContact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TargetContactFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TargetContactFindUniqueArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TargetContact that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TargetContactFindUniqueOrThrowArgs} args - Arguments to find a TargetContact
     * @example
     * // Get one TargetContact
     * const targetContact = await prisma.targetContact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TargetContactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetContactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TargetContact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactFindFirstArgs} args - Arguments to find a TargetContact
     * @example
     * // Get one TargetContact
     * const targetContact = await prisma.targetContact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TargetContactFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetContactFindFirstArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TargetContact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactFindFirstOrThrowArgs} args - Arguments to find a TargetContact
     * @example
     * // Get one TargetContact
     * const targetContact = await prisma.targetContact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TargetContactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetContactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TargetContacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TargetContacts
     * const targetContacts = await prisma.targetContact.findMany()
     * 
     * // Get first 10 TargetContacts
     * const targetContacts = await prisma.targetContact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const targetContactWithIdOnly = await prisma.targetContact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TargetContactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetContactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TargetContact.
     * @param {TargetContactCreateArgs} args - Arguments to create a TargetContact.
     * @example
     * // Create one TargetContact
     * const TargetContact = await prisma.targetContact.create({
     *   data: {
     *     // ... data to create a TargetContact
     *   }
     * })
     * 
    **/
    create<T extends TargetContactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TargetContactCreateArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TargetContacts.
     *     @param {TargetContactCreateManyArgs} args - Arguments to create many TargetContacts.
     *     @example
     *     // Create many TargetContacts
     *     const targetContact = await prisma.targetContact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TargetContactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetContactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TargetContact.
     * @param {TargetContactDeleteArgs} args - Arguments to delete one TargetContact.
     * @example
     * // Delete one TargetContact
     * const TargetContact = await prisma.targetContact.delete({
     *   where: {
     *     // ... filter to delete one TargetContact
     *   }
     * })
     * 
    **/
    delete<T extends TargetContactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TargetContactDeleteArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TargetContact.
     * @param {TargetContactUpdateArgs} args - Arguments to update one TargetContact.
     * @example
     * // Update one TargetContact
     * const targetContact = await prisma.targetContact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TargetContactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TargetContactUpdateArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TargetContacts.
     * @param {TargetContactDeleteManyArgs} args - Arguments to filter TargetContacts to delete.
     * @example
     * // Delete a few TargetContacts
     * const { count } = await prisma.targetContact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TargetContactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TargetContactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TargetContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TargetContacts
     * const targetContact = await prisma.targetContact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TargetContactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TargetContactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TargetContact.
     * @param {TargetContactUpsertArgs} args - Arguments to update or create a TargetContact.
     * @example
     * // Update or create a TargetContact
     * const targetContact = await prisma.targetContact.upsert({
     *   create: {
     *     // ... data to create a TargetContact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TargetContact we want to update
     *   }
     * })
    **/
    upsert<T extends TargetContactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TargetContactUpsertArgs<ExtArgs>>
    ): Prisma__TargetContactClient<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more TargetContacts that matches the filter.
     * @param {TargetContactFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const targetContact = await prisma.targetContact.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TargetContactFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TargetContact.
     * @param {TargetContactAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const targetContact = await prisma.targetContact.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TargetContactAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of TargetContacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactCountArgs} args - Arguments to filter TargetContacts to count.
     * @example
     * // Count the number of TargetContacts
     * const count = await prisma.targetContact.count({
     *   where: {
     *     // ... the filter for the TargetContacts we want to count
     *   }
     * })
    **/
    count<T extends TargetContactCountArgs>(
      args?: Subset<T, TargetContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TargetContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TargetContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TargetContactAggregateArgs>(args: Subset<T, TargetContactAggregateArgs>): Prisma.PrismaPromise<GetTargetContactAggregateType<T>>

    /**
     * Group by TargetContact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TargetContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TargetContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TargetContactGroupByArgs['orderBy'] }
        : { orderBy?: TargetContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TargetContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTargetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TargetContact model
   */
  readonly fields: TargetContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TargetContact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TargetContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    githubTarget<T extends TargetContact$githubTargetArgs<ExtArgs> = {}>(args?: Subset<T, TargetContact$githubTargetArgs<ExtArgs>>): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    teamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    campaigns<T extends TargetContact$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, TargetContact$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'> | Null>;

    customFieldValue<T extends TargetContact$customFieldValueArgs<ExtArgs> = {}>(args?: Subset<T, TargetContact$customFieldValueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldValuePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TargetContact model
   */ 
  interface TargetContactFieldRefs {
    readonly id: FieldRef<"TargetContact", 'String'>
    readonly githubTargetId: FieldRef<"TargetContact", 'String'>
    readonly industry: FieldRef<"TargetContact", 'String'>
    readonly projectOwner: FieldRef<"TargetContact", 'String'>
    readonly projectName: FieldRef<"TargetContact", 'String'>
    readonly type: FieldRef<"TargetContact", 'String'>
    readonly location: FieldRef<"TargetContact", 'String'>
    readonly teamAccountId: FieldRef<"TargetContact", 'String'>
    readonly status: FieldRef<"TargetContact", 'String'>
    readonly campaignIds: FieldRef<"TargetContact", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * TargetContact findUnique
   */
  export type TargetContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * Filter, which TargetContact to fetch.
     */
    where: TargetContactWhereUniqueInput
  }


  /**
   * TargetContact findUniqueOrThrow
   */
  export type TargetContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * Filter, which TargetContact to fetch.
     */
    where: TargetContactWhereUniqueInput
  }


  /**
   * TargetContact findFirst
   */
  export type TargetContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * Filter, which TargetContact to fetch.
     */
    where?: TargetContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetContacts to fetch.
     */
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetContacts.
     */
    cursor?: TargetContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetContacts.
     */
    distinct?: TargetContactScalarFieldEnum | TargetContactScalarFieldEnum[]
  }


  /**
   * TargetContact findFirstOrThrow
   */
  export type TargetContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * Filter, which TargetContact to fetch.
     */
    where?: TargetContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetContacts to fetch.
     */
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TargetContacts.
     */
    cursor?: TargetContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetContacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TargetContacts.
     */
    distinct?: TargetContactScalarFieldEnum | TargetContactScalarFieldEnum[]
  }


  /**
   * TargetContact findMany
   */
  export type TargetContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * Filter, which TargetContacts to fetch.
     */
    where?: TargetContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TargetContacts to fetch.
     */
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TargetContacts.
     */
    cursor?: TargetContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TargetContacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TargetContacts.
     */
    skip?: number
    distinct?: TargetContactScalarFieldEnum | TargetContactScalarFieldEnum[]
  }


  /**
   * TargetContact create
   */
  export type TargetContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * The data needed to create a TargetContact.
     */
    data: XOR<TargetContactCreateInput, TargetContactUncheckedCreateInput>
  }


  /**
   * TargetContact createMany
   */
  export type TargetContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TargetContacts.
     */
    data: TargetContactCreateManyInput | TargetContactCreateManyInput[]
  }


  /**
   * TargetContact update
   */
  export type TargetContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * The data needed to update a TargetContact.
     */
    data: XOR<TargetContactUpdateInput, TargetContactUncheckedUpdateInput>
    /**
     * Choose, which TargetContact to update.
     */
    where: TargetContactWhereUniqueInput
  }


  /**
   * TargetContact updateMany
   */
  export type TargetContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TargetContacts.
     */
    data: XOR<TargetContactUpdateManyMutationInput, TargetContactUncheckedUpdateManyInput>
    /**
     * Filter which TargetContacts to update
     */
    where?: TargetContactWhereInput
  }


  /**
   * TargetContact upsert
   */
  export type TargetContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * The filter to search for the TargetContact to update in case it exists.
     */
    where: TargetContactWhereUniqueInput
    /**
     * In case the TargetContact found by the `where` argument doesn't exist, create a new TargetContact with this data.
     */
    create: XOR<TargetContactCreateInput, TargetContactUncheckedCreateInput>
    /**
     * In case the TargetContact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TargetContactUpdateInput, TargetContactUncheckedUpdateInput>
  }


  /**
   * TargetContact delete
   */
  export type TargetContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    /**
     * Filter which TargetContact to delete.
     */
    where: TargetContactWhereUniqueInput
  }


  /**
   * TargetContact deleteMany
   */
  export type TargetContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TargetContacts to delete
     */
    where?: TargetContactWhereInput
  }


  /**
   * TargetContact findRaw
   */
  export type TargetContactFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TargetContact aggregateRaw
   */
  export type TargetContactAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * TargetContact.githubTarget
   */
  export type TargetContact$githubTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    where?: GithubTargetWhereInput
  }


  /**
   * TargetContact.campaigns
   */
  export type TargetContact$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * TargetContact.customFieldValue
   */
  export type TargetContact$customFieldValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomFieldValue
     */
    select?: CustomFieldValueSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldValueInclude<ExtArgs> | null
    where?: CustomFieldValueWhereInput
    orderBy?: CustomFieldValueOrderByWithRelationInput | CustomFieldValueOrderByWithRelationInput[]
    cursor?: CustomFieldValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldValueScalarFieldEnum | CustomFieldValueScalarFieldEnum[]
  }


  /**
   * TargetContact without action
   */
  export type TargetContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
  }



  /**
   * Model GithubTarget
   */

  export type AggregateGithubTarget = {
    _count: GithubTargetCountAggregateOutputType | null
    _min: GithubTargetMinAggregateOutputType | null
    _max: GithubTargetMaxAggregateOutputType | null
  }

  export type GithubTargetMinAggregateOutputType = {
    id: string | null
    githubGraphqlId: string | null
    type: string | null
    displayName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GithubTargetMaxAggregateOutputType = {
    id: string | null
    githubGraphqlId: string | null
    type: string | null
    displayName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GithubTargetCountAggregateOutputType = {
    id: number
    githubGraphqlId: number
    campaignIds: number
    reportIds: number
    type: number
    metadata: number
    displayName: number
    createdAt: number
    updatedAt: number
    contactIds: number
    emailThreadIds: number
    _all: number
  }


  export type GithubTargetMinAggregateInputType = {
    id?: true
    githubGraphqlId?: true
    type?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GithubTargetMaxAggregateInputType = {
    id?: true
    githubGraphqlId?: true
    type?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GithubTargetCountAggregateInputType = {
    id?: true
    githubGraphqlId?: true
    campaignIds?: true
    reportIds?: true
    type?: true
    metadata?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
    contactIds?: true
    emailThreadIds?: true
    _all?: true
  }

  export type GithubTargetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GithubTarget to aggregate.
     */
    where?: GithubTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubTargets to fetch.
     */
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GithubTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GithubTargets
    **/
    _count?: true | GithubTargetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GithubTargetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GithubTargetMaxAggregateInputType
  }

  export type GetGithubTargetAggregateType<T extends GithubTargetAggregateArgs> = {
        [P in keyof T & keyof AggregateGithubTarget]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGithubTarget[P]>
      : GetScalarType<T[P], AggregateGithubTarget[P]>
  }




  export type GithubTargetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubTargetWhereInput
    orderBy?: GithubTargetOrderByWithAggregationInput | GithubTargetOrderByWithAggregationInput[]
    by: GithubTargetScalarFieldEnum[] | GithubTargetScalarFieldEnum
    having?: GithubTargetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GithubTargetCountAggregateInputType | true
    _min?: GithubTargetMinAggregateInputType
    _max?: GithubTargetMaxAggregateInputType
  }

  export type GithubTargetGroupByOutputType = {
    id: string
    githubGraphqlId: string
    campaignIds: string[]
    reportIds: string[]
    type: string
    metadata: JsonValue
    displayName: string
    createdAt: Date
    updatedAt: Date
    contactIds: string[]
    emailThreadIds: string[]
    _count: GithubTargetCountAggregateOutputType | null
    _min: GithubTargetMinAggregateOutputType | null
    _max: GithubTargetMaxAggregateOutputType | null
  }

  type GetGithubTargetGroupByPayload<T extends GithubTargetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GithubTargetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GithubTargetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GithubTargetGroupByOutputType[P]>
            : GetScalarType<T[P], GithubTargetGroupByOutputType[P]>
        }
      >
    >


  export type GithubTargetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    githubGraphqlId?: boolean
    campaignIds?: boolean
    reportIds?: boolean
    type?: boolean
    metadata?: boolean
    displayName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactIds?: boolean
    emailThreadIds?: boolean
    campaigns?: boolean | GithubTarget$campaignsArgs<ExtArgs>
    reports?: boolean | GithubTarget$reportsArgs<ExtArgs>
    evaluations?: boolean | GithubTarget$evaluationsArgs<ExtArgs>
    contacts?: boolean | GithubTarget$contactsArgs<ExtArgs>
    targetContacts?: boolean | GithubTarget$targetContactsArgs<ExtArgs>
    notes?: boolean | GithubTarget$notesArgs<ExtArgs>
    emailThreads?: boolean | GithubTarget$emailThreadsArgs<ExtArgs>
    _count?: boolean | GithubTargetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["githubTarget"]>

  export type GithubTargetSelectScalar = {
    id?: boolean
    githubGraphqlId?: boolean
    campaignIds?: boolean
    reportIds?: boolean
    type?: boolean
    metadata?: boolean
    displayName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactIds?: boolean
    emailThreadIds?: boolean
  }

  export type GithubTargetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | GithubTarget$campaignsArgs<ExtArgs>
    reports?: boolean | GithubTarget$reportsArgs<ExtArgs>
    evaluations?: boolean | GithubTarget$evaluationsArgs<ExtArgs>
    contacts?: boolean | GithubTarget$contactsArgs<ExtArgs>
    targetContacts?: boolean | GithubTarget$targetContactsArgs<ExtArgs>
    notes?: boolean | GithubTarget$notesArgs<ExtArgs>
    emailThreads?: boolean | GithubTarget$emailThreadsArgs<ExtArgs>
    _count?: boolean | GithubTargetCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $GithubTargetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GithubTarget"
    objects: {
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      targetContacts: Prisma.$TargetContactPayload<ExtArgs>[]
      notes: Prisma.$NotePayload<ExtArgs>[]
      emailThreads: Prisma.$EmailThreadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      githubGraphqlId: string
      campaignIds: string[]
      reportIds: string[]
      type: string
      metadata: Prisma.JsonValue
      displayName: string
      createdAt: Date
      updatedAt: Date
      contactIds: string[]
      emailThreadIds: string[]
    }, ExtArgs["result"]["githubTarget"]>
    composites: {}
  }


  type GithubTargetGetPayload<S extends boolean | null | undefined | GithubTargetDefaultArgs> = $Result.GetResult<Prisma.$GithubTargetPayload, S>

  type GithubTargetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GithubTargetFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GithubTargetCountAggregateInputType | true
    }

  export interface GithubTargetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GithubTarget'], meta: { name: 'GithubTarget' } }
    /**
     * Find zero or one GithubTarget that matches the filter.
     * @param {GithubTargetFindUniqueArgs} args - Arguments to find a GithubTarget
     * @example
     * // Get one GithubTarget
     * const githubTarget = await prisma.githubTarget.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GithubTargetFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GithubTargetFindUniqueArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GithubTarget that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GithubTargetFindUniqueOrThrowArgs} args - Arguments to find a GithubTarget
     * @example
     * // Get one GithubTarget
     * const githubTarget = await prisma.githubTarget.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GithubTargetFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubTargetFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GithubTarget that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetFindFirstArgs} args - Arguments to find a GithubTarget
     * @example
     * // Get one GithubTarget
     * const githubTarget = await prisma.githubTarget.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GithubTargetFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubTargetFindFirstArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GithubTarget that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetFindFirstOrThrowArgs} args - Arguments to find a GithubTarget
     * @example
     * // Get one GithubTarget
     * const githubTarget = await prisma.githubTarget.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GithubTargetFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubTargetFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GithubTargets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GithubTargets
     * const githubTargets = await prisma.githubTarget.findMany()
     * 
     * // Get first 10 GithubTargets
     * const githubTargets = await prisma.githubTarget.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const githubTargetWithIdOnly = await prisma.githubTarget.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GithubTargetFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubTargetFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GithubTarget.
     * @param {GithubTargetCreateArgs} args - Arguments to create a GithubTarget.
     * @example
     * // Create one GithubTarget
     * const GithubTarget = await prisma.githubTarget.create({
     *   data: {
     *     // ... data to create a GithubTarget
     *   }
     * })
     * 
    **/
    create<T extends GithubTargetCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GithubTargetCreateArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GithubTargets.
     *     @param {GithubTargetCreateManyArgs} args - Arguments to create many GithubTargets.
     *     @example
     *     // Create many GithubTargets
     *     const githubTarget = await prisma.githubTarget.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GithubTargetCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubTargetCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GithubTarget.
     * @param {GithubTargetDeleteArgs} args - Arguments to delete one GithubTarget.
     * @example
     * // Delete one GithubTarget
     * const GithubTarget = await prisma.githubTarget.delete({
     *   where: {
     *     // ... filter to delete one GithubTarget
     *   }
     * })
     * 
    **/
    delete<T extends GithubTargetDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GithubTargetDeleteArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GithubTarget.
     * @param {GithubTargetUpdateArgs} args - Arguments to update one GithubTarget.
     * @example
     * // Update one GithubTarget
     * const githubTarget = await prisma.githubTarget.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GithubTargetUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GithubTargetUpdateArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GithubTargets.
     * @param {GithubTargetDeleteManyArgs} args - Arguments to filter GithubTargets to delete.
     * @example
     * // Delete a few GithubTargets
     * const { count } = await prisma.githubTarget.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GithubTargetDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubTargetDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GithubTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GithubTargets
     * const githubTarget = await prisma.githubTarget.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GithubTargetUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GithubTargetUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GithubTarget.
     * @param {GithubTargetUpsertArgs} args - Arguments to update or create a GithubTarget.
     * @example
     * // Update or create a GithubTarget
     * const githubTarget = await prisma.githubTarget.upsert({
     *   create: {
     *     // ... data to create a GithubTarget
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GithubTarget we want to update
     *   }
     * })
    **/
    upsert<T extends GithubTargetUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GithubTargetUpsertArgs<ExtArgs>>
    ): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more GithubTargets that matches the filter.
     * @param {GithubTargetFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const githubTarget = await prisma.githubTarget.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: GithubTargetFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GithubTarget.
     * @param {GithubTargetAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const githubTarget = await prisma.githubTarget.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: GithubTargetAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of GithubTargets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetCountArgs} args - Arguments to filter GithubTargets to count.
     * @example
     * // Count the number of GithubTargets
     * const count = await prisma.githubTarget.count({
     *   where: {
     *     // ... the filter for the GithubTargets we want to count
     *   }
     * })
    **/
    count<T extends GithubTargetCountArgs>(
      args?: Subset<T, GithubTargetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GithubTargetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GithubTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GithubTargetAggregateArgs>(args: Subset<T, GithubTargetAggregateArgs>): Prisma.PrismaPromise<GetGithubTargetAggregateType<T>>

    /**
     * Group by GithubTarget.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubTargetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GithubTargetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GithubTargetGroupByArgs['orderBy'] }
        : { orderBy?: GithubTargetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GithubTargetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGithubTargetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GithubTarget model
   */
  readonly fields: GithubTargetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GithubTarget.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GithubTargetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaigns<T extends GithubTarget$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'> | Null>;

    reports<T extends GithubTarget$reportsArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluations<T extends GithubTarget$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    contacts<T extends GithubTarget$contactsArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    targetContacts<T extends GithubTarget$targetContactsArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$targetContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends GithubTarget$notesArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotePayload<ExtArgs>, T, 'findMany'> | Null>;

    emailThreads<T extends GithubTarget$emailThreadsArgs<ExtArgs> = {}>(args?: Subset<T, GithubTarget$emailThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailThreadPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GithubTarget model
   */ 
  interface GithubTargetFieldRefs {
    readonly id: FieldRef<"GithubTarget", 'String'>
    readonly githubGraphqlId: FieldRef<"GithubTarget", 'String'>
    readonly campaignIds: FieldRef<"GithubTarget", 'String[]'>
    readonly reportIds: FieldRef<"GithubTarget", 'String[]'>
    readonly type: FieldRef<"GithubTarget", 'String'>
    readonly metadata: FieldRef<"GithubTarget", 'Json'>
    readonly displayName: FieldRef<"GithubTarget", 'String'>
    readonly createdAt: FieldRef<"GithubTarget", 'DateTime'>
    readonly updatedAt: FieldRef<"GithubTarget", 'DateTime'>
    readonly contactIds: FieldRef<"GithubTarget", 'String[]'>
    readonly emailThreadIds: FieldRef<"GithubTarget", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * GithubTarget findUnique
   */
  export type GithubTargetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * Filter, which GithubTarget to fetch.
     */
    where: GithubTargetWhereUniqueInput
  }


  /**
   * GithubTarget findUniqueOrThrow
   */
  export type GithubTargetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * Filter, which GithubTarget to fetch.
     */
    where: GithubTargetWhereUniqueInput
  }


  /**
   * GithubTarget findFirst
   */
  export type GithubTargetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * Filter, which GithubTarget to fetch.
     */
    where?: GithubTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubTargets to fetch.
     */
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GithubTargets.
     */
    cursor?: GithubTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GithubTargets.
     */
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * GithubTarget findFirstOrThrow
   */
  export type GithubTargetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * Filter, which GithubTarget to fetch.
     */
    where?: GithubTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubTargets to fetch.
     */
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GithubTargets.
     */
    cursor?: GithubTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubTargets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GithubTargets.
     */
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * GithubTarget findMany
   */
  export type GithubTargetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * Filter, which GithubTargets to fetch.
     */
    where?: GithubTargetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubTargets to fetch.
     */
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GithubTargets.
     */
    cursor?: GithubTargetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubTargets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubTargets.
     */
    skip?: number
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * GithubTarget create
   */
  export type GithubTargetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * The data needed to create a GithubTarget.
     */
    data: XOR<GithubTargetCreateInput, GithubTargetUncheckedCreateInput>
  }


  /**
   * GithubTarget createMany
   */
  export type GithubTargetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GithubTargets.
     */
    data: GithubTargetCreateManyInput | GithubTargetCreateManyInput[]
  }


  /**
   * GithubTarget update
   */
  export type GithubTargetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * The data needed to update a GithubTarget.
     */
    data: XOR<GithubTargetUpdateInput, GithubTargetUncheckedUpdateInput>
    /**
     * Choose, which GithubTarget to update.
     */
    where: GithubTargetWhereUniqueInput
  }


  /**
   * GithubTarget updateMany
   */
  export type GithubTargetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GithubTargets.
     */
    data: XOR<GithubTargetUpdateManyMutationInput, GithubTargetUncheckedUpdateManyInput>
    /**
     * Filter which GithubTargets to update
     */
    where?: GithubTargetWhereInput
  }


  /**
   * GithubTarget upsert
   */
  export type GithubTargetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * The filter to search for the GithubTarget to update in case it exists.
     */
    where: GithubTargetWhereUniqueInput
    /**
     * In case the GithubTarget found by the `where` argument doesn't exist, create a new GithubTarget with this data.
     */
    create: XOR<GithubTargetCreateInput, GithubTargetUncheckedCreateInput>
    /**
     * In case the GithubTarget was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GithubTargetUpdateInput, GithubTargetUncheckedUpdateInput>
  }


  /**
   * GithubTarget delete
   */
  export type GithubTargetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    /**
     * Filter which GithubTarget to delete.
     */
    where: GithubTargetWhereUniqueInput
  }


  /**
   * GithubTarget deleteMany
   */
  export type GithubTargetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GithubTargets to delete
     */
    where?: GithubTargetWhereInput
  }


  /**
   * GithubTarget findRaw
   */
  export type GithubTargetFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * GithubTarget aggregateRaw
   */
  export type GithubTargetAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * GithubTarget.campaigns
   */
  export type GithubTarget$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * GithubTarget.reports
   */
  export type GithubTarget$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * GithubTarget.evaluations
   */
  export type GithubTarget$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * GithubTarget.contacts
   */
  export type GithubTarget$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }


  /**
   * GithubTarget.targetContacts
   */
  export type GithubTarget$targetContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    where?: TargetContactWhereInput
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    cursor?: TargetContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetContactScalarFieldEnum | TargetContactScalarFieldEnum[]
  }


  /**
   * GithubTarget.notes
   */
  export type GithubTarget$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: NoteOrderByWithRelationInput | NoteOrderByWithRelationInput[]
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }


  /**
   * GithubTarget.emailThreads
   */
  export type GithubTarget$emailThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailThread
     */
    select?: EmailThreadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EmailThreadInclude<ExtArgs> | null
    where?: EmailThreadWhereInput
    orderBy?: EmailThreadOrderByWithRelationInput | EmailThreadOrderByWithRelationInput[]
    cursor?: EmailThreadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailThreadScalarFieldEnum | EmailThreadScalarFieldEnum[]
  }


  /**
   * GithubTarget without action
   */
  export type GithubTargetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
  }



  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    budget: number | null
  }

  export type CampaignSumAggregateOutputType = {
    budget: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    budget: number | null
    lightMode: boolean | null
    startDate: Date | null
    endDate: Date | null
    archived: boolean | null
    archivedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    budget: number | null
    lightMode: boolean | null
    startDate: Date | null
    endDate: Date | null
    archived: boolean | null
    archivedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    targetIds: number
    createdAt: number
    dependenciesInfo: number
    teamAccountIds: number
    targetScoutIds: number
    budget: number
    lightMode: number
    startDate: number
    endDate: number
    targetContactIds: number
    archived: number
    archivedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    budget?: true
  }

  export type CampaignSumAggregateInputType = {
    budget?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    budget?: true
    lightMode?: true
    startDate?: true
    endDate?: true
    archived?: true
    archivedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    budget?: true
    lightMode?: true
    startDate?: true
    endDate?: true
    archived?: true
    archivedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    targetIds?: true
    createdAt?: true
    dependenciesInfo?: true
    teamAccountIds?: true
    targetScoutIds?: true
    budget?: true
    lightMode?: true
    startDate?: true
    endDate?: true
    targetContactIds?: true
    archived?: true
    archivedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    targetIds: string[]
    createdAt: Date
    dependenciesInfo: JsonValue | null
    teamAccountIds: string[]
    targetScoutIds: string[]
    budget: number
    lightMode: boolean | null
    startDate: Date
    endDate: Date | null
    targetContactIds: string[]
    archived: boolean
    archivedAt: Date | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    targetIds?: boolean
    createdAt?: boolean
    dependenciesInfo?: boolean
    teamAccountIds?: boolean
    targetScoutIds?: boolean
    budget?: boolean
    lightMode?: boolean
    startDate?: boolean
    endDate?: boolean
    targetContactIds?: boolean
    archived?: boolean
    archivedAt?: boolean
    githubTargets?: boolean | Campaign$githubTargetsArgs<ExtArgs>
    teamAccounts?: boolean | Campaign$teamAccountsArgs<ExtArgs>
    targetScouts?: boolean | Campaign$targetScoutsArgs<ExtArgs>
    trackers?: boolean | Campaign$trackersArgs<ExtArgs>
    evaluation?: boolean | Campaign$evaluationArgs<ExtArgs>
    targetContacts?: boolean | Campaign$targetContactsArgs<ExtArgs>
    customFields?: boolean | Campaign$customFieldsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    targetIds?: boolean
    createdAt?: boolean
    dependenciesInfo?: boolean
    teamAccountIds?: boolean
    targetScoutIds?: boolean
    budget?: boolean
    lightMode?: boolean
    startDate?: boolean
    endDate?: boolean
    targetContactIds?: boolean
    archived?: boolean
    archivedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    githubTargets?: boolean | Campaign$githubTargetsArgs<ExtArgs>
    teamAccounts?: boolean | Campaign$teamAccountsArgs<ExtArgs>
    targetScouts?: boolean | Campaign$targetScoutsArgs<ExtArgs>
    trackers?: boolean | Campaign$trackersArgs<ExtArgs>
    evaluation?: boolean | Campaign$evaluationArgs<ExtArgs>
    targetContacts?: boolean | Campaign$targetContactsArgs<ExtArgs>
    customFields?: boolean | Campaign$customFieldsArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      githubTargets: Prisma.$GithubTargetPayload<ExtArgs>[]
      teamAccounts: Prisma.$TeamAccountPayload<ExtArgs>[]
      targetScouts: Prisma.$TargetScoutPayload<ExtArgs>[]
      trackers: Prisma.$TrackerPayload<ExtArgs>[]
      evaluation: Prisma.$EvaluationPayload<ExtArgs>[]
      targetContacts: Prisma.$TargetContactPayload<ExtArgs>[]
      customFields: Prisma.$CustomFieldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      targetIds: string[]
      createdAt: Date
      dependenciesInfo: Prisma.JsonValue | null
      teamAccountIds: string[]
      targetScoutIds: string[]
      budget: number
      lightMode: boolean | null
      startDate: Date
      endDate: Date | null
      targetContactIds: string[]
      archived: boolean
      archivedAt: Date | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }


  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CampaignFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CampaignFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CampaignFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
    **/
    create<T extends CampaignCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Campaigns.
     *     @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     *     @example
     *     // Create many Campaigns
     *     const campaign = await prisma.campaign.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CampaignCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
    **/
    delete<T extends CampaignDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CampaignUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CampaignDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CampaignUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
    **/
    upsert<T extends CampaignUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>
    ): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * @param {CampaignFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const campaign = await prisma.campaign.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CampaignFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Campaign.
     * @param {CampaignAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const campaign = await prisma.campaign.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CampaignAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    githubTargets<T extends Campaign$githubTargetsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$githubTargetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findMany'> | Null>;

    teamAccounts<T extends Campaign$teamAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$teamAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findMany'> | Null>;

    targetScouts<T extends Campaign$targetScoutsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$targetScoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetScoutPayload<ExtArgs>, T, 'findMany'> | Null>;

    trackers<T extends Campaign$trackersArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$trackersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findMany'> | Null>;

    evaluation<T extends Campaign$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$evaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    targetContacts<T extends Campaign$targetContactsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$targetContactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TargetContactPayload<ExtArgs>, T, 'findMany'> | Null>;

    customFields<T extends Campaign$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomFieldPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly targetIds: FieldRef<"Campaign", 'String[]'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly dependenciesInfo: FieldRef<"Campaign", 'Json'>
    readonly teamAccountIds: FieldRef<"Campaign", 'String[]'>
    readonly targetScoutIds: FieldRef<"Campaign", 'String[]'>
    readonly budget: FieldRef<"Campaign", 'Int'>
    readonly lightMode: FieldRef<"Campaign", 'Boolean'>
    readonly startDate: FieldRef<"Campaign", 'DateTime'>
    readonly endDate: FieldRef<"Campaign", 'DateTime'>
    readonly targetContactIds: FieldRef<"Campaign", 'String[]'>
    readonly archived: FieldRef<"Campaign", 'Boolean'>
    readonly archivedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }


  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }


  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
  }


  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }


  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }


  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }


  /**
   * Campaign findRaw
   */
  export type CampaignFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Campaign aggregateRaw
   */
  export type CampaignAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Campaign.githubTargets
   */
  export type Campaign$githubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    where?: GithubTargetWhereInput
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    cursor?: GithubTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * Campaign.teamAccounts
   */
  export type Campaign$teamAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamAccount
     */
    select?: TeamAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TeamAccountInclude<ExtArgs> | null
    where?: TeamAccountWhereInput
    orderBy?: TeamAccountOrderByWithRelationInput | TeamAccountOrderByWithRelationInput[]
    cursor?: TeamAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamAccountScalarFieldEnum | TeamAccountScalarFieldEnum[]
  }


  /**
   * Campaign.targetScouts
   */
  export type Campaign$targetScoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetScout
     */
    select?: TargetScoutSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetScoutInclude<ExtArgs> | null
    where?: TargetScoutWhereInput
    orderBy?: TargetScoutOrderByWithRelationInput | TargetScoutOrderByWithRelationInput[]
    cursor?: TargetScoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetScoutScalarFieldEnum | TargetScoutScalarFieldEnum[]
  }


  /**
   * Campaign.trackers
   */
  export type Campaign$trackersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    where?: TrackerWhereInput
    orderBy?: TrackerOrderByWithRelationInput | TrackerOrderByWithRelationInput[]
    cursor?: TrackerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrackerScalarFieldEnum | TrackerScalarFieldEnum[]
  }


  /**
   * Campaign.evaluation
   */
  export type Campaign$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Campaign.targetContacts
   */
  export type Campaign$targetContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TargetContact
     */
    select?: TargetContactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TargetContactInclude<ExtArgs> | null
    where?: TargetContactWhereInput
    orderBy?: TargetContactOrderByWithRelationInput | TargetContactOrderByWithRelationInput[]
    cursor?: TargetContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TargetContactScalarFieldEnum | TargetContactScalarFieldEnum[]
  }


  /**
   * Campaign.customFields
   */
  export type Campaign$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomField
     */
    select?: CustomFieldSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomFieldInclude<ExtArgs> | null
    where?: CustomFieldWhereInput
    orderBy?: CustomFieldOrderByWithRelationInput | CustomFieldOrderByWithRelationInput[]
    cursor?: CustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomFieldScalarFieldEnum | CustomFieldScalarFieldEnum[]
  }


  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CampaignInclude<ExtArgs> | null
  }



  /**
   * Model Tracker
   */

  export type AggregateTracker = {
    _count: TrackerCountAggregateOutputType | null
    _min: TrackerMinAggregateOutputType | null
    _max: TrackerMaxAggregateOutputType | null
  }

  export type TrackerMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    trackerName: string | null
  }

  export type TrackerMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    trackerName: string | null
  }

  export type TrackerCountAggregateOutputType = {
    id: number
    campaignId: number
    trackerName: number
    dependencies: number
    defaultFileNames: number
    customFileNames: number
    _all: number
  }


  export type TrackerMinAggregateInputType = {
    id?: true
    campaignId?: true
    trackerName?: true
  }

  export type TrackerMaxAggregateInputType = {
    id?: true
    campaignId?: true
    trackerName?: true
  }

  export type TrackerCountAggregateInputType = {
    id?: true
    campaignId?: true
    trackerName?: true
    dependencies?: true
    defaultFileNames?: true
    customFileNames?: true
    _all?: true
  }

  export type TrackerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tracker to aggregate.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: TrackerOrderByWithRelationInput | TrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trackers
    **/
    _count?: true | TrackerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrackerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrackerMaxAggregateInputType
  }

  export type GetTrackerAggregateType<T extends TrackerAggregateArgs> = {
        [P in keyof T & keyof AggregateTracker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTracker[P]>
      : GetScalarType<T[P], AggregateTracker[P]>
  }




  export type TrackerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrackerWhereInput
    orderBy?: TrackerOrderByWithAggregationInput | TrackerOrderByWithAggregationInput[]
    by: TrackerScalarFieldEnum[] | TrackerScalarFieldEnum
    having?: TrackerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrackerCountAggregateInputType | true
    _min?: TrackerMinAggregateInputType
    _max?: TrackerMaxAggregateInputType
  }

  export type TrackerGroupByOutputType = {
    id: string
    campaignId: string
    trackerName: string
    dependencies: string[]
    defaultFileNames: string[]
    customFileNames: string[]
    _count: TrackerCountAggregateOutputType | null
    _min: TrackerMinAggregateOutputType | null
    _max: TrackerMaxAggregateOutputType | null
  }

  type GetTrackerGroupByPayload<T extends TrackerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrackerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrackerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrackerGroupByOutputType[P]>
            : GetScalarType<T[P], TrackerGroupByOutputType[P]>
        }
      >
    >


  export type TrackerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    trackerName?: boolean
    dependencies?: boolean
    defaultFileNames?: boolean
    customFileNames?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    evaluations?: boolean | Tracker$evaluationsArgs<ExtArgs>
    _count?: boolean | TrackerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tracker"]>

  export type TrackerSelectScalar = {
    id?: boolean
    campaignId?: boolean
    trackerName?: boolean
    dependencies?: boolean
    defaultFileNames?: boolean
    customFileNames?: boolean
  }

  export type TrackerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    evaluations?: boolean | Tracker$evaluationsArgs<ExtArgs>
    _count?: boolean | TrackerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $TrackerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tracker"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      evaluations: Prisma.$EvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      trackerName: string
      dependencies: string[]
      defaultFileNames: string[]
      customFileNames: string[]
    }, ExtArgs["result"]["tracker"]>
    composites: {}
  }


  type TrackerGetPayload<S extends boolean | null | undefined | TrackerDefaultArgs> = $Result.GetResult<Prisma.$TrackerPayload, S>

  type TrackerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrackerFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: TrackerCountAggregateInputType | true
    }

  export interface TrackerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tracker'], meta: { name: 'Tracker' } }
    /**
     * Find zero or one Tracker that matches the filter.
     * @param {TrackerFindUniqueArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TrackerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TrackerFindUniqueArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tracker that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TrackerFindUniqueOrThrowArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TrackerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrackerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tracker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerFindFirstArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TrackerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TrackerFindFirstArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tracker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerFindFirstOrThrowArgs} args - Arguments to find a Tracker
     * @example
     * // Get one Tracker
     * const tracker = await prisma.tracker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TrackerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TrackerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Trackers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trackers
     * const trackers = await prisma.tracker.findMany()
     * 
     * // Get first 10 Trackers
     * const trackers = await prisma.tracker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trackerWithIdOnly = await prisma.tracker.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TrackerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrackerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tracker.
     * @param {TrackerCreateArgs} args - Arguments to create a Tracker.
     * @example
     * // Create one Tracker
     * const Tracker = await prisma.tracker.create({
     *   data: {
     *     // ... data to create a Tracker
     *   }
     * })
     * 
    **/
    create<T extends TrackerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TrackerCreateArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Trackers.
     *     @param {TrackerCreateManyArgs} args - Arguments to create many Trackers.
     *     @example
     *     // Create many Trackers
     *     const tracker = await prisma.tracker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TrackerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrackerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tracker.
     * @param {TrackerDeleteArgs} args - Arguments to delete one Tracker.
     * @example
     * // Delete one Tracker
     * const Tracker = await prisma.tracker.delete({
     *   where: {
     *     // ... filter to delete one Tracker
     *   }
     * })
     * 
    **/
    delete<T extends TrackerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TrackerDeleteArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tracker.
     * @param {TrackerUpdateArgs} args - Arguments to update one Tracker.
     * @example
     * // Update one Tracker
     * const tracker = await prisma.tracker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TrackerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TrackerUpdateArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Trackers.
     * @param {TrackerDeleteManyArgs} args - Arguments to filter Trackers to delete.
     * @example
     * // Delete a few Trackers
     * const { count } = await prisma.tracker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TrackerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TrackerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trackers
     * const tracker = await prisma.tracker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TrackerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TrackerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tracker.
     * @param {TrackerUpsertArgs} args - Arguments to update or create a Tracker.
     * @example
     * // Update or create a Tracker
     * const tracker = await prisma.tracker.upsert({
     *   create: {
     *     // ... data to create a Tracker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tracker we want to update
     *   }
     * })
    **/
    upsert<T extends TrackerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TrackerUpsertArgs<ExtArgs>>
    ): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Trackers that matches the filter.
     * @param {TrackerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tracker = await prisma.tracker.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: TrackerFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tracker.
     * @param {TrackerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tracker = await prisma.tracker.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: TrackerAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Trackers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerCountArgs} args - Arguments to filter Trackers to count.
     * @example
     * // Count the number of Trackers
     * const count = await prisma.tracker.count({
     *   where: {
     *     // ... the filter for the Trackers we want to count
     *   }
     * })
    **/
    count<T extends TrackerCountArgs>(
      args?: Subset<T, TrackerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrackerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrackerAggregateArgs>(args: Subset<T, TrackerAggregateArgs>): Prisma.PrismaPromise<GetTrackerAggregateType<T>>

    /**
     * Group by Tracker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrackerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrackerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrackerGroupByArgs['orderBy'] }
        : { orderBy?: TrackerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrackerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrackerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tracker model
   */
  readonly fields: TrackerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tracker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrackerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    evaluations<T extends Tracker$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Tracker$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tracker model
   */ 
  interface TrackerFieldRefs {
    readonly id: FieldRef<"Tracker", 'String'>
    readonly campaignId: FieldRef<"Tracker", 'String'>
    readonly trackerName: FieldRef<"Tracker", 'String'>
    readonly dependencies: FieldRef<"Tracker", 'String[]'>
    readonly defaultFileNames: FieldRef<"Tracker", 'String[]'>
    readonly customFileNames: FieldRef<"Tracker", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * Tracker findUnique
   */
  export type TrackerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * Filter, which Tracker to fetch.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker findUniqueOrThrow
   */
  export type TrackerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * Filter, which Tracker to fetch.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker findFirst
   */
  export type TrackerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * Filter, which Tracker to fetch.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: TrackerOrderByWithRelationInput | TrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trackers.
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trackers.
     */
    distinct?: TrackerScalarFieldEnum | TrackerScalarFieldEnum[]
  }


  /**
   * Tracker findFirstOrThrow
   */
  export type TrackerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * Filter, which Tracker to fetch.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: TrackerOrderByWithRelationInput | TrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trackers.
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trackers.
     */
    distinct?: TrackerScalarFieldEnum | TrackerScalarFieldEnum[]
  }


  /**
   * Tracker findMany
   */
  export type TrackerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * Filter, which Trackers to fetch.
     */
    where?: TrackerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trackers to fetch.
     */
    orderBy?: TrackerOrderByWithRelationInput | TrackerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trackers.
     */
    cursor?: TrackerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trackers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trackers.
     */
    skip?: number
    distinct?: TrackerScalarFieldEnum | TrackerScalarFieldEnum[]
  }


  /**
   * Tracker create
   */
  export type TrackerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * The data needed to create a Tracker.
     */
    data: XOR<TrackerCreateInput, TrackerUncheckedCreateInput>
  }


  /**
   * Tracker createMany
   */
  export type TrackerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trackers.
     */
    data: TrackerCreateManyInput | TrackerCreateManyInput[]
  }


  /**
   * Tracker update
   */
  export type TrackerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * The data needed to update a Tracker.
     */
    data: XOR<TrackerUpdateInput, TrackerUncheckedUpdateInput>
    /**
     * Choose, which Tracker to update.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker updateMany
   */
  export type TrackerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trackers.
     */
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyInput>
    /**
     * Filter which Trackers to update
     */
    where?: TrackerWhereInput
  }


  /**
   * Tracker upsert
   */
  export type TrackerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * The filter to search for the Tracker to update in case it exists.
     */
    where: TrackerWhereUniqueInput
    /**
     * In case the Tracker found by the `where` argument doesn't exist, create a new Tracker with this data.
     */
    create: XOR<TrackerCreateInput, TrackerUncheckedCreateInput>
    /**
     * In case the Tracker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrackerUpdateInput, TrackerUncheckedUpdateInput>
  }


  /**
   * Tracker delete
   */
  export type TrackerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    /**
     * Filter which Tracker to delete.
     */
    where: TrackerWhereUniqueInput
  }


  /**
   * Tracker deleteMany
   */
  export type TrackerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trackers to delete
     */
    where?: TrackerWhereInput
  }


  /**
   * Tracker findRaw
   */
  export type TrackerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Tracker aggregateRaw
   */
  export type TrackerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Tracker.evaluations
   */
  export type Tracker$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Tracker without action
   */
  export type TrackerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
  }



  /**
   * Model Evaluation
   */

  export type AggregateEvaluation = {
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  export type EvaluationAvgAggregateOutputType = {
    maxPerPage: number | null
  }

  export type EvaluationSumAggregateOutputType = {
    maxPerPage: number | null
  }

  export type EvaluationMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    accountId: string | null
    teamAccountId: string | null
    githubTargetId: string | null
    type: string | null
    query: string | null
    maxPerPage: number | null
    dataId: string | null
    status: string | null
    error: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    trackerId: string | null
    userId: string | null
  }

  export type EvaluationMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    accountId: string | null
    teamAccountId: string | null
    githubTargetId: string | null
    type: string | null
    query: string | null
    maxPerPage: number | null
    dataId: string | null
    status: string | null
    error: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    trackerId: string | null
    userId: string | null
  }

  export type EvaluationCountAggregateOutputType = {
    id: number
    campaignId: number
    accountId: number
    teamAccountId: number
    githubTargetId: number
    type: number
    params: number
    query: number
    queryVariables: number
    paginators: number
    maxPerPage: number
    dataId: number
    result: number
    status: number
    error: number
    parentId: number
    createdAt: number
    updatedAt: number
    trackerId: number
    userId: number
    _all: number
  }


  export type EvaluationAvgAggregateInputType = {
    maxPerPage?: true
  }

  export type EvaluationSumAggregateInputType = {
    maxPerPage?: true
  }

  export type EvaluationMinAggregateInputType = {
    id?: true
    campaignId?: true
    accountId?: true
    teamAccountId?: true
    githubTargetId?: true
    type?: true
    query?: true
    maxPerPage?: true
    dataId?: true
    status?: true
    error?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    trackerId?: true
    userId?: true
  }

  export type EvaluationMaxAggregateInputType = {
    id?: true
    campaignId?: true
    accountId?: true
    teamAccountId?: true
    githubTargetId?: true
    type?: true
    query?: true
    maxPerPage?: true
    dataId?: true
    status?: true
    error?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    trackerId?: true
    userId?: true
  }

  export type EvaluationCountAggregateInputType = {
    id?: true
    campaignId?: true
    accountId?: true
    teamAccountId?: true
    githubTargetId?: true
    type?: true
    params?: true
    query?: true
    queryVariables?: true
    paginators?: true
    maxPerPage?: true
    dataId?: true
    result?: true
    status?: true
    error?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    trackerId?: true
    userId?: true
    _all?: true
  }

  export type EvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluation to aggregate.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluations
    **/
    _count?: true | EvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluationMaxAggregateInputType
  }

  export type GetEvaluationAggregateType<T extends EvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluation[P]>
      : GetScalarType<T[P], AggregateEvaluation[P]>
  }




  export type EvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithAggregationInput | EvaluationOrderByWithAggregationInput[]
    by: EvaluationScalarFieldEnum[] | EvaluationScalarFieldEnum
    having?: EvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluationCountAggregateInputType | true
    _avg?: EvaluationAvgAggregateInputType
    _sum?: EvaluationSumAggregateInputType
    _min?: EvaluationMinAggregateInputType
    _max?: EvaluationMaxAggregateInputType
  }

  export type EvaluationGroupByOutputType = {
    id: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params: JsonValue | null
    query: string | null
    queryVariables: JsonValue | null
    paginators: JsonValue | null
    maxPerPage: number
    dataId: string | null
    result: JsonValue | null
    status: string
    error: string | null
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    trackerId: string | null
    userId: string | null
    _count: EvaluationCountAggregateOutputType | null
    _avg: EvaluationAvgAggregateOutputType | null
    _sum: EvaluationSumAggregateOutputType | null
    _min: EvaluationMinAggregateOutputType | null
    _max: EvaluationMaxAggregateOutputType | null
  }

  type GetEvaluationGroupByPayload<T extends EvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluationGroupByOutputType[P]>
        }
      >
    >


  export type EvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    accountId?: boolean
    teamAccountId?: boolean
    githubTargetId?: boolean
    type?: boolean
    params?: boolean
    query?: boolean
    queryVariables?: boolean
    paginators?: boolean
    maxPerPage?: boolean
    dataId?: boolean
    result?: boolean
    status?: boolean
    error?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trackerId?: boolean
    userId?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    githubTarget?: boolean | GithubTargetDefaultArgs<ExtArgs>
    parent?: boolean | Evaluation$parentArgs<ExtArgs>
    children?: boolean | Evaluation$childrenArgs<ExtArgs>
    tracker?: boolean | Evaluation$trackerArgs<ExtArgs>
    User?: boolean | Evaluation$UserArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evaluation"]>

  export type EvaluationSelectScalar = {
    id?: boolean
    campaignId?: boolean
    accountId?: boolean
    teamAccountId?: boolean
    githubTargetId?: boolean
    type?: boolean
    params?: boolean
    query?: boolean
    queryVariables?: boolean
    paginators?: boolean
    maxPerPage?: boolean
    dataId?: boolean
    result?: boolean
    status?: boolean
    error?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    trackerId?: boolean
    userId?: boolean
  }

  export type EvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
    teamAccount?: boolean | TeamAccountDefaultArgs<ExtArgs>
    githubTarget?: boolean | GithubTargetDefaultArgs<ExtArgs>
    parent?: boolean | Evaluation$parentArgs<ExtArgs>
    children?: boolean | Evaluation$childrenArgs<ExtArgs>
    tracker?: boolean | Evaluation$trackerArgs<ExtArgs>
    User?: boolean | Evaluation$UserArgs<ExtArgs>
    _count?: boolean | EvaluationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $EvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluation"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
      teamAccount: Prisma.$TeamAccountPayload<ExtArgs>
      githubTarget: Prisma.$GithubTargetPayload<ExtArgs>
      parent: Prisma.$EvaluationPayload<ExtArgs> | null
      children: Prisma.$EvaluationPayload<ExtArgs>[]
      tracker: Prisma.$TrackerPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      accountId: string
      teamAccountId: string
      githubTargetId: string
      type: string
      params: Prisma.JsonValue | null
      query: string | null
      queryVariables: Prisma.JsonValue | null
      paginators: Prisma.JsonValue | null
      maxPerPage: number
      dataId: string | null
      result: Prisma.JsonValue | null
      status: string
      error: string | null
      parentId: string | null
      createdAt: Date
      updatedAt: Date
      trackerId: string | null
      userId: string | null
    }, ExtArgs["result"]["evaluation"]>
    composites: {}
  }


  type EvaluationGetPayload<S extends boolean | null | undefined | EvaluationDefaultArgs> = $Result.GetResult<Prisma.$EvaluationPayload, S>

  type EvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EvaluationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EvaluationCountAggregateInputType | true
    }

  export interface EvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluation'], meta: { name: 'Evaluation' } }
    /**
     * Find zero or one Evaluation that matches the filter.
     * @param {EvaluationFindUniqueArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EvaluationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationFindUniqueArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Evaluation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EvaluationFindUniqueOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EvaluationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EvaluationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Evaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindFirstOrThrowArgs} args - Arguments to find a Evaluation
     * @example
     * // Get one Evaluation
     * const evaluation = await prisma.evaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EvaluationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluations
     * const evaluations = await prisma.evaluation.findMany()
     * 
     * // Get first 10 Evaluations
     * const evaluations = await prisma.evaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluationWithIdOnly = await prisma.evaluation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EvaluationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Evaluation.
     * @param {EvaluationCreateArgs} args - Arguments to create a Evaluation.
     * @example
     * // Create one Evaluation
     * const Evaluation = await prisma.evaluation.create({
     *   data: {
     *     // ... data to create a Evaluation
     *   }
     * })
     * 
    **/
    create<T extends EvaluationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationCreateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Evaluations.
     *     @param {EvaluationCreateManyArgs} args - Arguments to create many Evaluations.
     *     @example
     *     // Create many Evaluations
     *     const evaluation = await prisma.evaluation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EvaluationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Evaluation.
     * @param {EvaluationDeleteArgs} args - Arguments to delete one Evaluation.
     * @example
     * // Delete one Evaluation
     * const Evaluation = await prisma.evaluation.delete({
     *   where: {
     *     // ... filter to delete one Evaluation
     *   }
     * })
     * 
    **/
    delete<T extends EvaluationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationDeleteArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Evaluation.
     * @param {EvaluationUpdateArgs} args - Arguments to update one Evaluation.
     * @example
     * // Update one Evaluation
     * const evaluation = await prisma.evaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EvaluationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Evaluations.
     * @param {EvaluationDeleteManyArgs} args - Arguments to filter Evaluations to delete.
     * @example
     * // Delete a few Evaluations
     * const { count } = await prisma.evaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EvaluationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EvaluationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluations
     * const evaluation = await prisma.evaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EvaluationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evaluation.
     * @param {EvaluationUpsertArgs} args - Arguments to update or create a Evaluation.
     * @example
     * // Update or create a Evaluation
     * const evaluation = await prisma.evaluation.upsert({
     *   create: {
     *     // ... data to create a Evaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluation we want to update
     *   }
     * })
    **/
    upsert<T extends EvaluationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EvaluationUpsertArgs<ExtArgs>>
    ): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Evaluations that matches the filter.
     * @param {EvaluationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const evaluation = await prisma.evaluation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: EvaluationFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Evaluation.
     * @param {EvaluationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const evaluation = await prisma.evaluation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: EvaluationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Evaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationCountArgs} args - Arguments to filter Evaluations to count.
     * @example
     * // Count the number of Evaluations
     * const count = await prisma.evaluation.count({
     *   where: {
     *     // ... the filter for the Evaluations we want to count
     *   }
     * })
    **/
    count<T extends EvaluationCountArgs>(
      args?: Subset<T, EvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluationAggregateArgs>(args: Subset<T, EvaluationAggregateArgs>): Prisma.PrismaPromise<GetEvaluationAggregateType<T>>

    /**
     * Group by Evaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluationGroupByArgs['orderBy'] }
        : { orderBy?: EvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluation model
   */
  readonly fields: EvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    teamAccount<T extends TeamAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamAccountDefaultArgs<ExtArgs>>): Prisma__TeamAccountClient<$Result.GetResult<Prisma.$TeamAccountPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    githubTarget<T extends GithubTargetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GithubTargetDefaultArgs<ExtArgs>>): Prisma__GithubTargetClient<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parent<T extends Evaluation$parentArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$parentArgs<ExtArgs>>): Prisma__EvaluationClient<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    children<T extends Evaluation$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluationPayload<ExtArgs>, T, 'findMany'> | Null>;

    tracker<T extends Evaluation$trackerArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$trackerArgs<ExtArgs>>): Prisma__TrackerClient<$Result.GetResult<Prisma.$TrackerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    User<T extends Evaluation$UserArgs<ExtArgs> = {}>(args?: Subset<T, Evaluation$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Evaluation model
   */ 
  interface EvaluationFieldRefs {
    readonly id: FieldRef<"Evaluation", 'String'>
    readonly campaignId: FieldRef<"Evaluation", 'String'>
    readonly accountId: FieldRef<"Evaluation", 'String'>
    readonly teamAccountId: FieldRef<"Evaluation", 'String'>
    readonly githubTargetId: FieldRef<"Evaluation", 'String'>
    readonly type: FieldRef<"Evaluation", 'String'>
    readonly params: FieldRef<"Evaluation", 'Json'>
    readonly query: FieldRef<"Evaluation", 'String'>
    readonly queryVariables: FieldRef<"Evaluation", 'Json'>
    readonly paginators: FieldRef<"Evaluation", 'Json'>
    readonly maxPerPage: FieldRef<"Evaluation", 'Int'>
    readonly dataId: FieldRef<"Evaluation", 'String'>
    readonly result: FieldRef<"Evaluation", 'Json'>
    readonly status: FieldRef<"Evaluation", 'String'>
    readonly error: FieldRef<"Evaluation", 'String'>
    readonly parentId: FieldRef<"Evaluation", 'String'>
    readonly createdAt: FieldRef<"Evaluation", 'DateTime'>
    readonly updatedAt: FieldRef<"Evaluation", 'DateTime'>
    readonly trackerId: FieldRef<"Evaluation", 'String'>
    readonly userId: FieldRef<"Evaluation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Evaluation findUnique
   */
  export type EvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation findUniqueOrThrow
   */
  export type EvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation findFirst
   */
  export type EvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation findFirstOrThrow
   */
  export type EvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluation to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluations.
     */
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation findMany
   */
  export type EvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter, which Evaluations to fetch.
     */
    where?: EvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluations to fetch.
     */
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluations.
     */
    cursor?: EvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluations.
     */
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation create
   */
  export type EvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluation.
     */
    data: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
  }


  /**
   * Evaluation createMany
   */
  export type EvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluations.
     */
    data: EvaluationCreateManyInput | EvaluationCreateManyInput[]
  }


  /**
   * Evaluation update
   */
  export type EvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluation.
     */
    data: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
    /**
     * Choose, which Evaluation to update.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation updateMany
   */
  export type EvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluations.
     */
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyInput>
    /**
     * Filter which Evaluations to update
     */
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation upsert
   */
  export type EvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluation to update in case it exists.
     */
    where: EvaluationWhereUniqueInput
    /**
     * In case the Evaluation found by the `where` argument doesn't exist, create a new Evaluation with this data.
     */
    create: XOR<EvaluationCreateInput, EvaluationUncheckedCreateInput>
    /**
     * In case the Evaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluationUpdateInput, EvaluationUncheckedUpdateInput>
  }


  /**
   * Evaluation delete
   */
  export type EvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    /**
     * Filter which Evaluation to delete.
     */
    where: EvaluationWhereUniqueInput
  }


  /**
   * Evaluation deleteMany
   */
  export type EvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluations to delete
     */
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation findRaw
   */
  export type EvaluationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Evaluation aggregateRaw
   */
  export type EvaluationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Evaluation.parent
   */
  export type Evaluation$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
  }


  /**
   * Evaluation.children
   */
  export type Evaluation$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
    where?: EvaluationWhereInput
    orderBy?: EvaluationOrderByWithRelationInput | EvaluationOrderByWithRelationInput[]
    cursor?: EvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluationScalarFieldEnum | EvaluationScalarFieldEnum[]
  }


  /**
   * Evaluation.tracker
   */
  export type Evaluation$trackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tracker
     */
    select?: TrackerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TrackerInclude<ExtArgs> | null
    where?: TrackerWhereInput
  }


  /**
   * Evaluation.User
   */
  export type Evaluation$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Evaluation without action
   */
  export type EvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluation
     */
    select?: EvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EvaluationInclude<ExtArgs> | null
  }



  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    body: string | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    body: string | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    targetIds: number
    type: number
    params: number
    title: number
    body: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    body?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    body?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    targetIds?: true
    type?: true
    params?: true
    title?: true
    body?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    targetIds: string[]
    type: string
    params: JsonValue | null
    title: string
    body: string
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetIds?: boolean
    type?: boolean
    params?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
    githubTargets?: boolean | Report$githubTargetsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    targetIds?: boolean
    type?: boolean
    params?: boolean
    title?: boolean
    body?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    githubTargets?: boolean | Report$githubTargetsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      githubTargets: Prisma.$GithubTargetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetIds: string[]
      type: string
      params: Prisma.JsonValue | null
      title: string
      body: string
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * @param {ReportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const report = await prisma.report.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ReportFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Report.
     * @param {ReportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const report = await prisma.report.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ReportAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    githubTargets<T extends Report$githubTargetsArgs<ExtArgs> = {}>(args?: Subset<T, Report$githubTargetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubTargetPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly targetIds: FieldRef<"Report", 'String[]'>
    readonly type: FieldRef<"Report", 'String'>
    readonly params: FieldRef<"Report", 'Json'>
    readonly title: FieldRef<"Report", 'String'>
    readonly body: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report findRaw
   */
  export type ReportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Report aggregateRaw
   */
  export type ReportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Report.githubTargets
   */
  export type Report$githubTargetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubTarget
     */
    select?: GithubTargetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubTargetInclude<ExtArgs> | null
    where?: GithubTargetWhereInput
    orderBy?: GithubTargetOrderByWithRelationInput | GithubTargetOrderByWithRelationInput[]
    cursor?: GithubTargetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GithubTargetScalarFieldEnum | GithubTargetScalarFieldEnum[]
  }


  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
  }



  /**
   * Model GithubRepository
   */

  export type AggregateGithubRepository = {
    _count: GithubRepositoryCountAggregateOutputType | null
    _min: GithubRepositoryMinAggregateOutputType | null
    _max: GithubRepositoryMaxAggregateOutputType | null
  }

  export type GithubRepositoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    owner: string | null
    url: string | null
  }

  export type GithubRepositoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    owner: string | null
    url: string | null
  }

  export type GithubRepositoryCountAggregateOutputType = {
    id: number
    name: number
    owner: number
    url: number
    _all: number
  }


  export type GithubRepositoryMinAggregateInputType = {
    id?: true
    name?: true
    owner?: true
    url?: true
  }

  export type GithubRepositoryMaxAggregateInputType = {
    id?: true
    name?: true
    owner?: true
    url?: true
  }

  export type GithubRepositoryCountAggregateInputType = {
    id?: true
    name?: true
    owner?: true
    url?: true
    _all?: true
  }

  export type GithubRepositoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GithubRepository to aggregate.
     */
    where?: GithubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubRepositories to fetch.
     */
    orderBy?: GithubRepositoryOrderByWithRelationInput | GithubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GithubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubRepositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GithubRepositories
    **/
    _count?: true | GithubRepositoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GithubRepositoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GithubRepositoryMaxAggregateInputType
  }

  export type GetGithubRepositoryAggregateType<T extends GithubRepositoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGithubRepository]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGithubRepository[P]>
      : GetScalarType<T[P], AggregateGithubRepository[P]>
  }




  export type GithubRepositoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GithubRepositoryWhereInput
    orderBy?: GithubRepositoryOrderByWithAggregationInput | GithubRepositoryOrderByWithAggregationInput[]
    by: GithubRepositoryScalarFieldEnum[] | GithubRepositoryScalarFieldEnum
    having?: GithubRepositoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GithubRepositoryCountAggregateInputType | true
    _min?: GithubRepositoryMinAggregateInputType
    _max?: GithubRepositoryMaxAggregateInputType
  }

  export type GithubRepositoryGroupByOutputType = {
    id: string
    name: string
    owner: string
    url: string
    _count: GithubRepositoryCountAggregateOutputType | null
    _min: GithubRepositoryMinAggregateOutputType | null
    _max: GithubRepositoryMaxAggregateOutputType | null
  }

  type GetGithubRepositoryGroupByPayload<T extends GithubRepositoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GithubRepositoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GithubRepositoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GithubRepositoryGroupByOutputType[P]>
            : GetScalarType<T[P], GithubRepositoryGroupByOutputType[P]>
        }
      >
    >


  export type GithubRepositorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    owner?: boolean
    url?: boolean
    branches?: boolean | GithubRepositoryBranchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["githubRepository"]>

  export type GithubRepositorySelectScalar = {
    id?: boolean
    name?: boolean
    owner?: boolean
    url?: boolean
  }

  export type GithubRepositoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}


  export type $GithubRepositoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GithubRepository"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      owner: string
      url: string
    }, ExtArgs["result"]["githubRepository"]>
    composites: {
      branches: Prisma.$GithubRepositoryBranchPayload[]
    }
  }


  type GithubRepositoryGetPayload<S extends boolean | null | undefined | GithubRepositoryDefaultArgs> = $Result.GetResult<Prisma.$GithubRepositoryPayload, S>

  type GithubRepositoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GithubRepositoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: GithubRepositoryCountAggregateInputType | true
    }

  export interface GithubRepositoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GithubRepository'], meta: { name: 'GithubRepository' } }
    /**
     * Find zero or one GithubRepository that matches the filter.
     * @param {GithubRepositoryFindUniqueArgs} args - Arguments to find a GithubRepository
     * @example
     * // Get one GithubRepository
     * const githubRepository = await prisma.githubRepository.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends GithubRepositoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, GithubRepositoryFindUniqueArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one GithubRepository that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {GithubRepositoryFindUniqueOrThrowArgs} args - Arguments to find a GithubRepository
     * @example
     * // Get one GithubRepository
     * const githubRepository = await prisma.githubRepository.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends GithubRepositoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubRepositoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first GithubRepository that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryFindFirstArgs} args - Arguments to find a GithubRepository
     * @example
     * // Get one GithubRepository
     * const githubRepository = await prisma.githubRepository.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends GithubRepositoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubRepositoryFindFirstArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first GithubRepository that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryFindFirstOrThrowArgs} args - Arguments to find a GithubRepository
     * @example
     * // Get one GithubRepository
     * const githubRepository = await prisma.githubRepository.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends GithubRepositoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubRepositoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more GithubRepositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GithubRepositories
     * const githubRepositories = await prisma.githubRepository.findMany()
     * 
     * // Get first 10 GithubRepositories
     * const githubRepositories = await prisma.githubRepository.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const githubRepositoryWithIdOnly = await prisma.githubRepository.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends GithubRepositoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubRepositoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a GithubRepository.
     * @param {GithubRepositoryCreateArgs} args - Arguments to create a GithubRepository.
     * @example
     * // Create one GithubRepository
     * const GithubRepository = await prisma.githubRepository.create({
     *   data: {
     *     // ... data to create a GithubRepository
     *   }
     * })
     * 
    **/
    create<T extends GithubRepositoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, GithubRepositoryCreateArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many GithubRepositories.
     *     @param {GithubRepositoryCreateManyArgs} args - Arguments to create many GithubRepositories.
     *     @example
     *     // Create many GithubRepositories
     *     const githubRepository = await prisma.githubRepository.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends GithubRepositoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubRepositoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a GithubRepository.
     * @param {GithubRepositoryDeleteArgs} args - Arguments to delete one GithubRepository.
     * @example
     * // Delete one GithubRepository
     * const GithubRepository = await prisma.githubRepository.delete({
     *   where: {
     *     // ... filter to delete one GithubRepository
     *   }
     * })
     * 
    **/
    delete<T extends GithubRepositoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, GithubRepositoryDeleteArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one GithubRepository.
     * @param {GithubRepositoryUpdateArgs} args - Arguments to update one GithubRepository.
     * @example
     * // Update one GithubRepository
     * const githubRepository = await prisma.githubRepository.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends GithubRepositoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, GithubRepositoryUpdateArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more GithubRepositories.
     * @param {GithubRepositoryDeleteManyArgs} args - Arguments to filter GithubRepositories to delete.
     * @example
     * // Delete a few GithubRepositories
     * const { count } = await prisma.githubRepository.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends GithubRepositoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, GithubRepositoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GithubRepositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GithubRepositories
     * const githubRepository = await prisma.githubRepository.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends GithubRepositoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, GithubRepositoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one GithubRepository.
     * @param {GithubRepositoryUpsertArgs} args - Arguments to update or create a GithubRepository.
     * @example
     * // Update or create a GithubRepository
     * const githubRepository = await prisma.githubRepository.upsert({
     *   create: {
     *     // ... data to create a GithubRepository
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GithubRepository we want to update
     *   }
     * })
    **/
    upsert<T extends GithubRepositoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, GithubRepositoryUpsertArgs<ExtArgs>>
    ): Prisma__GithubRepositoryClient<$Result.GetResult<Prisma.$GithubRepositoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more GithubRepositories that matches the filter.
     * @param {GithubRepositoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const githubRepository = await prisma.githubRepository.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: GithubRepositoryFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a GithubRepository.
     * @param {GithubRepositoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const githubRepository = await prisma.githubRepository.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: GithubRepositoryAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of GithubRepositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryCountArgs} args - Arguments to filter GithubRepositories to count.
     * @example
     * // Count the number of GithubRepositories
     * const count = await prisma.githubRepository.count({
     *   where: {
     *     // ... the filter for the GithubRepositories we want to count
     *   }
     * })
    **/
    count<T extends GithubRepositoryCountArgs>(
      args?: Subset<T, GithubRepositoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GithubRepositoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GithubRepository.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GithubRepositoryAggregateArgs>(args: Subset<T, GithubRepositoryAggregateArgs>): Prisma.PrismaPromise<GetGithubRepositoryAggregateType<T>>

    /**
     * Group by GithubRepository.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GithubRepositoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GithubRepositoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GithubRepositoryGroupByArgs['orderBy'] }
        : { orderBy?: GithubRepositoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GithubRepositoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGithubRepositoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GithubRepository model
   */
  readonly fields: GithubRepositoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GithubRepository.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GithubRepositoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the GithubRepository model
   */ 
  interface GithubRepositoryFieldRefs {
    readonly id: FieldRef<"GithubRepository", 'String'>
    readonly name: FieldRef<"GithubRepository", 'String'>
    readonly owner: FieldRef<"GithubRepository", 'String'>
    readonly url: FieldRef<"GithubRepository", 'String'>
  }
    

  // Custom InputTypes

  /**
   * GithubRepository findUnique
   */
  export type GithubRepositoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GithubRepository to fetch.
     */
    where: GithubRepositoryWhereUniqueInput
  }


  /**
   * GithubRepository findUniqueOrThrow
   */
  export type GithubRepositoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GithubRepository to fetch.
     */
    where: GithubRepositoryWhereUniqueInput
  }


  /**
   * GithubRepository findFirst
   */
  export type GithubRepositoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GithubRepository to fetch.
     */
    where?: GithubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubRepositories to fetch.
     */
    orderBy?: GithubRepositoryOrderByWithRelationInput | GithubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GithubRepositories.
     */
    cursor?: GithubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubRepositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GithubRepositories.
     */
    distinct?: GithubRepositoryScalarFieldEnum | GithubRepositoryScalarFieldEnum[]
  }


  /**
   * GithubRepository findFirstOrThrow
   */
  export type GithubRepositoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GithubRepository to fetch.
     */
    where?: GithubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubRepositories to fetch.
     */
    orderBy?: GithubRepositoryOrderByWithRelationInput | GithubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GithubRepositories.
     */
    cursor?: GithubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubRepositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GithubRepositories.
     */
    distinct?: GithubRepositoryScalarFieldEnum | GithubRepositoryScalarFieldEnum[]
  }


  /**
   * GithubRepository findMany
   */
  export type GithubRepositoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GithubRepositories to fetch.
     */
    where?: GithubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GithubRepositories to fetch.
     */
    orderBy?: GithubRepositoryOrderByWithRelationInput | GithubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GithubRepositories.
     */
    cursor?: GithubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GithubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GithubRepositories.
     */
    skip?: number
    distinct?: GithubRepositoryScalarFieldEnum | GithubRepositoryScalarFieldEnum[]
  }


  /**
   * GithubRepository create
   */
  export type GithubRepositoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GithubRepository.
     */
    data: XOR<GithubRepositoryCreateInput, GithubRepositoryUncheckedCreateInput>
  }


  /**
   * GithubRepository createMany
   */
  export type GithubRepositoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GithubRepositories.
     */
    data: GithubRepositoryCreateManyInput | GithubRepositoryCreateManyInput[]
  }


  /**
   * GithubRepository update
   */
  export type GithubRepositoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GithubRepository.
     */
    data: XOR<GithubRepositoryUpdateInput, GithubRepositoryUncheckedUpdateInput>
    /**
     * Choose, which GithubRepository to update.
     */
    where: GithubRepositoryWhereUniqueInput
  }


  /**
   * GithubRepository updateMany
   */
  export type GithubRepositoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GithubRepositories.
     */
    data: XOR<GithubRepositoryUpdateManyMutationInput, GithubRepositoryUncheckedUpdateManyInput>
    /**
     * Filter which GithubRepositories to update
     */
    where?: GithubRepositoryWhereInput
  }


  /**
   * GithubRepository upsert
   */
  export type GithubRepositoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GithubRepository to update in case it exists.
     */
    where: GithubRepositoryWhereUniqueInput
    /**
     * In case the GithubRepository found by the `where` argument doesn't exist, create a new GithubRepository with this data.
     */
    create: XOR<GithubRepositoryCreateInput, GithubRepositoryUncheckedCreateInput>
    /**
     * In case the GithubRepository was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GithubRepositoryUpdateInput, GithubRepositoryUncheckedUpdateInput>
  }


  /**
   * GithubRepository delete
   */
  export type GithubRepositoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
    /**
     * Filter which GithubRepository to delete.
     */
    where: GithubRepositoryWhereUniqueInput
  }


  /**
   * GithubRepository deleteMany
   */
  export type GithubRepositoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GithubRepositories to delete
     */
    where?: GithubRepositoryWhereInput
  }


  /**
   * GithubRepository findRaw
   */
  export type GithubRepositoryFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * GithubRepository aggregateRaw
   */
  export type GithubRepositoryAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * GithubRepository without action
   */
  export type GithubRepositoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GithubRepository
     */
    select?: GithubRepositorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: GithubRepositoryInclude<ExtArgs> | null
  }



  /**
   * Model ZapierEvent
   */

  export type AggregateZapierEvent = {
    _count: ZapierEventCountAggregateOutputType | null
    _min: ZapierEventMinAggregateOutputType | null
    _max: ZapierEventMaxAggregateOutputType | null
  }

  export type ZapierEventMinAggregateOutputType = {
    id: string | null
    uuid: string | null
    createdAt: Date | null
    text: string | null
  }

  export type ZapierEventMaxAggregateOutputType = {
    id: string | null
    uuid: string | null
    createdAt: Date | null
    text: string | null
  }

  export type ZapierEventCountAggregateOutputType = {
    id: number
    uuid: number
    createdAt: number
    text: number
    _all: number
  }


  export type ZapierEventMinAggregateInputType = {
    id?: true
    uuid?: true
    createdAt?: true
    text?: true
  }

  export type ZapierEventMaxAggregateInputType = {
    id?: true
    uuid?: true
    createdAt?: true
    text?: true
  }

  export type ZapierEventCountAggregateInputType = {
    id?: true
    uuid?: true
    createdAt?: true
    text?: true
    _all?: true
  }

  export type ZapierEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZapierEvent to aggregate.
     */
    where?: ZapierEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZapierEvents to fetch.
     */
    orderBy?: ZapierEventOrderByWithRelationInput | ZapierEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZapierEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZapierEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZapierEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZapierEvents
    **/
    _count?: true | ZapierEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZapierEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZapierEventMaxAggregateInputType
  }

  export type GetZapierEventAggregateType<T extends ZapierEventAggregateArgs> = {
        [P in keyof T & keyof AggregateZapierEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZapierEvent[P]>
      : GetScalarType<T[P], AggregateZapierEvent[P]>
  }




  export type ZapierEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZapierEventWhereInput
    orderBy?: ZapierEventOrderByWithAggregationInput | ZapierEventOrderByWithAggregationInput[]
    by: ZapierEventScalarFieldEnum[] | ZapierEventScalarFieldEnum
    having?: ZapierEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZapierEventCountAggregateInputType | true
    _min?: ZapierEventMinAggregateInputType
    _max?: ZapierEventMaxAggregateInputType
  }

  export type ZapierEventGroupByOutputType = {
    id: string
    uuid: string
    createdAt: Date
    text: string | null
    _count: ZapierEventCountAggregateOutputType | null
    _min: ZapierEventMinAggregateOutputType | null
    _max: ZapierEventMaxAggregateOutputType | null
  }

  type GetZapierEventGroupByPayload<T extends ZapierEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZapierEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZapierEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZapierEventGroupByOutputType[P]>
            : GetScalarType<T[P], ZapierEventGroupByOutputType[P]>
        }
      >
    >


  export type ZapierEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    createdAt?: boolean
    text?: boolean
  }, ExtArgs["result"]["zapierEvent"]>

  export type ZapierEventSelectScalar = {
    id?: boolean
    uuid?: boolean
    createdAt?: boolean
    text?: boolean
  }


  export type $ZapierEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZapierEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uuid: string
      createdAt: Date
      text: string | null
    }, ExtArgs["result"]["zapierEvent"]>
    composites: {}
  }


  type ZapierEventGetPayload<S extends boolean | null | undefined | ZapierEventDefaultArgs> = $Result.GetResult<Prisma.$ZapierEventPayload, S>

  type ZapierEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZapierEventFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ZapierEventCountAggregateInputType | true
    }

  export interface ZapierEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZapierEvent'], meta: { name: 'ZapierEvent' } }
    /**
     * Find zero or one ZapierEvent that matches the filter.
     * @param {ZapierEventFindUniqueArgs} args - Arguments to find a ZapierEvent
     * @example
     * // Get one ZapierEvent
     * const zapierEvent = await prisma.zapierEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ZapierEventFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ZapierEventFindUniqueArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ZapierEvent that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ZapierEventFindUniqueOrThrowArgs} args - Arguments to find a ZapierEvent
     * @example
     * // Get one ZapierEvent
     * const zapierEvent = await prisma.zapierEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ZapierEventFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZapierEventFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ZapierEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventFindFirstArgs} args - Arguments to find a ZapierEvent
     * @example
     * // Get one ZapierEvent
     * const zapierEvent = await prisma.zapierEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ZapierEventFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ZapierEventFindFirstArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ZapierEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventFindFirstOrThrowArgs} args - Arguments to find a ZapierEvent
     * @example
     * // Get one ZapierEvent
     * const zapierEvent = await prisma.zapierEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ZapierEventFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ZapierEventFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ZapierEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZapierEvents
     * const zapierEvents = await prisma.zapierEvent.findMany()
     * 
     * // Get first 10 ZapierEvents
     * const zapierEvents = await prisma.zapierEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zapierEventWithIdOnly = await prisma.zapierEvent.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ZapierEventFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZapierEventFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ZapierEvent.
     * @param {ZapierEventCreateArgs} args - Arguments to create a ZapierEvent.
     * @example
     * // Create one ZapierEvent
     * const ZapierEvent = await prisma.zapierEvent.create({
     *   data: {
     *     // ... data to create a ZapierEvent
     *   }
     * })
     * 
    **/
    create<T extends ZapierEventCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ZapierEventCreateArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ZapierEvents.
     *     @param {ZapierEventCreateManyArgs} args - Arguments to create many ZapierEvents.
     *     @example
     *     // Create many ZapierEvents
     *     const zapierEvent = await prisma.zapierEvent.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ZapierEventCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZapierEventCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ZapierEvent.
     * @param {ZapierEventDeleteArgs} args - Arguments to delete one ZapierEvent.
     * @example
     * // Delete one ZapierEvent
     * const ZapierEvent = await prisma.zapierEvent.delete({
     *   where: {
     *     // ... filter to delete one ZapierEvent
     *   }
     * })
     * 
    **/
    delete<T extends ZapierEventDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ZapierEventDeleteArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ZapierEvent.
     * @param {ZapierEventUpdateArgs} args - Arguments to update one ZapierEvent.
     * @example
     * // Update one ZapierEvent
     * const zapierEvent = await prisma.zapierEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ZapierEventUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ZapierEventUpdateArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ZapierEvents.
     * @param {ZapierEventDeleteManyArgs} args - Arguments to filter ZapierEvents to delete.
     * @example
     * // Delete a few ZapierEvents
     * const { count } = await prisma.zapierEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ZapierEventDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ZapierEventDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZapierEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZapierEvents
     * const zapierEvent = await prisma.zapierEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ZapierEventUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ZapierEventUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ZapierEvent.
     * @param {ZapierEventUpsertArgs} args - Arguments to update or create a ZapierEvent.
     * @example
     * // Update or create a ZapierEvent
     * const zapierEvent = await prisma.zapierEvent.upsert({
     *   create: {
     *     // ... data to create a ZapierEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZapierEvent we want to update
     *   }
     * })
    **/
    upsert<T extends ZapierEventUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ZapierEventUpsertArgs<ExtArgs>>
    ): Prisma__ZapierEventClient<$Result.GetResult<Prisma.$ZapierEventPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more ZapierEvents that matches the filter.
     * @param {ZapierEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const zapierEvent = await prisma.zapierEvent.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ZapierEventFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ZapierEvent.
     * @param {ZapierEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const zapierEvent = await prisma.zapierEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ZapierEventAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of ZapierEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventCountArgs} args - Arguments to filter ZapierEvents to count.
     * @example
     * // Count the number of ZapierEvents
     * const count = await prisma.zapierEvent.count({
     *   where: {
     *     // ... the filter for the ZapierEvents we want to count
     *   }
     * })
    **/
    count<T extends ZapierEventCountArgs>(
      args?: Subset<T, ZapierEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZapierEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZapierEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZapierEventAggregateArgs>(args: Subset<T, ZapierEventAggregateArgs>): Prisma.PrismaPromise<GetZapierEventAggregateType<T>>

    /**
     * Group by ZapierEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZapierEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZapierEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZapierEventGroupByArgs['orderBy'] }
        : { orderBy?: ZapierEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZapierEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZapierEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZapierEvent model
   */
  readonly fields: ZapierEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZapierEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZapierEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ZapierEvent model
   */ 
  interface ZapierEventFieldRefs {
    readonly id: FieldRef<"ZapierEvent", 'String'>
    readonly uuid: FieldRef<"ZapierEvent", 'String'>
    readonly createdAt: FieldRef<"ZapierEvent", 'DateTime'>
    readonly text: FieldRef<"ZapierEvent", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ZapierEvent findUnique
   */
  export type ZapierEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * Filter, which ZapierEvent to fetch.
     */
    where: ZapierEventWhereUniqueInput
  }


  /**
   * ZapierEvent findUniqueOrThrow
   */
  export type ZapierEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * Filter, which ZapierEvent to fetch.
     */
    where: ZapierEventWhereUniqueInput
  }


  /**
   * ZapierEvent findFirst
   */
  export type ZapierEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * Filter, which ZapierEvent to fetch.
     */
    where?: ZapierEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZapierEvents to fetch.
     */
    orderBy?: ZapierEventOrderByWithRelationInput | ZapierEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZapierEvents.
     */
    cursor?: ZapierEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZapierEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZapierEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZapierEvents.
     */
    distinct?: ZapierEventScalarFieldEnum | ZapierEventScalarFieldEnum[]
  }


  /**
   * ZapierEvent findFirstOrThrow
   */
  export type ZapierEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * Filter, which ZapierEvent to fetch.
     */
    where?: ZapierEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZapierEvents to fetch.
     */
    orderBy?: ZapierEventOrderByWithRelationInput | ZapierEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZapierEvents.
     */
    cursor?: ZapierEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZapierEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZapierEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZapierEvents.
     */
    distinct?: ZapierEventScalarFieldEnum | ZapierEventScalarFieldEnum[]
  }


  /**
   * ZapierEvent findMany
   */
  export type ZapierEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * Filter, which ZapierEvents to fetch.
     */
    where?: ZapierEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZapierEvents to fetch.
     */
    orderBy?: ZapierEventOrderByWithRelationInput | ZapierEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZapierEvents.
     */
    cursor?: ZapierEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZapierEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZapierEvents.
     */
    skip?: number
    distinct?: ZapierEventScalarFieldEnum | ZapierEventScalarFieldEnum[]
  }


  /**
   * ZapierEvent create
   */
  export type ZapierEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * The data needed to create a ZapierEvent.
     */
    data: XOR<ZapierEventCreateInput, ZapierEventUncheckedCreateInput>
  }


  /**
   * ZapierEvent createMany
   */
  export type ZapierEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZapierEvents.
     */
    data: ZapierEventCreateManyInput | ZapierEventCreateManyInput[]
  }


  /**
   * ZapierEvent update
   */
  export type ZapierEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * The data needed to update a ZapierEvent.
     */
    data: XOR<ZapierEventUpdateInput, ZapierEventUncheckedUpdateInput>
    /**
     * Choose, which ZapierEvent to update.
     */
    where: ZapierEventWhereUniqueInput
  }


  /**
   * ZapierEvent updateMany
   */
  export type ZapierEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZapierEvents.
     */
    data: XOR<ZapierEventUpdateManyMutationInput, ZapierEventUncheckedUpdateManyInput>
    /**
     * Filter which ZapierEvents to update
     */
    where?: ZapierEventWhereInput
  }


  /**
   * ZapierEvent upsert
   */
  export type ZapierEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * The filter to search for the ZapierEvent to update in case it exists.
     */
    where: ZapierEventWhereUniqueInput
    /**
     * In case the ZapierEvent found by the `where` argument doesn't exist, create a new ZapierEvent with this data.
     */
    create: XOR<ZapierEventCreateInput, ZapierEventUncheckedCreateInput>
    /**
     * In case the ZapierEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZapierEventUpdateInput, ZapierEventUncheckedUpdateInput>
  }


  /**
   * ZapierEvent delete
   */
  export type ZapierEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
    /**
     * Filter which ZapierEvent to delete.
     */
    where: ZapierEventWhereUniqueInput
  }


  /**
   * ZapierEvent deleteMany
   */
  export type ZapierEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZapierEvents to delete
     */
    where?: ZapierEventWhereInput
  }


  /**
   * ZapierEvent findRaw
   */
  export type ZapierEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ZapierEvent aggregateRaw
   */
  export type ZapierEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * ZapierEvent without action
   */
  export type ZapierEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZapierEvent
     */
    select?: ZapierEventSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    refresh_token_expires_in: 'refresh_token_expires_in',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const WhitelistScalarFieldEnum: {
    id: 'id',
    githubName: 'githubName',
    quantity: 'quantity',
    createdAt: 'createdAt',
    teamAccountId: 'teamAccountId'
  };

  export type WhitelistScalarFieldEnum = (typeof WhitelistScalarFieldEnum)[keyof typeof WhitelistScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    role: 'role',
    email: 'email',
    emailVerified: 'emailVerified',
    contactEmail: 'contactEmail',
    image: 'image',
    firstName: 'firstName',
    lastName: 'lastName',
    lastSeen: 'lastSeen',
    ownedTeamAccountIds: 'ownedTeamAccountIds',
    teamAccountIds: 'teamAccountIds'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const OneTimeCodesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    expires: 'expires',
    type: 'type',
    email: 'email',
    createdAt: 'createdAt',
    teamAccountId: 'teamAccountId'
  };

  export type OneTimeCodesScalarFieldEnum = (typeof OneTimeCodesScalarFieldEnum)[keyof typeof OneTimeCodesScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    featureList: 'featureList'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const TeamAccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    aliasEmail: 'aliasEmail',
    verifiedEmailAddresses: 'verifiedEmailAddresses',
    teamAccountUserIds: 'teamAccountUserIds',
    ownerIds: 'ownerIds',
    campaignIds: 'campaignIds',
    subscriptionId: 'subscriptionId'
  };

  export type TeamAccountScalarFieldEnum = (typeof TeamAccountScalarFieldEnum)[keyof typeof TeamAccountScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    email: 'email',
    contactEmails: 'contactEmails',
    teamAccountId: 'teamAccountId',
    emailIds: 'emailIds',
    emailThreadIds: 'emailThreadIds',
    targetIds: 'targetIds'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const EmailScalarFieldEnum: {
    id: 'id',
    to: 'to',
    bcc: 'bcc',
    cc: 'cc',
    from: 'from',
    subject: 'subject',
    text: 'text',
    sentByUser: 'sentByUser',
    sentAt: 'sentAt',
    contactIds: 'contactIds',
    teamAccountId: 'teamAccountId',
    messageId: 'messageId',
    emailThreadId: 'emailThreadId'
  };

  export type EmailScalarFieldEnum = (typeof EmailScalarFieldEnum)[keyof typeof EmailScalarFieldEnum]


  export const EmailThreadScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contactIds: 'contactIds',
    teamAccountId: 'teamAccountId',
    targetIds: 'targetIds'
  };

  export type EmailThreadScalarFieldEnum = (typeof EmailThreadScalarFieldEnum)[keyof typeof EmailThreadScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    teamAccountId: 'teamAccountId',
    subject: 'subject',
    text: 'text',
    teamAccountUserId: 'teamAccountUserId',
    githubTargetId: 'githubTargetId'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const TargetScoutScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    dependencyName: 'dependencyName',
    dependencyFilename: 'dependencyFilename'
  };

  export type TargetScoutScalarFieldEnum = (typeof TargetScoutScalarFieldEnum)[keyof typeof TargetScoutScalarFieldEnum]


  export const CustomFieldScalarFieldEnum: {
    id: 'id',
    key: 'key',
    bgColor: 'bgColor',
    type: 'type',
    targetType: 'targetType',
    campaignId: 'campaignId'
  };

  export type CustomFieldScalarFieldEnum = (typeof CustomFieldScalarFieldEnum)[keyof typeof CustomFieldScalarFieldEnum]


  export const CustomFieldValueScalarFieldEnum: {
    id: 'id',
    value_string: 'value_string',
    value_number: 'value_number',
    value_date: 'value_date',
    value_boolean: 'value_boolean',
    customFieldId: 'customFieldId',
    targetContactId: 'targetContactId'
  };

  export type CustomFieldValueScalarFieldEnum = (typeof CustomFieldValueScalarFieldEnum)[keyof typeof CustomFieldValueScalarFieldEnum]


  export const TargetContactScalarFieldEnum: {
    id: 'id',
    githubTargetId: 'githubTargetId',
    industry: 'industry',
    projectOwner: 'projectOwner',
    projectName: 'projectName',
    type: 'type',
    location: 'location',
    teamAccountId: 'teamAccountId',
    status: 'status',
    campaignIds: 'campaignIds'
  };

  export type TargetContactScalarFieldEnum = (typeof TargetContactScalarFieldEnum)[keyof typeof TargetContactScalarFieldEnum]


  export const GithubTargetScalarFieldEnum: {
    id: 'id',
    githubGraphqlId: 'githubGraphqlId',
    campaignIds: 'campaignIds',
    reportIds: 'reportIds',
    type: 'type',
    metadata: 'metadata',
    displayName: 'displayName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contactIds: 'contactIds',
    emailThreadIds: 'emailThreadIds'
  };

  export type GithubTargetScalarFieldEnum = (typeof GithubTargetScalarFieldEnum)[keyof typeof GithubTargetScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    targetIds: 'targetIds',
    createdAt: 'createdAt',
    dependenciesInfo: 'dependenciesInfo',
    teamAccountIds: 'teamAccountIds',
    targetScoutIds: 'targetScoutIds',
    budget: 'budget',
    lightMode: 'lightMode',
    startDate: 'startDate',
    endDate: 'endDate',
    targetContactIds: 'targetContactIds',
    archived: 'archived',
    archivedAt: 'archivedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const TrackerScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    trackerName: 'trackerName',
    dependencies: 'dependencies',
    defaultFileNames: 'defaultFileNames',
    customFileNames: 'customFileNames'
  };

  export type TrackerScalarFieldEnum = (typeof TrackerScalarFieldEnum)[keyof typeof TrackerScalarFieldEnum]


  export const EvaluationScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    accountId: 'accountId',
    teamAccountId: 'teamAccountId',
    githubTargetId: 'githubTargetId',
    type: 'type',
    params: 'params',
    query: 'query',
    queryVariables: 'queryVariables',
    paginators: 'paginators',
    maxPerPage: 'maxPerPage',
    dataId: 'dataId',
    result: 'result',
    status: 'status',
    error: 'error',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    trackerId: 'trackerId',
    userId: 'userId'
  };

  export type EvaluationScalarFieldEnum = (typeof EvaluationScalarFieldEnum)[keyof typeof EvaluationScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    targetIds: 'targetIds',
    type: 'type',
    params: 'params',
    title: 'title',
    body: 'body',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const GithubRepositoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    owner: 'owner',
    url: 'url'
  };

  export type GithubRepositoryScalarFieldEnum = (typeof GithubRepositoryScalarFieldEnum)[keyof typeof GithubRepositoryScalarFieldEnum]


  export const ZapierEventScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    createdAt: 'createdAt',
    text: 'text'
  };

  export type ZapierEventScalarFieldEnum = (typeof ZapierEventScalarFieldEnum)[keyof typeof ZapierEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    Evaluation?: EvaluationListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user?: UserOrderByWithRelationInput
    Evaluation?: EvaluationOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    Evaluation?: EvaluationListRelationFilter
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableWithAggregatesFilter<"Account"> | number | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type WhitelistWhereInput = {
    AND?: WhitelistWhereInput | WhitelistWhereInput[]
    OR?: WhitelistWhereInput[]
    NOT?: WhitelistWhereInput | WhitelistWhereInput[]
    id?: StringFilter<"Whitelist"> | string
    githubName?: StringFilter<"Whitelist"> | string
    quantity?: IntFilter<"Whitelist"> | number
    createdAt?: DateTimeNullableFilter<"Whitelist"> | Date | string | null
    teamAccountId?: StringNullableFilter<"Whitelist"> | string | null
    teamAccount?: XOR<TeamAccountNullableRelationFilter, TeamAccountWhereInput> | null
  }

  export type WhitelistOrderByWithRelationInput = {
    id?: SortOrder
    githubName?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
    teamAccount?: TeamAccountOrderByWithRelationInput
  }

  export type WhitelistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    githubName?: string
    teamAccountId?: string
    AND?: WhitelistWhereInput | WhitelistWhereInput[]
    OR?: WhitelistWhereInput[]
    NOT?: WhitelistWhereInput | WhitelistWhereInput[]
    quantity?: IntFilter<"Whitelist"> | number
    createdAt?: DateTimeNullableFilter<"Whitelist"> | Date | string | null
    teamAccount?: XOR<TeamAccountNullableRelationFilter, TeamAccountWhereInput> | null
  }, "id" | "githubName" | "teamAccountId">

  export type WhitelistOrderByWithAggregationInput = {
    id?: SortOrder
    githubName?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
    _count?: WhitelistCountOrderByAggregateInput
    _avg?: WhitelistAvgOrderByAggregateInput
    _max?: WhitelistMaxOrderByAggregateInput
    _min?: WhitelistMinOrderByAggregateInput
    _sum?: WhitelistSumOrderByAggregateInput
  }

  export type WhitelistScalarWhereWithAggregatesInput = {
    AND?: WhitelistScalarWhereWithAggregatesInput | WhitelistScalarWhereWithAggregatesInput[]
    OR?: WhitelistScalarWhereWithAggregatesInput[]
    NOT?: WhitelistScalarWhereWithAggregatesInput | WhitelistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Whitelist"> | string
    githubName?: StringWithAggregatesFilter<"Whitelist"> | string
    quantity?: IntWithAggregatesFilter<"Whitelist"> | number
    createdAt?: DateTimeNullableWithAggregatesFilter<"Whitelist"> | Date | string | null
    teamAccountId?: StringNullableWithAggregatesFilter<"Whitelist"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    contactEmail?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    lastSeen?: DateTimeFilter<"User"> | Date | string
    ownedTeamAccountIds?: StringNullableListFilter<"User">
    teamAccountIds?: StringNullableListFilter<"User">
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    ownedTeamAccounts?: TeamAccountListRelationFilter
    teamAccounts?: TeamAccountListRelationFilter
    notes?: NoteListRelationFilter
    evaluation?: EvaluationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    contactEmail?: SortOrder
    image?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lastSeen?: SortOrder
    ownedTeamAccountIds?: SortOrder
    teamAccountIds?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    ownedTeamAccounts?: TeamAccountOrderByRelationAggregateInput
    teamAccounts?: TeamAccountOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    evaluation?: EvaluationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    contactEmail?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    lastSeen?: DateTimeFilter<"User"> | Date | string
    ownedTeamAccountIds?: StringNullableListFilter<"User">
    teamAccountIds?: StringNullableListFilter<"User">
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    ownedTeamAccounts?: TeamAccountListRelationFilter
    teamAccounts?: TeamAccountListRelationFilter
    notes?: NoteListRelationFilter
    evaluation?: EvaluationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    contactEmail?: SortOrder
    image?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lastSeen?: SortOrder
    ownedTeamAccountIds?: SortOrder
    teamAccountIds?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    lastSeen?: DateTimeWithAggregatesFilter<"User"> | Date | string
    ownedTeamAccountIds?: StringNullableListFilter<"User">
    teamAccountIds?: StringNullableListFilter<"User">
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    identifier?: string
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "identifier" | "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type OneTimeCodesWhereInput = {
    AND?: OneTimeCodesWhereInput | OneTimeCodesWhereInput[]
    OR?: OneTimeCodesWhereInput[]
    NOT?: OneTimeCodesWhereInput | OneTimeCodesWhereInput[]
    id?: StringFilter<"OneTimeCodes"> | string
    code?: StringFilter<"OneTimeCodes"> | string
    expires?: DateTimeFilter<"OneTimeCodes"> | Date | string
    type?: StringFilter<"OneTimeCodes"> | string
    email?: StringFilter<"OneTimeCodes"> | string
    createdAt?: DateTimeFilter<"OneTimeCodes"> | Date | string
    teamAccountId?: StringFilter<"OneTimeCodes"> | string
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
  }

  export type OneTimeCodesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
    teamAccount?: TeamAccountOrderByWithRelationInput
  }

  export type OneTimeCodesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: OneTimeCodesWhereInput | OneTimeCodesWhereInput[]
    OR?: OneTimeCodesWhereInput[]
    NOT?: OneTimeCodesWhereInput | OneTimeCodesWhereInput[]
    expires?: DateTimeFilter<"OneTimeCodes"> | Date | string
    type?: StringFilter<"OneTimeCodes"> | string
    email?: StringFilter<"OneTimeCodes"> | string
    createdAt?: DateTimeFilter<"OneTimeCodes"> | Date | string
    teamAccountId?: StringFilter<"OneTimeCodes"> | string
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
  }, "id" | "code">

  export type OneTimeCodesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
    _count?: OneTimeCodesCountOrderByAggregateInput
    _max?: OneTimeCodesMaxOrderByAggregateInput
    _min?: OneTimeCodesMinOrderByAggregateInput
  }

  export type OneTimeCodesScalarWhereWithAggregatesInput = {
    AND?: OneTimeCodesScalarWhereWithAggregatesInput | OneTimeCodesScalarWhereWithAggregatesInput[]
    OR?: OneTimeCodesScalarWhereWithAggregatesInput[]
    NOT?: OneTimeCodesScalarWhereWithAggregatesInput | OneTimeCodesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OneTimeCodes"> | string
    code?: StringWithAggregatesFilter<"OneTimeCodes"> | string
    expires?: DateTimeWithAggregatesFilter<"OneTimeCodes"> | Date | string
    type?: StringWithAggregatesFilter<"OneTimeCodes"> | string
    email?: StringWithAggregatesFilter<"OneTimeCodes"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OneTimeCodes"> | Date | string
    teamAccountId?: StringWithAggregatesFilter<"OneTimeCodes"> | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    featureList?: StringNullableListFilter<"Subscription">
    teamAccounts?: TeamAccountListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    featureList?: SortOrder
    teamAccounts?: TeamAccountOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    featureList?: StringNullableListFilter<"Subscription">
    teamAccounts?: TeamAccountListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    featureList?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    featureList?: StringNullableListFilter<"Subscription">
  }

  export type TeamAccountWhereInput = {
    AND?: TeamAccountWhereInput | TeamAccountWhereInput[]
    OR?: TeamAccountWhereInput[]
    NOT?: TeamAccountWhereInput | TeamAccountWhereInput[]
    id?: StringFilter<"TeamAccount"> | string
    name?: StringFilter<"TeamAccount"> | string
    aliasEmail?: StringFilter<"TeamAccount"> | string
    verifiedEmailAddresses?: StringNullableListFilter<"TeamAccount">
    teamAccountUserIds?: StringNullableListFilter<"TeamAccount">
    ownerIds?: StringNullableListFilter<"TeamAccount">
    campaignIds?: StringNullableListFilter<"TeamAccount">
    subscriptionId?: StringNullableFilter<"TeamAccount"> | string | null
    inviteCodes?: OneTimeCodesListRelationFilter
    teamAccountUsers?: UserListRelationFilter
    contacts?: ContactListRelationFilter
    emails?: EmailListRelationFilter
    owners?: UserListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    campaigns?: CampaignListRelationFilter
    notes?: NoteListRelationFilter
    targetContact?: TargetContactListRelationFilter
    evaluation?: EvaluationListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    whitelist?: XOR<WhitelistNullableRelationFilter, WhitelistWhereInput> | null
  }

  export type TeamAccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    aliasEmail?: SortOrder
    verifiedEmailAddresses?: SortOrder
    teamAccountUserIds?: SortOrder
    ownerIds?: SortOrder
    campaignIds?: SortOrder
    subscriptionId?: SortOrder
    inviteCodes?: OneTimeCodesOrderByRelationAggregateInput
    teamAccountUsers?: UserOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    emails?: EmailOrderByRelationAggregateInput
    owners?: UserOrderByRelationAggregateInput
    emailThreads?: EmailThreadOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    targetContact?: TargetContactOrderByRelationAggregateInput
    evaluation?: EvaluationOrderByRelationAggregateInput
    subscription?: SubscriptionOrderByWithRelationInput
    whitelist?: WhitelistOrderByWithRelationInput
  }

  export type TeamAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    aliasEmail?: string
    AND?: TeamAccountWhereInput | TeamAccountWhereInput[]
    OR?: TeamAccountWhereInput[]
    NOT?: TeamAccountWhereInput | TeamAccountWhereInput[]
    verifiedEmailAddresses?: StringNullableListFilter<"TeamAccount">
    teamAccountUserIds?: StringNullableListFilter<"TeamAccount">
    ownerIds?: StringNullableListFilter<"TeamAccount">
    campaignIds?: StringNullableListFilter<"TeamAccount">
    subscriptionId?: StringNullableFilter<"TeamAccount"> | string | null
    inviteCodes?: OneTimeCodesListRelationFilter
    teamAccountUsers?: UserListRelationFilter
    contacts?: ContactListRelationFilter
    emails?: EmailListRelationFilter
    owners?: UserListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    campaigns?: CampaignListRelationFilter
    notes?: NoteListRelationFilter
    targetContact?: TargetContactListRelationFilter
    evaluation?: EvaluationListRelationFilter
    subscription?: XOR<SubscriptionNullableRelationFilter, SubscriptionWhereInput> | null
    whitelist?: XOR<WhitelistNullableRelationFilter, WhitelistWhereInput> | null
  }, "id" | "name" | "aliasEmail">

  export type TeamAccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    aliasEmail?: SortOrder
    verifiedEmailAddresses?: SortOrder
    teamAccountUserIds?: SortOrder
    ownerIds?: SortOrder
    campaignIds?: SortOrder
    subscriptionId?: SortOrder
    _count?: TeamAccountCountOrderByAggregateInput
    _max?: TeamAccountMaxOrderByAggregateInput
    _min?: TeamAccountMinOrderByAggregateInput
  }

  export type TeamAccountScalarWhereWithAggregatesInput = {
    AND?: TeamAccountScalarWhereWithAggregatesInput | TeamAccountScalarWhereWithAggregatesInput[]
    OR?: TeamAccountScalarWhereWithAggregatesInput[]
    NOT?: TeamAccountScalarWhereWithAggregatesInput | TeamAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamAccount"> | string
    name?: StringWithAggregatesFilter<"TeamAccount"> | string
    aliasEmail?: StringWithAggregatesFilter<"TeamAccount"> | string
    verifiedEmailAddresses?: StringNullableListFilter<"TeamAccount">
    teamAccountUserIds?: StringNullableListFilter<"TeamAccount">
    ownerIds?: StringNullableListFilter<"TeamAccount">
    campaignIds?: StringNullableListFilter<"TeamAccount">
    subscriptionId?: StringNullableWithAggregatesFilter<"TeamAccount"> | string | null
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    email?: StringNullableFilter<"Contact"> | string | null
    contactEmails?: StringNullableListFilter<"Contact">
    teamAccountId?: StringFilter<"Contact"> | string
    emailIds?: StringNullableListFilter<"Contact">
    emailThreadIds?: StringNullableListFilter<"Contact">
    targetIds?: StringNullableListFilter<"Contact">
    creatingTeamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    emails?: EmailListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    githubTargets?: GithubTargetListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    contactEmails?: SortOrder
    teamAccountId?: SortOrder
    emailIds?: SortOrder
    emailThreadIds?: SortOrder
    targetIds?: SortOrder
    creatingTeamAccount?: TeamAccountOrderByWithRelationInput
    emails?: EmailOrderByRelationAggregateInput
    emailThreads?: EmailThreadOrderByRelationAggregateInput
    githubTargets?: GithubTargetOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    name?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    email?: StringNullableFilter<"Contact"> | string | null
    contactEmails?: StringNullableListFilter<"Contact">
    teamAccountId?: StringFilter<"Contact"> | string
    emailIds?: StringNullableListFilter<"Contact">
    emailThreadIds?: StringNullableListFilter<"Contact">
    targetIds?: StringNullableListFilter<"Contact">
    creatingTeamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    emails?: EmailListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
    githubTargets?: GithubTargetListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    contactEmails?: SortOrder
    teamAccountId?: SortOrder
    emailIds?: SortOrder
    emailThreadIds?: SortOrder
    targetIds?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    name?: StringWithAggregatesFilter<"Contact"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    contactEmails?: StringNullableListFilter<"Contact">
    teamAccountId?: StringWithAggregatesFilter<"Contact"> | string
    emailIds?: StringNullableListFilter<"Contact">
    emailThreadIds?: StringNullableListFilter<"Contact">
    targetIds?: StringNullableListFilter<"Contact">
  }

  export type EmailWhereInput = {
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    id?: StringFilter<"Email"> | string
    to?: StringNullableListFilter<"Email">
    bcc?: StringNullableListFilter<"Email">
    cc?: StringNullableListFilter<"Email">
    from?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    text?: StringFilter<"Email"> | string
    sentByUser?: BoolFilter<"Email"> | boolean
    sentAt?: DateTimeFilter<"Email"> | Date | string
    contactIds?: StringNullableListFilter<"Email">
    teamAccountId?: StringFilter<"Email"> | string
    messageId?: StringFilter<"Email"> | string
    emailThreadId?: StringFilter<"Email"> | string
    contacts?: ContactListRelationFilter
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    emailThread?: XOR<EmailThreadRelationFilter, EmailThreadWhereInput>
  }

  export type EmailOrderByWithRelationInput = {
    id?: SortOrder
    to?: SortOrder
    bcc?: SortOrder
    cc?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    sentByUser?: SortOrder
    sentAt?: SortOrder
    contactIds?: SortOrder
    teamAccountId?: SortOrder
    messageId?: SortOrder
    emailThreadId?: SortOrder
    contacts?: ContactOrderByRelationAggregateInput
    teamAccount?: TeamAccountOrderByWithRelationInput
    emailThread?: EmailThreadOrderByWithRelationInput
  }

  export type EmailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailWhereInput | EmailWhereInput[]
    OR?: EmailWhereInput[]
    NOT?: EmailWhereInput | EmailWhereInput[]
    to?: StringNullableListFilter<"Email">
    bcc?: StringNullableListFilter<"Email">
    cc?: StringNullableListFilter<"Email">
    from?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    text?: StringFilter<"Email"> | string
    sentByUser?: BoolFilter<"Email"> | boolean
    sentAt?: DateTimeFilter<"Email"> | Date | string
    contactIds?: StringNullableListFilter<"Email">
    teamAccountId?: StringFilter<"Email"> | string
    messageId?: StringFilter<"Email"> | string
    emailThreadId?: StringFilter<"Email"> | string
    contacts?: ContactListRelationFilter
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    emailThread?: XOR<EmailThreadRelationFilter, EmailThreadWhereInput>
  }, "id">

  export type EmailOrderByWithAggregationInput = {
    id?: SortOrder
    to?: SortOrder
    bcc?: SortOrder
    cc?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    sentByUser?: SortOrder
    sentAt?: SortOrder
    contactIds?: SortOrder
    teamAccountId?: SortOrder
    messageId?: SortOrder
    emailThreadId?: SortOrder
    _count?: EmailCountOrderByAggregateInput
    _max?: EmailMaxOrderByAggregateInput
    _min?: EmailMinOrderByAggregateInput
  }

  export type EmailScalarWhereWithAggregatesInput = {
    AND?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    OR?: EmailScalarWhereWithAggregatesInput[]
    NOT?: EmailScalarWhereWithAggregatesInput | EmailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Email"> | string
    to?: StringNullableListFilter<"Email">
    bcc?: StringNullableListFilter<"Email">
    cc?: StringNullableListFilter<"Email">
    from?: StringWithAggregatesFilter<"Email"> | string
    subject?: StringWithAggregatesFilter<"Email"> | string
    text?: StringWithAggregatesFilter<"Email"> | string
    sentByUser?: BoolWithAggregatesFilter<"Email"> | boolean
    sentAt?: DateTimeWithAggregatesFilter<"Email"> | Date | string
    contactIds?: StringNullableListFilter<"Email">
    teamAccountId?: StringWithAggregatesFilter<"Email"> | string
    messageId?: StringWithAggregatesFilter<"Email"> | string
    emailThreadId?: StringWithAggregatesFilter<"Email"> | string
  }

  export type EmailThreadWhereInput = {
    AND?: EmailThreadWhereInput | EmailThreadWhereInput[]
    OR?: EmailThreadWhereInput[]
    NOT?: EmailThreadWhereInput | EmailThreadWhereInput[]
    id?: StringFilter<"EmailThread"> | string
    createdAt?: DateTimeFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeFilter<"EmailThread"> | Date | string
    contactIds?: StringNullableListFilter<"EmailThread">
    teamAccountId?: StringFilter<"EmailThread"> | string
    targetIds?: StringNullableListFilter<"EmailThread">
    emails?: EmailListRelationFilter
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    contacts?: ContactListRelationFilter
    githubTargets?: GithubTargetListRelationFilter
  }

  export type EmailThreadOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactIds?: SortOrder
    teamAccountId?: SortOrder
    targetIds?: SortOrder
    emails?: EmailOrderByRelationAggregateInput
    teamAccount?: TeamAccountOrderByWithRelationInput
    contacts?: ContactOrderByRelationAggregateInput
    githubTargets?: GithubTargetOrderByRelationAggregateInput
  }

  export type EmailThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailThreadWhereInput | EmailThreadWhereInput[]
    OR?: EmailThreadWhereInput[]
    NOT?: EmailThreadWhereInput | EmailThreadWhereInput[]
    createdAt?: DateTimeFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeFilter<"EmailThread"> | Date | string
    contactIds?: StringNullableListFilter<"EmailThread">
    teamAccountId?: StringFilter<"EmailThread"> | string
    targetIds?: StringNullableListFilter<"EmailThread">
    emails?: EmailListRelationFilter
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    contacts?: ContactListRelationFilter
    githubTargets?: GithubTargetListRelationFilter
  }, "id">

  export type EmailThreadOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactIds?: SortOrder
    teamAccountId?: SortOrder
    targetIds?: SortOrder
    _count?: EmailThreadCountOrderByAggregateInput
    _max?: EmailThreadMaxOrderByAggregateInput
    _min?: EmailThreadMinOrderByAggregateInput
  }

  export type EmailThreadScalarWhereWithAggregatesInput = {
    AND?: EmailThreadScalarWhereWithAggregatesInput | EmailThreadScalarWhereWithAggregatesInput[]
    OR?: EmailThreadScalarWhereWithAggregatesInput[]
    NOT?: EmailThreadScalarWhereWithAggregatesInput | EmailThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailThread"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailThread"> | Date | string
    contactIds?: StringNullableListFilter<"EmailThread">
    teamAccountId?: StringWithAggregatesFilter<"EmailThread"> | string
    targetIds?: StringNullableListFilter<"EmailThread">
  }

  export type NoteWhereInput = {
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    id?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    teamAccountId?: StringFilter<"Note"> | string
    subject?: StringFilter<"Note"> | string
    text?: StringFilter<"Note"> | string
    teamAccountUserId?: StringFilter<"Note"> | string
    githubTargetId?: StringNullableFilter<"Note"> | string | null
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    teamAccountUser?: XOR<UserRelationFilter, UserWhereInput>
    githubTarget?: XOR<GithubTargetNullableRelationFilter, GithubTargetWhereInput> | null
  }

  export type NoteOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    teamAccountUserId?: SortOrder
    githubTargetId?: SortOrder
    teamAccount?: TeamAccountOrderByWithRelationInput
    teamAccountUser?: UserOrderByWithRelationInput
    githubTarget?: GithubTargetOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NoteWhereInput | NoteWhereInput[]
    OR?: NoteWhereInput[]
    NOT?: NoteWhereInput | NoteWhereInput[]
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    teamAccountId?: StringFilter<"Note"> | string
    subject?: StringFilter<"Note"> | string
    text?: StringFilter<"Note"> | string
    teamAccountUserId?: StringFilter<"Note"> | string
    githubTargetId?: StringNullableFilter<"Note"> | string | null
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    teamAccountUser?: XOR<UserRelationFilter, UserWhereInput>
    githubTarget?: XOR<GithubTargetNullableRelationFilter, GithubTargetWhereInput> | null
  }, "id">

  export type NoteOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    teamAccountUserId?: SortOrder
    githubTargetId?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    OR?: NoteScalarWhereWithAggregatesInput[]
    NOT?: NoteScalarWhereWithAggregatesInput | NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Note"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Note"> | Date | string
    teamAccountId?: StringWithAggregatesFilter<"Note"> | string
    subject?: StringWithAggregatesFilter<"Note"> | string
    text?: StringWithAggregatesFilter<"Note"> | string
    teamAccountUserId?: StringWithAggregatesFilter<"Note"> | string
    githubTargetId?: StringNullableWithAggregatesFilter<"Note"> | string | null
  }

  export type TargetScoutWhereInput = {
    AND?: TargetScoutWhereInput | TargetScoutWhereInput[]
    OR?: TargetScoutWhereInput[]
    NOT?: TargetScoutWhereInput | TargetScoutWhereInput[]
    id?: StringFilter<"TargetScout"> | string
    campaignId?: StringFilter<"TargetScout"> | string
    dependencyName?: StringFilter<"TargetScout"> | string
    dependencyFilename?: StringFilter<"TargetScout"> | string
    filter?: XOR<TargetScoutFilterNullableCompositeFilter, TargetScoutFilterObjectEqualityInput> | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }

  export type TargetScoutOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    dependencyName?: SortOrder
    dependencyFilename?: SortOrder
    filter?: TargetScoutFilterOrderByInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type TargetScoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TargetScoutWhereInput | TargetScoutWhereInput[]
    OR?: TargetScoutWhereInput[]
    NOT?: TargetScoutWhereInput | TargetScoutWhereInput[]
    campaignId?: StringFilter<"TargetScout"> | string
    dependencyName?: StringFilter<"TargetScout"> | string
    dependencyFilename?: StringFilter<"TargetScout"> | string
    filter?: XOR<TargetScoutFilterNullableCompositeFilter, TargetScoutFilterObjectEqualityInput> | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
  }, "id">

  export type TargetScoutOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    dependencyName?: SortOrder
    dependencyFilename?: SortOrder
    _count?: TargetScoutCountOrderByAggregateInput
    _max?: TargetScoutMaxOrderByAggregateInput
    _min?: TargetScoutMinOrderByAggregateInput
  }

  export type TargetScoutScalarWhereWithAggregatesInput = {
    AND?: TargetScoutScalarWhereWithAggregatesInput | TargetScoutScalarWhereWithAggregatesInput[]
    OR?: TargetScoutScalarWhereWithAggregatesInput[]
    NOT?: TargetScoutScalarWhereWithAggregatesInput | TargetScoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TargetScout"> | string
    campaignId?: StringWithAggregatesFilter<"TargetScout"> | string
    dependencyName?: StringWithAggregatesFilter<"TargetScout"> | string
    dependencyFilename?: StringWithAggregatesFilter<"TargetScout"> | string
  }

  export type CustomFieldWhereInput = {
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    id?: StringFilter<"CustomField"> | string
    key?: StringFilter<"CustomField"> | string
    bgColor?: StringNullableFilter<"CustomField"> | string | null
    type?: StringFilter<"CustomField"> | string
    targetType?: StringFilter<"CustomField"> | string
    campaignId?: StringFilter<"CustomField"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    customFieldValues?: CustomFieldValueListRelationFilter
  }

  export type CustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    bgColor?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    campaignId?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    customFieldValues?: CustomFieldValueOrderByRelationAggregateInput
  }

  export type CustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomFieldWhereInput | CustomFieldWhereInput[]
    OR?: CustomFieldWhereInput[]
    NOT?: CustomFieldWhereInput | CustomFieldWhereInput[]
    key?: StringFilter<"CustomField"> | string
    bgColor?: StringNullableFilter<"CustomField"> | string | null
    type?: StringFilter<"CustomField"> | string
    targetType?: StringFilter<"CustomField"> | string
    campaignId?: StringFilter<"CustomField"> | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    customFieldValues?: CustomFieldValueListRelationFilter
  }, "id">

  export type CustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    bgColor?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    campaignId?: SortOrder
    _count?: CustomFieldCountOrderByAggregateInput
    _max?: CustomFieldMaxOrderByAggregateInput
    _min?: CustomFieldMinOrderByAggregateInput
  }

  export type CustomFieldScalarWhereWithAggregatesInput = {
    AND?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    OR?: CustomFieldScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldScalarWhereWithAggregatesInput | CustomFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomField"> | string
    key?: StringWithAggregatesFilter<"CustomField"> | string
    bgColor?: StringNullableWithAggregatesFilter<"CustomField"> | string | null
    type?: StringWithAggregatesFilter<"CustomField"> | string
    targetType?: StringWithAggregatesFilter<"CustomField"> | string
    campaignId?: StringWithAggregatesFilter<"CustomField"> | string
  }

  export type CustomFieldValueWhereInput = {
    AND?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    OR?: CustomFieldValueWhereInput[]
    NOT?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    id?: StringFilter<"CustomFieldValue"> | string
    value_string?: StringFilter<"CustomFieldValue"> | string
    value_number?: FloatFilter<"CustomFieldValue"> | number
    value_date?: DateTimeFilter<"CustomFieldValue"> | Date | string
    value_boolean?: BoolFilter<"CustomFieldValue"> | boolean
    customFieldId?: StringFilter<"CustomFieldValue"> | string
    targetContactId?: StringFilter<"CustomFieldValue"> | string
    customField?: XOR<CustomFieldNullableRelationFilter, CustomFieldWhereInput> | null
    targetContact?: XOR<TargetContactRelationFilter, TargetContactWhereInput>
  }

  export type CustomFieldValueOrderByWithRelationInput = {
    id?: SortOrder
    value_string?: SortOrder
    value_number?: SortOrder
    value_date?: SortOrder
    value_boolean?: SortOrder
    customFieldId?: SortOrder
    targetContactId?: SortOrder
    customField?: CustomFieldOrderByWithRelationInput
    targetContact?: TargetContactOrderByWithRelationInput
  }

  export type CustomFieldValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    customFieldId?: string
    AND?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    OR?: CustomFieldValueWhereInput[]
    NOT?: CustomFieldValueWhereInput | CustomFieldValueWhereInput[]
    value_string?: StringFilter<"CustomFieldValue"> | string
    value_number?: FloatFilter<"CustomFieldValue"> | number
    value_date?: DateTimeFilter<"CustomFieldValue"> | Date | string
    value_boolean?: BoolFilter<"CustomFieldValue"> | boolean
    targetContactId?: StringFilter<"CustomFieldValue"> | string
    customField?: XOR<CustomFieldNullableRelationFilter, CustomFieldWhereInput> | null
    targetContact?: XOR<TargetContactRelationFilter, TargetContactWhereInput>
  }, "id" | "customFieldId">

  export type CustomFieldValueOrderByWithAggregationInput = {
    id?: SortOrder
    value_string?: SortOrder
    value_number?: SortOrder
    value_date?: SortOrder
    value_boolean?: SortOrder
    customFieldId?: SortOrder
    targetContactId?: SortOrder
    _count?: CustomFieldValueCountOrderByAggregateInput
    _avg?: CustomFieldValueAvgOrderByAggregateInput
    _max?: CustomFieldValueMaxOrderByAggregateInput
    _min?: CustomFieldValueMinOrderByAggregateInput
    _sum?: CustomFieldValueSumOrderByAggregateInput
  }

  export type CustomFieldValueScalarWhereWithAggregatesInput = {
    AND?: CustomFieldValueScalarWhereWithAggregatesInput | CustomFieldValueScalarWhereWithAggregatesInput[]
    OR?: CustomFieldValueScalarWhereWithAggregatesInput[]
    NOT?: CustomFieldValueScalarWhereWithAggregatesInput | CustomFieldValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    value_string?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    value_number?: FloatWithAggregatesFilter<"CustomFieldValue"> | number
    value_date?: DateTimeWithAggregatesFilter<"CustomFieldValue"> | Date | string
    value_boolean?: BoolWithAggregatesFilter<"CustomFieldValue"> | boolean
    customFieldId?: StringWithAggregatesFilter<"CustomFieldValue"> | string
    targetContactId?: StringWithAggregatesFilter<"CustomFieldValue"> | string
  }

  export type TargetContactWhereInput = {
    AND?: TargetContactWhereInput | TargetContactWhereInput[]
    OR?: TargetContactWhereInput[]
    NOT?: TargetContactWhereInput | TargetContactWhereInput[]
    id?: StringFilter<"TargetContact"> | string
    githubTargetId?: StringNullableFilter<"TargetContact"> | string | null
    industry?: StringNullableFilter<"TargetContact"> | string | null
    projectOwner?: StringNullableFilter<"TargetContact"> | string | null
    projectName?: StringNullableFilter<"TargetContact"> | string | null
    type?: StringFilter<"TargetContact"> | string
    location?: StringNullableFilter<"TargetContact"> | string | null
    teamAccountId?: StringFilter<"TargetContact"> | string
    status?: StringNullableFilter<"TargetContact"> | string | null
    campaignIds?: StringNullableListFilter<"TargetContact">
    githubTarget?: XOR<GithubTargetNullableRelationFilter, GithubTargetWhereInput> | null
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    campaigns?: CampaignListRelationFilter
    customFieldValue?: CustomFieldValueListRelationFilter
  }

  export type TargetContactOrderByWithRelationInput = {
    id?: SortOrder
    githubTargetId?: SortOrder
    industry?: SortOrder
    projectOwner?: SortOrder
    projectName?: SortOrder
    type?: SortOrder
    location?: SortOrder
    teamAccountId?: SortOrder
    status?: SortOrder
    campaignIds?: SortOrder
    githubTarget?: GithubTargetOrderByWithRelationInput
    teamAccount?: TeamAccountOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
    customFieldValue?: CustomFieldValueOrderByRelationAggregateInput
  }

  export type TargetContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamAccountId?: string
    AND?: TargetContactWhereInput | TargetContactWhereInput[]
    OR?: TargetContactWhereInput[]
    NOT?: TargetContactWhereInput | TargetContactWhereInput[]
    githubTargetId?: StringNullableFilter<"TargetContact"> | string | null
    industry?: StringNullableFilter<"TargetContact"> | string | null
    projectOwner?: StringNullableFilter<"TargetContact"> | string | null
    projectName?: StringNullableFilter<"TargetContact"> | string | null
    type?: StringFilter<"TargetContact"> | string
    location?: StringNullableFilter<"TargetContact"> | string | null
    status?: StringNullableFilter<"TargetContact"> | string | null
    campaignIds?: StringNullableListFilter<"TargetContact">
    githubTarget?: XOR<GithubTargetNullableRelationFilter, GithubTargetWhereInput> | null
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    campaigns?: CampaignListRelationFilter
    customFieldValue?: CustomFieldValueListRelationFilter
  }, "id" | "teamAccountId">

  export type TargetContactOrderByWithAggregationInput = {
    id?: SortOrder
    githubTargetId?: SortOrder
    industry?: SortOrder
    projectOwner?: SortOrder
    projectName?: SortOrder
    type?: SortOrder
    location?: SortOrder
    teamAccountId?: SortOrder
    status?: SortOrder
    campaignIds?: SortOrder
    _count?: TargetContactCountOrderByAggregateInput
    _max?: TargetContactMaxOrderByAggregateInput
    _min?: TargetContactMinOrderByAggregateInput
  }

  export type TargetContactScalarWhereWithAggregatesInput = {
    AND?: TargetContactScalarWhereWithAggregatesInput | TargetContactScalarWhereWithAggregatesInput[]
    OR?: TargetContactScalarWhereWithAggregatesInput[]
    NOT?: TargetContactScalarWhereWithAggregatesInput | TargetContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TargetContact"> | string
    githubTargetId?: StringNullableWithAggregatesFilter<"TargetContact"> | string | null
    industry?: StringNullableWithAggregatesFilter<"TargetContact"> | string | null
    projectOwner?: StringNullableWithAggregatesFilter<"TargetContact"> | string | null
    projectName?: StringNullableWithAggregatesFilter<"TargetContact"> | string | null
    type?: StringWithAggregatesFilter<"TargetContact"> | string
    location?: StringNullableWithAggregatesFilter<"TargetContact"> | string | null
    teamAccountId?: StringWithAggregatesFilter<"TargetContact"> | string
    status?: StringNullableWithAggregatesFilter<"TargetContact"> | string | null
    campaignIds?: StringNullableListFilter<"TargetContact">
  }

  export type GithubTargetWhereInput = {
    AND?: GithubTargetWhereInput | GithubTargetWhereInput[]
    OR?: GithubTargetWhereInput[]
    NOT?: GithubTargetWhereInput | GithubTargetWhereInput[]
    id?: StringFilter<"GithubTarget"> | string
    githubGraphqlId?: StringFilter<"GithubTarget"> | string
    campaignIds?: StringNullableListFilter<"GithubTarget">
    reportIds?: StringNullableListFilter<"GithubTarget">
    type?: StringFilter<"GithubTarget"> | string
    metadata?: JsonFilter<"GithubTarget">
    displayName?: StringFilter<"GithubTarget"> | string
    createdAt?: DateTimeFilter<"GithubTarget"> | Date | string
    updatedAt?: DateTimeFilter<"GithubTarget"> | Date | string
    contactIds?: StringNullableListFilter<"GithubTarget">
    emailThreadIds?: StringNullableListFilter<"GithubTarget">
    campaigns?: CampaignListRelationFilter
    reports?: ReportListRelationFilter
    evaluations?: EvaluationListRelationFilter
    contacts?: ContactListRelationFilter
    targetContacts?: TargetContactListRelationFilter
    notes?: NoteListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
  }

  export type GithubTargetOrderByWithRelationInput = {
    id?: SortOrder
    githubGraphqlId?: SortOrder
    campaignIds?: SortOrder
    reportIds?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactIds?: SortOrder
    emailThreadIds?: SortOrder
    campaigns?: CampaignOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    evaluations?: EvaluationOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    targetContacts?: TargetContactOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    emailThreads?: EmailThreadOrderByRelationAggregateInput
  }

  export type GithubTargetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    githubGraphqlId?: string
    AND?: GithubTargetWhereInput | GithubTargetWhereInput[]
    OR?: GithubTargetWhereInput[]
    NOT?: GithubTargetWhereInput | GithubTargetWhereInput[]
    campaignIds?: StringNullableListFilter<"GithubTarget">
    reportIds?: StringNullableListFilter<"GithubTarget">
    type?: StringFilter<"GithubTarget"> | string
    metadata?: JsonFilter<"GithubTarget">
    displayName?: StringFilter<"GithubTarget"> | string
    createdAt?: DateTimeFilter<"GithubTarget"> | Date | string
    updatedAt?: DateTimeFilter<"GithubTarget"> | Date | string
    contactIds?: StringNullableListFilter<"GithubTarget">
    emailThreadIds?: StringNullableListFilter<"GithubTarget">
    campaigns?: CampaignListRelationFilter
    reports?: ReportListRelationFilter
    evaluations?: EvaluationListRelationFilter
    contacts?: ContactListRelationFilter
    targetContacts?: TargetContactListRelationFilter
    notes?: NoteListRelationFilter
    emailThreads?: EmailThreadListRelationFilter
  }, "id" | "githubGraphqlId">

  export type GithubTargetOrderByWithAggregationInput = {
    id?: SortOrder
    githubGraphqlId?: SortOrder
    campaignIds?: SortOrder
    reportIds?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactIds?: SortOrder
    emailThreadIds?: SortOrder
    _count?: GithubTargetCountOrderByAggregateInput
    _max?: GithubTargetMaxOrderByAggregateInput
    _min?: GithubTargetMinOrderByAggregateInput
  }

  export type GithubTargetScalarWhereWithAggregatesInput = {
    AND?: GithubTargetScalarWhereWithAggregatesInput | GithubTargetScalarWhereWithAggregatesInput[]
    OR?: GithubTargetScalarWhereWithAggregatesInput[]
    NOT?: GithubTargetScalarWhereWithAggregatesInput | GithubTargetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GithubTarget"> | string
    githubGraphqlId?: StringWithAggregatesFilter<"GithubTarget"> | string
    campaignIds?: StringNullableListFilter<"GithubTarget">
    reportIds?: StringNullableListFilter<"GithubTarget">
    type?: StringWithAggregatesFilter<"GithubTarget"> | string
    metadata?: JsonWithAggregatesFilter<"GithubTarget">
    displayName?: StringWithAggregatesFilter<"GithubTarget"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GithubTarget"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GithubTarget"> | Date | string
    contactIds?: StringNullableListFilter<"GithubTarget">
    emailThreadIds?: StringNullableListFilter<"GithubTarget">
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    targetIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    dependenciesInfo?: JsonNullableFilter<"Campaign">
    teamAccountIds?: StringNullableListFilter<"Campaign">
    targetScoutIds?: StringNullableListFilter<"Campaign">
    budget?: IntFilter<"Campaign"> | number
    lightMode?: BoolNullableFilter<"Campaign"> | boolean | null
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    targetContactIds?: StringNullableListFilter<"Campaign">
    archived?: BoolFilter<"Campaign"> | boolean
    archivedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    githubTargets?: GithubTargetListRelationFilter
    teamAccounts?: TeamAccountListRelationFilter
    targetScouts?: TargetScoutListRelationFilter
    trackers?: TrackerListRelationFilter
    evaluation?: EvaluationListRelationFilter
    targetContacts?: TargetContactListRelationFilter
    customFields?: CustomFieldListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    targetIds?: SortOrder
    createdAt?: SortOrder
    dependenciesInfo?: SortOrder
    teamAccountIds?: SortOrder
    targetScoutIds?: SortOrder
    budget?: SortOrder
    lightMode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    targetContactIds?: SortOrder
    archived?: SortOrder
    archivedAt?: SortOrder
    githubTargets?: GithubTargetOrderByRelationAggregateInput
    teamAccounts?: TeamAccountOrderByRelationAggregateInput
    targetScouts?: TargetScoutOrderByRelationAggregateInput
    trackers?: TrackerOrderByRelationAggregateInput
    evaluation?: EvaluationOrderByRelationAggregateInput
    targetContacts?: TargetContactOrderByRelationAggregateInput
    customFields?: CustomFieldOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    targetIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    dependenciesInfo?: JsonNullableFilter<"Campaign">
    teamAccountIds?: StringNullableListFilter<"Campaign">
    targetScoutIds?: StringNullableListFilter<"Campaign">
    budget?: IntFilter<"Campaign"> | number
    lightMode?: BoolNullableFilter<"Campaign"> | boolean | null
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    targetContactIds?: StringNullableListFilter<"Campaign">
    archived?: BoolFilter<"Campaign"> | boolean
    archivedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    githubTargets?: GithubTargetListRelationFilter
    teamAccounts?: TeamAccountListRelationFilter
    targetScouts?: TargetScoutListRelationFilter
    trackers?: TrackerListRelationFilter
    evaluation?: EvaluationListRelationFilter
    targetContacts?: TargetContactListRelationFilter
    customFields?: CustomFieldListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    targetIds?: SortOrder
    createdAt?: SortOrder
    dependenciesInfo?: SortOrder
    teamAccountIds?: SortOrder
    targetScoutIds?: SortOrder
    budget?: SortOrder
    lightMode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    targetContactIds?: SortOrder
    archived?: SortOrder
    archivedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    targetIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    dependenciesInfo?: JsonNullableWithAggregatesFilter<"Campaign">
    teamAccountIds?: StringNullableListFilter<"Campaign">
    targetScoutIds?: StringNullableListFilter<"Campaign">
    budget?: IntWithAggregatesFilter<"Campaign"> | number
    lightMode?: BoolNullableWithAggregatesFilter<"Campaign"> | boolean | null
    startDate?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    targetContactIds?: StringNullableListFilter<"Campaign">
    archived?: BoolWithAggregatesFilter<"Campaign"> | boolean
    archivedAt?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
  }

  export type TrackerWhereInput = {
    AND?: TrackerWhereInput | TrackerWhereInput[]
    OR?: TrackerWhereInput[]
    NOT?: TrackerWhereInput | TrackerWhereInput[]
    id?: StringFilter<"Tracker"> | string
    campaignId?: StringFilter<"Tracker"> | string
    trackerName?: StringFilter<"Tracker"> | string
    dependencies?: StringNullableListFilter<"Tracker">
    defaultFileNames?: StringNullableListFilter<"Tracker">
    customFileNames?: StringNullableListFilter<"Tracker">
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    evaluations?: EvaluationListRelationFilter
  }

  export type TrackerOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    trackerName?: SortOrder
    dependencies?: SortOrder
    defaultFileNames?: SortOrder
    customFileNames?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    evaluations?: EvaluationOrderByRelationAggregateInput
  }

  export type TrackerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    trackerName?: string
    AND?: TrackerWhereInput | TrackerWhereInput[]
    OR?: TrackerWhereInput[]
    NOT?: TrackerWhereInput | TrackerWhereInput[]
    campaignId?: StringFilter<"Tracker"> | string
    dependencies?: StringNullableListFilter<"Tracker">
    defaultFileNames?: StringNullableListFilter<"Tracker">
    customFileNames?: StringNullableListFilter<"Tracker">
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    evaluations?: EvaluationListRelationFilter
  }, "id" | "trackerName">

  export type TrackerOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    trackerName?: SortOrder
    dependencies?: SortOrder
    defaultFileNames?: SortOrder
    customFileNames?: SortOrder
    _count?: TrackerCountOrderByAggregateInput
    _max?: TrackerMaxOrderByAggregateInput
    _min?: TrackerMinOrderByAggregateInput
  }

  export type TrackerScalarWhereWithAggregatesInput = {
    AND?: TrackerScalarWhereWithAggregatesInput | TrackerScalarWhereWithAggregatesInput[]
    OR?: TrackerScalarWhereWithAggregatesInput[]
    NOT?: TrackerScalarWhereWithAggregatesInput | TrackerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tracker"> | string
    campaignId?: StringWithAggregatesFilter<"Tracker"> | string
    trackerName?: StringWithAggregatesFilter<"Tracker"> | string
    dependencies?: StringNullableListFilter<"Tracker">
    defaultFileNames?: StringNullableListFilter<"Tracker">
    customFileNames?: StringNullableListFilter<"Tracker">
  }

  export type EvaluationWhereInput = {
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    campaignId?: StringFilter<"Evaluation"> | string
    accountId?: StringFilter<"Evaluation"> | string
    teamAccountId?: StringFilter<"Evaluation"> | string
    githubTargetId?: StringFilter<"Evaluation"> | string
    type?: StringFilter<"Evaluation"> | string
    params?: JsonNullableFilter<"Evaluation">
    query?: StringNullableFilter<"Evaluation"> | string | null
    queryVariables?: JsonNullableFilter<"Evaluation">
    paginators?: JsonNullableFilter<"Evaluation">
    maxPerPage?: IntFilter<"Evaluation"> | number
    dataId?: StringNullableFilter<"Evaluation"> | string | null
    result?: JsonNullableFilter<"Evaluation">
    status?: StringFilter<"Evaluation"> | string
    error?: StringNullableFilter<"Evaluation"> | string | null
    parentId?: StringNullableFilter<"Evaluation"> | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    trackerId?: StringNullableFilter<"Evaluation"> | string | null
    userId?: StringNullableFilter<"Evaluation"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    githubTarget?: XOR<GithubTargetRelationFilter, GithubTargetWhereInput>
    parent?: XOR<EvaluationNullableRelationFilter, EvaluationWhereInput> | null
    children?: EvaluationListRelationFilter
    tracker?: XOR<TrackerNullableRelationFilter, TrackerWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type EvaluationOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    accountId?: SortOrder
    teamAccountId?: SortOrder
    githubTargetId?: SortOrder
    type?: SortOrder
    params?: SortOrder
    query?: SortOrder
    queryVariables?: SortOrder
    paginators?: SortOrder
    maxPerPage?: SortOrder
    dataId?: SortOrder
    result?: SortOrder
    status?: SortOrder
    error?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trackerId?: SortOrder
    userId?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
    teamAccount?: TeamAccountOrderByWithRelationInput
    githubTarget?: GithubTargetOrderByWithRelationInput
    parent?: EvaluationOrderByWithRelationInput
    children?: EvaluationOrderByRelationAggregateInput
    tracker?: TrackerOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type EvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    dataId?: string
    AND?: EvaluationWhereInput | EvaluationWhereInput[]
    OR?: EvaluationWhereInput[]
    NOT?: EvaluationWhereInput | EvaluationWhereInput[]
    campaignId?: StringFilter<"Evaluation"> | string
    accountId?: StringFilter<"Evaluation"> | string
    teamAccountId?: StringFilter<"Evaluation"> | string
    githubTargetId?: StringFilter<"Evaluation"> | string
    type?: StringFilter<"Evaluation"> | string
    params?: JsonNullableFilter<"Evaluation">
    query?: StringNullableFilter<"Evaluation"> | string | null
    queryVariables?: JsonNullableFilter<"Evaluation">
    paginators?: JsonNullableFilter<"Evaluation">
    maxPerPage?: IntFilter<"Evaluation"> | number
    result?: JsonNullableFilter<"Evaluation">
    status?: StringFilter<"Evaluation"> | string
    error?: StringNullableFilter<"Evaluation"> | string | null
    parentId?: StringNullableFilter<"Evaluation"> | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    trackerId?: StringNullableFilter<"Evaluation"> | string | null
    userId?: StringNullableFilter<"Evaluation"> | string | null
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    teamAccount?: XOR<TeamAccountRelationFilter, TeamAccountWhereInput>
    githubTarget?: XOR<GithubTargetRelationFilter, GithubTargetWhereInput>
    parent?: XOR<EvaluationNullableRelationFilter, EvaluationWhereInput> | null
    children?: EvaluationListRelationFilter
    tracker?: XOR<TrackerNullableRelationFilter, TrackerWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "dataId">

  export type EvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    accountId?: SortOrder
    teamAccountId?: SortOrder
    githubTargetId?: SortOrder
    type?: SortOrder
    params?: SortOrder
    query?: SortOrder
    queryVariables?: SortOrder
    paginators?: SortOrder
    maxPerPage?: SortOrder
    dataId?: SortOrder
    result?: SortOrder
    status?: SortOrder
    error?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trackerId?: SortOrder
    userId?: SortOrder
    _count?: EvaluationCountOrderByAggregateInput
    _avg?: EvaluationAvgOrderByAggregateInput
    _max?: EvaluationMaxOrderByAggregateInput
    _min?: EvaluationMinOrderByAggregateInput
    _sum?: EvaluationSumOrderByAggregateInput
  }

  export type EvaluationScalarWhereWithAggregatesInput = {
    AND?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    OR?: EvaluationScalarWhereWithAggregatesInput[]
    NOT?: EvaluationScalarWhereWithAggregatesInput | EvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evaluation"> | string
    campaignId?: StringWithAggregatesFilter<"Evaluation"> | string
    accountId?: StringWithAggregatesFilter<"Evaluation"> | string
    teamAccountId?: StringWithAggregatesFilter<"Evaluation"> | string
    githubTargetId?: StringWithAggregatesFilter<"Evaluation"> | string
    type?: StringWithAggregatesFilter<"Evaluation"> | string
    params?: JsonNullableWithAggregatesFilter<"Evaluation">
    query?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    queryVariables?: JsonNullableWithAggregatesFilter<"Evaluation">
    paginators?: JsonNullableWithAggregatesFilter<"Evaluation">
    maxPerPage?: IntWithAggregatesFilter<"Evaluation"> | number
    dataId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    result?: JsonNullableWithAggregatesFilter<"Evaluation">
    status?: StringWithAggregatesFilter<"Evaluation"> | string
    error?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evaluation"> | Date | string
    trackerId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Evaluation"> | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    targetIds?: StringNullableListFilter<"Report">
    type?: StringFilter<"Report"> | string
    params?: JsonNullableFilter<"Report">
    title?: StringFilter<"Report"> | string
    body?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    githubTargets?: GithubTargetListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    targetIds?: SortOrder
    type?: SortOrder
    params?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    githubTargets?: GithubTargetOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    targetIds?: StringNullableListFilter<"Report">
    type?: StringFilter<"Report"> | string
    params?: JsonNullableFilter<"Report">
    title?: StringFilter<"Report"> | string
    body?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    githubTargets?: GithubTargetListRelationFilter
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    targetIds?: SortOrder
    type?: SortOrder
    params?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    targetIds?: StringNullableListFilter<"Report">
    type?: StringWithAggregatesFilter<"Report"> | string
    params?: JsonNullableWithAggregatesFilter<"Report">
    title?: StringWithAggregatesFilter<"Report"> | string
    body?: StringWithAggregatesFilter<"Report"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type GithubRepositoryWhereInput = {
    AND?: GithubRepositoryWhereInput | GithubRepositoryWhereInput[]
    OR?: GithubRepositoryWhereInput[]
    NOT?: GithubRepositoryWhereInput | GithubRepositoryWhereInput[]
    id?: StringFilter<"GithubRepository"> | string
    name?: StringFilter<"GithubRepository"> | string
    owner?: StringFilter<"GithubRepository"> | string
    url?: StringFilter<"GithubRepository"> | string
    branches?: GithubRepositoryBranchCompositeListFilter | GithubRepositoryBranchObjectEqualityInput[]
  }

  export type GithubRepositoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    url?: SortOrder
    branches?: GithubRepositoryBranchOrderByCompositeAggregateInput
  }

  export type GithubRepositoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GithubRepositoryWhereInput | GithubRepositoryWhereInput[]
    OR?: GithubRepositoryWhereInput[]
    NOT?: GithubRepositoryWhereInput | GithubRepositoryWhereInput[]
    name?: StringFilter<"GithubRepository"> | string
    owner?: StringFilter<"GithubRepository"> | string
    url?: StringFilter<"GithubRepository"> | string
    branches?: GithubRepositoryBranchCompositeListFilter | GithubRepositoryBranchObjectEqualityInput[]
  }, "id">

  export type GithubRepositoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    url?: SortOrder
    _count?: GithubRepositoryCountOrderByAggregateInput
    _max?: GithubRepositoryMaxOrderByAggregateInput
    _min?: GithubRepositoryMinOrderByAggregateInput
  }

  export type GithubRepositoryScalarWhereWithAggregatesInput = {
    AND?: GithubRepositoryScalarWhereWithAggregatesInput | GithubRepositoryScalarWhereWithAggregatesInput[]
    OR?: GithubRepositoryScalarWhereWithAggregatesInput[]
    NOT?: GithubRepositoryScalarWhereWithAggregatesInput | GithubRepositoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GithubRepository"> | string
    name?: StringWithAggregatesFilter<"GithubRepository"> | string
    owner?: StringWithAggregatesFilter<"GithubRepository"> | string
    url?: StringWithAggregatesFilter<"GithubRepository"> | string
  }

  export type ZapierEventWhereInput = {
    AND?: ZapierEventWhereInput | ZapierEventWhereInput[]
    OR?: ZapierEventWhereInput[]
    NOT?: ZapierEventWhereInput | ZapierEventWhereInput[]
    id?: StringFilter<"ZapierEvent"> | string
    uuid?: StringFilter<"ZapierEvent"> | string
    createdAt?: DateTimeFilter<"ZapierEvent"> | Date | string
    text?: StringNullableFilter<"ZapierEvent"> | string | null
  }

  export type ZapierEventOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    text?: SortOrder
  }

  export type ZapierEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZapierEventWhereInput | ZapierEventWhereInput[]
    OR?: ZapierEventWhereInput[]
    NOT?: ZapierEventWhereInput | ZapierEventWhereInput[]
    uuid?: StringFilter<"ZapierEvent"> | string
    createdAt?: DateTimeFilter<"ZapierEvent"> | Date | string
    text?: StringNullableFilter<"ZapierEvent"> | string | null
  }, "id">

  export type ZapierEventOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    text?: SortOrder
    _count?: ZapierEventCountOrderByAggregateInput
    _max?: ZapierEventMaxOrderByAggregateInput
    _min?: ZapierEventMinOrderByAggregateInput
  }

  export type ZapierEventScalarWhereWithAggregatesInput = {
    AND?: ZapierEventScalarWhereWithAggregatesInput | ZapierEventScalarWhereWithAggregatesInput[]
    OR?: ZapierEventScalarWhereWithAggregatesInput[]
    NOT?: ZapierEventScalarWhereWithAggregatesInput | ZapierEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ZapierEvent"> | string
    uuid?: StringWithAggregatesFilter<"ZapierEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ZapierEvent"> | Date | string
    text?: StringNullableWithAggregatesFilter<"ZapierEvent"> | string | null
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
    Evaluation?: EvaluationCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    Evaluation?: EvaluationUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
    Evaluation?: EvaluationUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    Evaluation?: EvaluationUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhitelistCreateInput = {
    id?: string
    githubName: string
    quantity?: number
    createdAt?: Date | string | null
    teamAccount?: TeamAccountCreateNestedOneWithoutWhitelistInput
  }

  export type WhitelistUncheckedCreateInput = {
    id?: string
    githubName: string
    quantity?: number
    createdAt?: Date | string | null
    teamAccountId?: string | null
  }

  export type WhitelistUpdateInput = {
    githubName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamAccount?: TeamAccountUpdateOneWithoutWhitelistNestedInput
  }

  export type WhitelistUncheckedUpdateInput = {
    githubName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WhitelistCreateManyInput = {
    id?: string
    githubName: string
    quantity?: number
    createdAt?: Date | string | null
    teamAccountId?: string | null
  }

  export type WhitelistUpdateManyMutationInput = {
    githubName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhitelistUncheckedUpdateManyInput = {
    githubName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamAccountId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeCodesCreateInput = {
    id?: string
    code: string
    expires: Date | string
    type?: string
    email: string
    createdAt?: Date | string
    teamAccount: TeamAccountCreateNestedOneWithoutInviteCodesInput
  }

  export type OneTimeCodesUncheckedCreateInput = {
    id?: string
    code: string
    expires: Date | string
    type?: string
    email: string
    createdAt?: Date | string
    teamAccountId: string
  }

  export type OneTimeCodesUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccount?: TeamAccountUpdateOneRequiredWithoutInviteCodesNestedInput
  }

  export type OneTimeCodesUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type OneTimeCodesCreateManyInput = {
    id?: string
    code: string
    expires: Date | string
    type?: string
    email: string
    createdAt?: Date | string
    teamAccountId: string
  }

  export type OneTimeCodesUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeCodesUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    featureList?: SubscriptionCreatefeatureListInput | string[]
    teamAccounts?: TeamAccountCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    featureList?: SubscriptionCreatefeatureListInput | string[]
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    featureList?: SubscriptionUpdatefeatureListInput | string[]
    teamAccounts?: TeamAccountUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    featureList?: SubscriptionUpdatefeatureListInput | string[]
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    featureList?: SubscriptionCreatefeatureListInput | string[]
  }

  export type SubscriptionUpdateManyMutationInput = {
    featureList?: SubscriptionUpdatefeatureListInput | string[]
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    featureList?: SubscriptionUpdatefeatureListInput | string[]
  }

  export type TeamAccountCreateInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountCreateManyInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
  }

  export type TeamAccountUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
  }

  export type TeamAccountUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    creatingTeamAccount: TeamAccountCreateNestedOneWithoutContactsInput
    emails?: EmailCreateNestedManyWithoutContactsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutContactsInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    teamAccountId: string
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutContactsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    creatingTeamAccount?: TeamAccountUpdateOneRequiredWithoutContactsNestedInput
    emails?: EmailUpdateManyWithoutContactsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutContactsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    teamAccountId: string
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
  }

  export type ContactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
  }

  export type ContactUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
  }

  export type EmailCreateInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    messageId: string
    contacts?: ContactCreateNestedManyWithoutEmailsInput
    teamAccount: TeamAccountCreateNestedOneWithoutEmailsInput
    emailThread: EmailThreadCreateNestedOneWithoutEmailsInput
  }

  export type EmailUncheckedCreateInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    teamAccountId: string
    messageId: string
    emailThreadId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailsInput
  }

  export type EmailUpdateInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUpdateManyWithoutEmailsNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailsNestedInput
    emailThread?: EmailThreadUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutEmailsNestedInput
  }

  export type EmailCreateManyInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    teamAccountId: string
    messageId: string
    emailThreadId: string
  }

  export type EmailUpdateManyMutationInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUncheckedUpdateManyInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailThreadCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailCreateNestedManyWithoutEmailThreadInput
    teamAccount: TeamAccountCreateNestedOneWithoutEmailThreadsInput
    contacts?: ContactCreateNestedManyWithoutEmailThreadsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadUncheckedCreateInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    teamAccountId: string
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutEmailThreadInput
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailThreadsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUpdateManyWithoutEmailThreadNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailThreadsNestedInput
    contacts?: ContactUpdateManyWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutEmailThreadNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadCreateManyInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    teamAccountId: string
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
  }

  export type EmailThreadUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailThreadUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
  }

  export type NoteCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: string
    text: string
    teamAccount: TeamAccountCreateNestedOneWithoutNotesInput
    teamAccountUser: UserCreateNestedOneWithoutNotesInput
    githubTarget?: GithubTargetCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccountId: string
    subject?: string
    text: string
    teamAccountUserId: string
    githubTargetId?: string | null
  }

  export type NoteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccount?: TeamAccountUpdateOneRequiredWithoutNotesNestedInput
    teamAccountUser?: UserUpdateOneRequiredWithoutNotesNestedInput
    githubTarget?: GithubTargetUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUserId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoteCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccountId: string
    subject?: string
    text: string
    teamAccountUserId: string
    githubTargetId?: string | null
  }

  export type NoteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type NoteUncheckedUpdateManyInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUserId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TargetScoutCreateInput = {
    id?: string
    dependencyName: string
    dependencyFilename: string
    filter?: XOR<TargetScoutFilterNullableCreateEnvelopeInput, TargetScoutFilterCreateInput> | null
    campaign: CampaignCreateNestedOneWithoutTargetScoutsInput
  }

  export type TargetScoutUncheckedCreateInput = {
    id?: string
    campaignId: string
    dependencyName: string
    dependencyFilename: string
    filter?: XOR<TargetScoutFilterNullableCreateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutUpdateInput = {
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
    campaign?: CampaignUpdateOneRequiredWithoutTargetScoutsNestedInput
  }

  export type TargetScoutUncheckedUpdateInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutCreateManyInput = {
    id?: string
    campaignId: string
    dependencyName: string
    dependencyFilename: string
    filter?: XOR<TargetScoutFilterNullableCreateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutUpdateManyMutationInput = {
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutUncheckedUpdateManyInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type CustomFieldCreateInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    campaign: CampaignCreateNestedOneWithoutCustomFieldsInput
    customFieldValues?: CustomFieldValueCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldUncheckedCreateInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    campaignId: string
    customFieldValues?: CustomFieldValueUncheckedCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCustomFieldsNestedInput
    customFieldValues?: CustomFieldValueUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    customFieldValues?: CustomFieldValueUncheckedUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldCreateManyInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    campaignId: string
  }

  export type CustomFieldUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
  }

  export type CustomFieldUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomFieldValueCreateInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    customField?: CustomFieldCreateNestedOneWithoutCustomFieldValuesInput
    targetContact: TargetContactCreateNestedOneWithoutCustomFieldValueInput
  }

  export type CustomFieldValueUncheckedCreateInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    customFieldId: string
    targetContactId: string
  }

  export type CustomFieldValueUpdateInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    customField?: CustomFieldUpdateOneWithoutCustomFieldValuesNestedInput
    targetContact?: TargetContactUpdateOneRequiredWithoutCustomFieldValueNestedInput
  }

  export type CustomFieldValueUncheckedUpdateInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    customFieldId?: StringFieldUpdateOperationsInput | string
    targetContactId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomFieldValueCreateManyInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    customFieldId: string
    targetContactId: string
  }

  export type CustomFieldValueUpdateManyMutationInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CustomFieldValueUncheckedUpdateManyInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    customFieldId?: StringFieldUpdateOperationsInput | string
    targetContactId?: StringFieldUpdateOperationsInput | string
  }

  export type TargetContactCreateInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    githubTarget?: GithubTargetCreateNestedOneWithoutTargetContactsInput
    teamAccount: TeamAccountCreateNestedOneWithoutTargetContactInput
    campaigns?: CampaignCreateNestedManyWithoutTargetContactsInput
    customFieldValue?: CustomFieldValueCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactUncheckedCreateInput = {
    id?: string
    githubTargetId?: string | null
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    teamAccountId: string
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTargetContactsInput
    customFieldValue?: CustomFieldValueUncheckedCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactUpdateInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    githubTarget?: GithubTargetUpdateOneWithoutTargetContactsNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutTargetContactNestedInput
    campaigns?: CampaignUpdateManyWithoutTargetContactsNestedInput
    customFieldValue?: CustomFieldValueUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutTargetContactsNestedInput
    customFieldValue?: CustomFieldValueUncheckedUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactCreateManyInput = {
    id?: string
    githubTargetId?: string | null
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    teamAccountId: string
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
  }

  export type TargetContactUpdateManyMutationInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TargetContactUncheckedUpdateManyInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
  }

  export type GithubTargetCreateInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUpdateInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetCreateManyInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
  }

  export type GithubTargetUpdateManyMutationInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubTargetUncheckedUpdateManyInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
  }

  export type CampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrackerCreateInput = {
    id?: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
    campaign: CampaignCreateNestedOneWithoutTrackersInput
    evaluations?: EvaluationCreateNestedManyWithoutTrackerInput
  }

  export type TrackerUncheckedCreateInput = {
    id?: string
    campaignId: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutTrackerInput
  }

  export type TrackerUpdateInput = {
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
    campaign?: CampaignUpdateOneRequiredWithoutTrackersNestedInput
    evaluations?: EvaluationUpdateManyWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
    evaluations?: EvaluationUncheckedUpdateManyWithoutTrackerNestedInput
  }

  export type TrackerCreateManyInput = {
    id?: string
    campaignId: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
  }

  export type TrackerUpdateManyMutationInput = {
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
  }

  export type TrackerUncheckedUpdateManyInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
  }

  export type EvaluationCreateInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationCreateManyInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type EvaluationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUncheckedUpdateManyInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    title: string
    body: string
    createdAt?: Date | string
    githubTargets?: GithubTargetCreateNestedManyWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    targetIds?: ReportCreatetargetIdsInput | string[]
    type: string
    params?: InputJsonValue | null
    title: string
    body: string
    createdAt?: Date | string
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutReportsInput
  }

  export type ReportUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubTargets?: GithubTargetUpdateManyWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    targetIds?: ReportUpdatetargetIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutReportsNestedInput
  }

  export type ReportCreateManyInput = {
    id?: string
    targetIds?: ReportCreatetargetIdsInput | string[]
    type: string
    params?: InputJsonValue | null
    title: string
    body: string
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    targetIds?: ReportUpdatetargetIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GithubRepositoryCreateInput = {
    id?: string
    name: string
    owner: string
    url: string
    branches?: XOR<GithubRepositoryBranchListCreateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryUncheckedCreateInput = {
    id?: string
    name: string
    owner: string
    url: string
    branches?: XOR<GithubRepositoryBranchListCreateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    branches?: XOR<GithubRepositoryBranchListUpdateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    branches?: XOR<GithubRepositoryBranchListUpdateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryCreateManyInput = {
    id?: string
    name: string
    owner: string
    url: string
    branches?: XOR<GithubRepositoryBranchListCreateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    branches?: XOR<GithubRepositoryBranchListUpdateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    branches?: XOR<GithubRepositoryBranchListUpdateEnvelopeInput, GithubRepositoryBranchCreateInput> | GithubRepositoryBranchCreateInput[]
  }

  export type ZapierEventCreateInput = {
    id?: string
    uuid: string
    createdAt?: Date | string
    text?: string | null
  }

  export type ZapierEventUncheckedCreateInput = {
    id?: string
    uuid: string
    createdAt?: Date | string
    text?: string | null
  }

  export type ZapierEventUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZapierEventUncheckedUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZapierEventCreateManyInput = {
    id?: string
    uuid: string
    createdAt?: Date | string
    text?: string | null
  }

  export type ZapierEventUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ZapierEventUncheckedUpdateManyInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EvaluationListRelationFilter = {
    every?: EvaluationWhereInput
    some?: EvaluationWhereInput
    none?: EvaluationWhereInput
  }

  export type EvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    refresh_token_expires_in?: SortOrder
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    refresh_token_expires_in?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    refresh_token_expires_in?: SortOrder
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type TeamAccountNullableRelationFilter = {
    is?: TeamAccountWhereInput | null
    isNot?: TeamAccountWhereInput | null
  }

  export type WhitelistCountOrderByAggregateInput = {
    id?: SortOrder
    githubName?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type WhitelistAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type WhitelistMaxOrderByAggregateInput = {
    id?: SortOrder
    githubName?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type WhitelistMinOrderByAggregateInput = {
    id?: SortOrder
    githubName?: SortOrder
    quantity?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type WhitelistSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type TeamAccountListRelationFilter = {
    every?: TeamAccountWhereInput
    some?: TeamAccountWhereInput
    none?: TeamAccountWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    contactEmail?: SortOrder
    image?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lastSeen?: SortOrder
    ownedTeamAccountIds?: SortOrder
    teamAccountIds?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    contactEmail?: SortOrder
    image?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lastSeen?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    contactEmail?: SortOrder
    image?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    lastSeen?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type TeamAccountRelationFilter = {
    is?: TeamAccountWhereInput
    isNot?: TeamAccountWhereInput
  }

  export type OneTimeCodesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type OneTimeCodesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type OneTimeCodesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expires?: SortOrder
    type?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    featureList?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OneTimeCodesListRelationFilter = {
    every?: OneTimeCodesWhereInput
    some?: OneTimeCodesWhereInput
    none?: OneTimeCodesWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type EmailListRelationFilter = {
    every?: EmailWhereInput
    some?: EmailWhereInput
    none?: EmailWhereInput
  }

  export type EmailThreadListRelationFilter = {
    every?: EmailThreadWhereInput
    some?: EmailThreadWhereInput
    none?: EmailThreadWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type TargetContactListRelationFilter = {
    every?: TargetContactWhereInput
    some?: TargetContactWhereInput
    none?: TargetContactWhereInput
  }

  export type SubscriptionNullableRelationFilter = {
    is?: SubscriptionWhereInput | null
    isNot?: SubscriptionWhereInput | null
  }

  export type WhitelistNullableRelationFilter = {
    is?: WhitelistWhereInput | null
    isNot?: WhitelistWhereInput | null
  }

  export type OneTimeCodesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailThreadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TargetContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamAccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    aliasEmail?: SortOrder
    verifiedEmailAddresses?: SortOrder
    teamAccountUserIds?: SortOrder
    ownerIds?: SortOrder
    campaignIds?: SortOrder
    subscriptionId?: SortOrder
  }

  export type TeamAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    aliasEmail?: SortOrder
    subscriptionId?: SortOrder
  }

  export type TeamAccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    aliasEmail?: SortOrder
    subscriptionId?: SortOrder
  }

  export type GithubTargetListRelationFilter = {
    every?: GithubTargetWhereInput
    some?: GithubTargetWhereInput
    none?: GithubTargetWhereInput
  }

  export type GithubTargetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    contactEmails?: SortOrder
    teamAccountId?: SortOrder
    emailIds?: SortOrder
    emailThreadIds?: SortOrder
    targetIds?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    teamAccountId?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    email?: SortOrder
    teamAccountId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EmailThreadRelationFilter = {
    is?: EmailThreadWhereInput
    isNot?: EmailThreadWhereInput
  }

  export type EmailCountOrderByAggregateInput = {
    id?: SortOrder
    to?: SortOrder
    bcc?: SortOrder
    cc?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    sentByUser?: SortOrder
    sentAt?: SortOrder
    contactIds?: SortOrder
    teamAccountId?: SortOrder
    messageId?: SortOrder
    emailThreadId?: SortOrder
  }

  export type EmailMaxOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    sentByUser?: SortOrder
    sentAt?: SortOrder
    teamAccountId?: SortOrder
    messageId?: SortOrder
    emailThreadId?: SortOrder
  }

  export type EmailMinOrderByAggregateInput = {
    id?: SortOrder
    from?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    sentByUser?: SortOrder
    sentAt?: SortOrder
    teamAccountId?: SortOrder
    messageId?: SortOrder
    emailThreadId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EmailThreadCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactIds?: SortOrder
    teamAccountId?: SortOrder
    targetIds?: SortOrder
  }

  export type EmailThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type EmailThreadMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
  }

  export type GithubTargetNullableRelationFilter = {
    is?: GithubTargetWhereInput | null
    isNot?: GithubTargetWhereInput | null
  }

  export type NoteCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    teamAccountUserId?: SortOrder
    githubTargetId?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    teamAccountUserId?: SortOrder
    githubTargetId?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamAccountId?: SortOrder
    subject?: SortOrder
    text?: SortOrder
    teamAccountUserId?: SortOrder
    githubTargetId?: SortOrder
  }

  export type TargetScoutFilterNullableCompositeFilter = {
    equals?: TargetScoutFilterObjectEqualityInput | null
    is?: TargetScoutFilterWhereInput | null
    isNot?: TargetScoutFilterWhereInput | null
    isSet?: boolean
  }

  export type TargetScoutFilterObjectEqualityInput = {
    repoOwners?: string | null
    repoCreatedDate?: string | null
    repoStars?: string | null
    repoForks?: string | null
    userLocation?: string | null
    userFollowers?: string | null
    userRepositories?: string | null
    userLanguages?: string | null
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type TargetScoutFilterOrderByInput = {
    repoOwners?: SortOrder
    repoCreatedDate?: SortOrder
    repoStars?: SortOrder
    repoForks?: SortOrder
    userLocation?: SortOrder
    userFollowers?: SortOrder
    userRepositories?: SortOrder
    userLanguages?: SortOrder
  }

  export type TargetScoutCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    dependencyName?: SortOrder
    dependencyFilename?: SortOrder
  }

  export type TargetScoutMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    dependencyName?: SortOrder
    dependencyFilename?: SortOrder
  }

  export type TargetScoutMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    dependencyName?: SortOrder
    dependencyFilename?: SortOrder
  }

  export type CustomFieldValueListRelationFilter = {
    every?: CustomFieldValueWhereInput
    some?: CustomFieldValueWhereInput
    none?: CustomFieldValueWhereInput
  }

  export type CustomFieldValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    bgColor?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    campaignId?: SortOrder
  }

  export type CustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    bgColor?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    campaignId?: SortOrder
  }

  export type CustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    bgColor?: SortOrder
    type?: SortOrder
    targetType?: SortOrder
    campaignId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CustomFieldNullableRelationFilter = {
    is?: CustomFieldWhereInput | null
    isNot?: CustomFieldWhereInput | null
  }

  export type TargetContactRelationFilter = {
    is?: TargetContactWhereInput
    isNot?: TargetContactWhereInput
  }

  export type CustomFieldValueCountOrderByAggregateInput = {
    id?: SortOrder
    value_string?: SortOrder
    value_number?: SortOrder
    value_date?: SortOrder
    value_boolean?: SortOrder
    customFieldId?: SortOrder
    targetContactId?: SortOrder
  }

  export type CustomFieldValueAvgOrderByAggregateInput = {
    value_number?: SortOrder
  }

  export type CustomFieldValueMaxOrderByAggregateInput = {
    id?: SortOrder
    value_string?: SortOrder
    value_number?: SortOrder
    value_date?: SortOrder
    value_boolean?: SortOrder
    customFieldId?: SortOrder
    targetContactId?: SortOrder
  }

  export type CustomFieldValueMinOrderByAggregateInput = {
    id?: SortOrder
    value_string?: SortOrder
    value_number?: SortOrder
    value_date?: SortOrder
    value_boolean?: SortOrder
    customFieldId?: SortOrder
    targetContactId?: SortOrder
  }

  export type CustomFieldValueSumOrderByAggregateInput = {
    value_number?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TargetContactCountOrderByAggregateInput = {
    id?: SortOrder
    githubTargetId?: SortOrder
    industry?: SortOrder
    projectOwner?: SortOrder
    projectName?: SortOrder
    type?: SortOrder
    location?: SortOrder
    teamAccountId?: SortOrder
    status?: SortOrder
    campaignIds?: SortOrder
  }

  export type TargetContactMaxOrderByAggregateInput = {
    id?: SortOrder
    githubTargetId?: SortOrder
    industry?: SortOrder
    projectOwner?: SortOrder
    projectName?: SortOrder
    type?: SortOrder
    location?: SortOrder
    teamAccountId?: SortOrder
    status?: SortOrder
  }

  export type TargetContactMinOrderByAggregateInput = {
    id?: SortOrder
    githubTargetId?: SortOrder
    industry?: SortOrder
    projectOwner?: SortOrder
    projectName?: SortOrder
    type?: SortOrder
    location?: SortOrder
    teamAccountId?: SortOrder
    status?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GithubTargetCountOrderByAggregateInput = {
    id?: SortOrder
    githubGraphqlId?: SortOrder
    campaignIds?: SortOrder
    reportIds?: SortOrder
    type?: SortOrder
    metadata?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactIds?: SortOrder
    emailThreadIds?: SortOrder
  }

  export type GithubTargetMaxOrderByAggregateInput = {
    id?: SortOrder
    githubGraphqlId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GithubTargetMinOrderByAggregateInput = {
    id?: SortOrder
    githubGraphqlId?: SortOrder
    type?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type TargetScoutListRelationFilter = {
    every?: TargetScoutWhereInput
    some?: TargetScoutWhereInput
    none?: TargetScoutWhereInput
  }

  export type TrackerListRelationFilter = {
    every?: TrackerWhereInput
    some?: TrackerWhereInput
    none?: TrackerWhereInput
  }

  export type CustomFieldListRelationFilter = {
    every?: CustomFieldWhereInput
    some?: CustomFieldWhereInput
    none?: CustomFieldWhereInput
  }

  export type TargetScoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrackerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    targetIds?: SortOrder
    createdAt?: SortOrder
    dependenciesInfo?: SortOrder
    teamAccountIds?: SortOrder
    targetScoutIds?: SortOrder
    budget?: SortOrder
    lightMode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    targetContactIds?: SortOrder
    archived?: SortOrder
    archivedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    budget?: SortOrder
    lightMode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    archived?: SortOrder
    archivedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    budget?: SortOrder
    lightMode?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    archived?: SortOrder
    archivedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    budget?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type TrackerCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    trackerName?: SortOrder
    dependencies?: SortOrder
    defaultFileNames?: SortOrder
    customFileNames?: SortOrder
  }

  export type TrackerMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    trackerName?: SortOrder
  }

  export type TrackerMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    trackerName?: SortOrder
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type GithubTargetRelationFilter = {
    is?: GithubTargetWhereInput
    isNot?: GithubTargetWhereInput
  }

  export type EvaluationNullableRelationFilter = {
    is?: EvaluationWhereInput | null
    isNot?: EvaluationWhereInput | null
  }

  export type TrackerNullableRelationFilter = {
    is?: TrackerWhereInput | null
    isNot?: TrackerWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    accountId?: SortOrder
    teamAccountId?: SortOrder
    githubTargetId?: SortOrder
    type?: SortOrder
    params?: SortOrder
    query?: SortOrder
    queryVariables?: SortOrder
    paginators?: SortOrder
    maxPerPage?: SortOrder
    dataId?: SortOrder
    result?: SortOrder
    status?: SortOrder
    error?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trackerId?: SortOrder
    userId?: SortOrder
  }

  export type EvaluationAvgOrderByAggregateInput = {
    maxPerPage?: SortOrder
  }

  export type EvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    accountId?: SortOrder
    teamAccountId?: SortOrder
    githubTargetId?: SortOrder
    type?: SortOrder
    query?: SortOrder
    maxPerPage?: SortOrder
    dataId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trackerId?: SortOrder
    userId?: SortOrder
  }

  export type EvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    accountId?: SortOrder
    teamAccountId?: SortOrder
    githubTargetId?: SortOrder
    type?: SortOrder
    query?: SortOrder
    maxPerPage?: SortOrder
    dataId?: SortOrder
    status?: SortOrder
    error?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    trackerId?: SortOrder
    userId?: SortOrder
  }

  export type EvaluationSumOrderByAggregateInput = {
    maxPerPage?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    targetIds?: SortOrder
    type?: SortOrder
    params?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type GithubRepositoryBranchCompositeListFilter = {
    equals?: GithubRepositoryBranchObjectEqualityInput[]
    every?: GithubRepositoryBranchWhereInput
    some?: GithubRepositoryBranchWhereInput
    none?: GithubRepositoryBranchWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type GithubRepositoryBranchObjectEqualityInput = {
    name: string
    isDefault: boolean
    commits?: GithubRepositoryCommitObjectEqualityInput[]
  }

  export type GithubRepositoryBranchOrderByCompositeAggregateInput = {
    _count?: SortOrder
  }

  export type GithubRepositoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    url?: SortOrder
  }

  export type GithubRepositoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    url?: SortOrder
  }

  export type GithubRepositoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    owner?: SortOrder
    url?: SortOrder
  }

  export type ZapierEventCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    text?: SortOrder
  }

  export type ZapierEventMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    text?: SortOrder
  }

  export type ZapierEventMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    createdAt?: SortOrder
    text?: SortOrder
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutAccountInput = {
    create?: XOR<EvaluationCreateWithoutAccountInput, EvaluationUncheckedCreateWithoutAccountInput> | EvaluationCreateWithoutAccountInput[] | EvaluationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutAccountInput | EvaluationCreateOrConnectWithoutAccountInput[]
    createMany?: EvaluationCreateManyAccountInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<EvaluationCreateWithoutAccountInput, EvaluationUncheckedCreateWithoutAccountInput> | EvaluationCreateWithoutAccountInput[] | EvaluationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutAccountInput | EvaluationCreateOrConnectWithoutAccountInput[]
    createMany?: EvaluationCreateManyAccountInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type EvaluationUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EvaluationCreateWithoutAccountInput, EvaluationUncheckedCreateWithoutAccountInput> | EvaluationCreateWithoutAccountInput[] | EvaluationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutAccountInput | EvaluationCreateOrConnectWithoutAccountInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutAccountInput | EvaluationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EvaluationCreateManyAccountInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutAccountInput | EvaluationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutAccountInput | EvaluationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EvaluationCreateWithoutAccountInput, EvaluationUncheckedCreateWithoutAccountInput> | EvaluationCreateWithoutAccountInput[] | EvaluationUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutAccountInput | EvaluationCreateOrConnectWithoutAccountInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutAccountInput | EvaluationUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EvaluationCreateManyAccountInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutAccountInput | EvaluationUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutAccountInput | EvaluationUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type TeamAccountCreateNestedOneWithoutWhitelistInput = {
    create?: XOR<TeamAccountCreateWithoutWhitelistInput, TeamAccountUncheckedCreateWithoutWhitelistInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutWhitelistInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type TeamAccountUpdateOneWithoutWhitelistNestedInput = {
    create?: XOR<TeamAccountCreateWithoutWhitelistInput, TeamAccountUncheckedCreateWithoutWhitelistInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutWhitelistInput
    upsert?: TeamAccountUpsertWithoutWhitelistInput
    disconnect?: boolean
    delete?: TeamAccountWhereInput | boolean
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutWhitelistInput, TeamAccountUpdateWithoutWhitelistInput>, TeamAccountUncheckedUpdateWithoutWhitelistInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TeamAccountCreateNestedManyWithoutOwnersInput = {
    create?: XOR<TeamAccountCreateWithoutOwnersInput, TeamAccountUncheckedCreateWithoutOwnersInput> | TeamAccountCreateWithoutOwnersInput[] | TeamAccountUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutOwnersInput | TeamAccountCreateOrConnectWithoutOwnersInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type TeamAccountCreateNestedManyWithoutTeamAccountUsersInput = {
    create?: XOR<TeamAccountCreateWithoutTeamAccountUsersInput, TeamAccountUncheckedCreateWithoutTeamAccountUsersInput> | TeamAccountCreateWithoutTeamAccountUsersInput[] | TeamAccountUncheckedCreateWithoutTeamAccountUsersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutTeamAccountUsersInput | TeamAccountCreateOrConnectWithoutTeamAccountUsersInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutTeamAccountUserInput = {
    create?: XOR<NoteCreateWithoutTeamAccountUserInput, NoteUncheckedCreateWithoutTeamAccountUserInput> | NoteCreateWithoutTeamAccountUserInput[] | NoteUncheckedCreateWithoutTeamAccountUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountUserInput | NoteCreateOrConnectWithoutTeamAccountUserInput[]
    createMany?: NoteCreateManyTeamAccountUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutUserInput = {
    create?: XOR<EvaluationCreateWithoutUserInput, EvaluationUncheckedCreateWithoutUserInput> | EvaluationCreateWithoutUserInput[] | EvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutUserInput | EvaluationCreateOrConnectWithoutUserInput[]
    createMany?: EvaluationCreateManyUserInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type UserCreateownedTeamAccountIdsInput = {
    set: string[]
  }

  export type UserCreateteamAccountIdsInput = {
    set: string[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type TeamAccountUncheckedCreateNestedManyWithoutOwnersInput = {
    create?: XOR<TeamAccountCreateWithoutOwnersInput, TeamAccountUncheckedCreateWithoutOwnersInput> | TeamAccountCreateWithoutOwnersInput[] | TeamAccountUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutOwnersInput | TeamAccountCreateOrConnectWithoutOwnersInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput = {
    create?: XOR<TeamAccountCreateWithoutTeamAccountUsersInput, TeamAccountUncheckedCreateWithoutTeamAccountUsersInput> | TeamAccountCreateWithoutTeamAccountUsersInput[] | TeamAccountUncheckedCreateWithoutTeamAccountUsersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutTeamAccountUsersInput | TeamAccountCreateOrConnectWithoutTeamAccountUsersInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput = {
    create?: XOR<NoteCreateWithoutTeamAccountUserInput, NoteUncheckedCreateWithoutTeamAccountUserInput> | NoteCreateWithoutTeamAccountUserInput[] | NoteUncheckedCreateWithoutTeamAccountUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountUserInput | NoteCreateOrConnectWithoutTeamAccountUserInput[]
    createMany?: NoteCreateManyTeamAccountUserInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EvaluationCreateWithoutUserInput, EvaluationUncheckedCreateWithoutUserInput> | EvaluationCreateWithoutUserInput[] | EvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutUserInput | EvaluationCreateOrConnectWithoutUserInput[]
    createMany?: EvaluationCreateManyUserInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TeamAccountUpdateManyWithoutOwnersNestedInput = {
    create?: XOR<TeamAccountCreateWithoutOwnersInput, TeamAccountUncheckedCreateWithoutOwnersInput> | TeamAccountCreateWithoutOwnersInput[] | TeamAccountUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutOwnersInput | TeamAccountCreateOrConnectWithoutOwnersInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutOwnersInput | TeamAccountUpsertWithWhereUniqueWithoutOwnersInput[]
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutOwnersInput | TeamAccountUpdateWithWhereUniqueWithoutOwnersInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutOwnersInput | TeamAccountUpdateManyWithWhereWithoutOwnersInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput = {
    create?: XOR<TeamAccountCreateWithoutTeamAccountUsersInput, TeamAccountUncheckedCreateWithoutTeamAccountUsersInput> | TeamAccountCreateWithoutTeamAccountUsersInput[] | TeamAccountUncheckedCreateWithoutTeamAccountUsersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutTeamAccountUsersInput | TeamAccountCreateOrConnectWithoutTeamAccountUsersInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutTeamAccountUsersInput | TeamAccountUpsertWithWhereUniqueWithoutTeamAccountUsersInput[]
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutTeamAccountUsersInput | TeamAccountUpdateWithWhereUniqueWithoutTeamAccountUsersInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutTeamAccountUsersInput | TeamAccountUpdateManyWithWhereWithoutTeamAccountUsersInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutTeamAccountUserNestedInput = {
    create?: XOR<NoteCreateWithoutTeamAccountUserInput, NoteUncheckedCreateWithoutTeamAccountUserInput> | NoteCreateWithoutTeamAccountUserInput[] | NoteUncheckedCreateWithoutTeamAccountUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountUserInput | NoteCreateOrConnectWithoutTeamAccountUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutTeamAccountUserInput | NoteUpsertWithWhereUniqueWithoutTeamAccountUserInput[]
    createMany?: NoteCreateManyTeamAccountUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutTeamAccountUserInput | NoteUpdateWithWhereUniqueWithoutTeamAccountUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutTeamAccountUserInput | NoteUpdateManyWithWhereWithoutTeamAccountUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EvaluationCreateWithoutUserInput, EvaluationUncheckedCreateWithoutUserInput> | EvaluationCreateWithoutUserInput[] | EvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutUserInput | EvaluationCreateOrConnectWithoutUserInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutUserInput | EvaluationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EvaluationCreateManyUserInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutUserInput | EvaluationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutUserInput | EvaluationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type UserUpdateownedTeamAccountIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateteamAccountIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput = {
    create?: XOR<TeamAccountCreateWithoutOwnersInput, TeamAccountUncheckedCreateWithoutOwnersInput> | TeamAccountCreateWithoutOwnersInput[] | TeamAccountUncheckedCreateWithoutOwnersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutOwnersInput | TeamAccountCreateOrConnectWithoutOwnersInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutOwnersInput | TeamAccountUpsertWithWhereUniqueWithoutOwnersInput[]
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutOwnersInput | TeamAccountUpdateWithWhereUniqueWithoutOwnersInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutOwnersInput | TeamAccountUpdateManyWithWhereWithoutOwnersInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput = {
    create?: XOR<TeamAccountCreateWithoutTeamAccountUsersInput, TeamAccountUncheckedCreateWithoutTeamAccountUsersInput> | TeamAccountCreateWithoutTeamAccountUsersInput[] | TeamAccountUncheckedCreateWithoutTeamAccountUsersInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutTeamAccountUsersInput | TeamAccountCreateOrConnectWithoutTeamAccountUsersInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutTeamAccountUsersInput | TeamAccountUpsertWithWhereUniqueWithoutTeamAccountUsersInput[]
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutTeamAccountUsersInput | TeamAccountUpdateWithWhereUniqueWithoutTeamAccountUsersInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutTeamAccountUsersInput | TeamAccountUpdateManyWithWhereWithoutTeamAccountUsersInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput = {
    create?: XOR<NoteCreateWithoutTeamAccountUserInput, NoteUncheckedCreateWithoutTeamAccountUserInput> | NoteCreateWithoutTeamAccountUserInput[] | NoteUncheckedCreateWithoutTeamAccountUserInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountUserInput | NoteCreateOrConnectWithoutTeamAccountUserInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutTeamAccountUserInput | NoteUpsertWithWhereUniqueWithoutTeamAccountUserInput[]
    createMany?: NoteCreateManyTeamAccountUserInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutTeamAccountUserInput | NoteUpdateWithWhereUniqueWithoutTeamAccountUserInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutTeamAccountUserInput | NoteUpdateManyWithWhereWithoutTeamAccountUserInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EvaluationCreateWithoutUserInput, EvaluationUncheckedCreateWithoutUserInput> | EvaluationCreateWithoutUserInput[] | EvaluationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutUserInput | EvaluationCreateOrConnectWithoutUserInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutUserInput | EvaluationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EvaluationCreateManyUserInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutUserInput | EvaluationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutUserInput | EvaluationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type TeamAccountCreateNestedOneWithoutInviteCodesInput = {
    create?: XOR<TeamAccountCreateWithoutInviteCodesInput, TeamAccountUncheckedCreateWithoutInviteCodesInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutInviteCodesInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type TeamAccountUpdateOneRequiredWithoutInviteCodesNestedInput = {
    create?: XOR<TeamAccountCreateWithoutInviteCodesInput, TeamAccountUncheckedCreateWithoutInviteCodesInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutInviteCodesInput
    upsert?: TeamAccountUpsertWithoutInviteCodesInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutInviteCodesInput, TeamAccountUpdateWithoutInviteCodesInput>, TeamAccountUncheckedUpdateWithoutInviteCodesInput>
  }

  export type SubscriptionCreatefeatureListInput = {
    set: string[]
  }

  export type TeamAccountCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<TeamAccountCreateWithoutSubscriptionInput, TeamAccountUncheckedCreateWithoutSubscriptionInput> | TeamAccountCreateWithoutSubscriptionInput[] | TeamAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutSubscriptionInput | TeamAccountCreateOrConnectWithoutSubscriptionInput[]
    createMany?: TeamAccountCreateManySubscriptionInputEnvelope
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type TeamAccountUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<TeamAccountCreateWithoutSubscriptionInput, TeamAccountUncheckedCreateWithoutSubscriptionInput> | TeamAccountCreateWithoutSubscriptionInput[] | TeamAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutSubscriptionInput | TeamAccountCreateOrConnectWithoutSubscriptionInput[]
    createMany?: TeamAccountCreateManySubscriptionInputEnvelope
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type SubscriptionUpdatefeatureListInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeamAccountUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<TeamAccountCreateWithoutSubscriptionInput, TeamAccountUncheckedCreateWithoutSubscriptionInput> | TeamAccountCreateWithoutSubscriptionInput[] | TeamAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutSubscriptionInput | TeamAccountCreateOrConnectWithoutSubscriptionInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutSubscriptionInput | TeamAccountUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: TeamAccountCreateManySubscriptionInputEnvelope
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutSubscriptionInput | TeamAccountUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutSubscriptionInput | TeamAccountUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type TeamAccountUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<TeamAccountCreateWithoutSubscriptionInput, TeamAccountUncheckedCreateWithoutSubscriptionInput> | TeamAccountCreateWithoutSubscriptionInput[] | TeamAccountUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutSubscriptionInput | TeamAccountCreateOrConnectWithoutSubscriptionInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutSubscriptionInput | TeamAccountUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: TeamAccountCreateManySubscriptionInputEnvelope
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutSubscriptionInput | TeamAccountUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutSubscriptionInput | TeamAccountUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type TeamAccountCreateverifiedEmailAddressesInput = {
    set: string[]
  }

  export type OneTimeCodesCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<OneTimeCodesCreateWithoutTeamAccountInput, OneTimeCodesUncheckedCreateWithoutTeamAccountInput> | OneTimeCodesCreateWithoutTeamAccountInput[] | OneTimeCodesUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: OneTimeCodesCreateOrConnectWithoutTeamAccountInput | OneTimeCodesCreateOrConnectWithoutTeamAccountInput[]
    createMany?: OneTimeCodesCreateManyTeamAccountInputEnvelope
    connect?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTeamAccountsInput = {
    create?: XOR<UserCreateWithoutTeamAccountsInput, UserUncheckedCreateWithoutTeamAccountsInput> | UserCreateWithoutTeamAccountsInput[] | UserUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamAccountsInput | UserCreateOrConnectWithoutTeamAccountsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutCreatingTeamAccountInput = {
    create?: XOR<ContactCreateWithoutCreatingTeamAccountInput, ContactUncheckedCreateWithoutCreatingTeamAccountInput> | ContactCreateWithoutCreatingTeamAccountInput[] | ContactUncheckedCreateWithoutCreatingTeamAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatingTeamAccountInput | ContactCreateOrConnectWithoutCreatingTeamAccountInput[]
    createMany?: ContactCreateManyCreatingTeamAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type EmailCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<EmailCreateWithoutTeamAccountInput, EmailUncheckedCreateWithoutTeamAccountInput> | EmailCreateWithoutTeamAccountInput[] | EmailUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTeamAccountInput | EmailCreateOrConnectWithoutTeamAccountInput[]
    createMany?: EmailCreateManyTeamAccountInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutOwnedTeamAccountsInput = {
    create?: XOR<UserCreateWithoutOwnedTeamAccountsInput, UserUncheckedCreateWithoutOwnedTeamAccountsInput> | UserCreateWithoutOwnedTeamAccountsInput[] | UserUncheckedCreateWithoutOwnedTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedTeamAccountsInput | UserCreateOrConnectWithoutOwnedTeamAccountsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EmailThreadCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<EmailThreadCreateWithoutTeamAccountInput, EmailThreadUncheckedCreateWithoutTeamAccountInput> | EmailThreadCreateWithoutTeamAccountInput[] | EmailThreadUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTeamAccountInput | EmailThreadCreateOrConnectWithoutTeamAccountInput[]
    createMany?: EmailThreadCreateManyTeamAccountInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutTeamAccountsInput = {
    create?: XOR<CampaignCreateWithoutTeamAccountsInput, CampaignUncheckedCreateWithoutTeamAccountsInput> | CampaignCreateWithoutTeamAccountsInput[] | CampaignUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamAccountsInput | CampaignCreateOrConnectWithoutTeamAccountsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<NoteCreateWithoutTeamAccountInput, NoteUncheckedCreateWithoutTeamAccountInput> | NoteCreateWithoutTeamAccountInput[] | NoteUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountInput | NoteCreateOrConnectWithoutTeamAccountInput[]
    createMany?: NoteCreateManyTeamAccountInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TargetContactCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<TargetContactCreateWithoutTeamAccountInput, TargetContactUncheckedCreateWithoutTeamAccountInput> | TargetContactCreateWithoutTeamAccountInput[] | TargetContactUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutTeamAccountInput | TargetContactCreateOrConnectWithoutTeamAccountInput[]
    createMany?: TargetContactCreateManyTeamAccountInputEnvelope
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<EvaluationCreateWithoutTeamAccountInput, EvaluationUncheckedCreateWithoutTeamAccountInput> | EvaluationCreateWithoutTeamAccountInput[] | EvaluationUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTeamAccountInput | EvaluationCreateOrConnectWithoutTeamAccountInput[]
    createMany?: EvaluationCreateManyTeamAccountInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedOneWithoutTeamAccountsInput = {
    create?: XOR<SubscriptionCreateWithoutTeamAccountsInput, SubscriptionUncheckedCreateWithoutTeamAccountsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTeamAccountsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type WhitelistCreateNestedOneWithoutTeamAccountInput = {
    create?: XOR<WhitelistCreateWithoutTeamAccountInput, WhitelistUncheckedCreateWithoutTeamAccountInput>
    connectOrCreate?: WhitelistCreateOrConnectWithoutTeamAccountInput
    connect?: WhitelistWhereUniqueInput
  }

  export type TeamAccountCreateteamAccountUserIdsInput = {
    set: string[]
  }

  export type TeamAccountCreateownerIdsInput = {
    set: string[]
  }

  export type TeamAccountCreatecampaignIdsInput = {
    set: string[]
  }

  export type OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<OneTimeCodesCreateWithoutTeamAccountInput, OneTimeCodesUncheckedCreateWithoutTeamAccountInput> | OneTimeCodesCreateWithoutTeamAccountInput[] | OneTimeCodesUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: OneTimeCodesCreateOrConnectWithoutTeamAccountInput | OneTimeCodesCreateOrConnectWithoutTeamAccountInput[]
    createMany?: OneTimeCodesCreateManyTeamAccountInputEnvelope
    connect?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTeamAccountsInput = {
    create?: XOR<UserCreateWithoutTeamAccountsInput, UserUncheckedCreateWithoutTeamAccountsInput> | UserCreateWithoutTeamAccountsInput[] | UserUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamAccountsInput | UserCreateOrConnectWithoutTeamAccountsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput = {
    create?: XOR<ContactCreateWithoutCreatingTeamAccountInput, ContactUncheckedCreateWithoutCreatingTeamAccountInput> | ContactCreateWithoutCreatingTeamAccountInput[] | ContactUncheckedCreateWithoutCreatingTeamAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatingTeamAccountInput | ContactCreateOrConnectWithoutCreatingTeamAccountInput[]
    createMany?: ContactCreateManyCreatingTeamAccountInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type EmailUncheckedCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<EmailCreateWithoutTeamAccountInput, EmailUncheckedCreateWithoutTeamAccountInput> | EmailCreateWithoutTeamAccountInput[] | EmailUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTeamAccountInput | EmailCreateOrConnectWithoutTeamAccountInput[]
    createMany?: EmailCreateManyTeamAccountInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput = {
    create?: XOR<UserCreateWithoutOwnedTeamAccountsInput, UserUncheckedCreateWithoutOwnedTeamAccountsInput> | UserCreateWithoutOwnedTeamAccountsInput[] | UserUncheckedCreateWithoutOwnedTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedTeamAccountsInput | UserCreateOrConnectWithoutOwnedTeamAccountsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<EmailThreadCreateWithoutTeamAccountInput, EmailThreadUncheckedCreateWithoutTeamAccountInput> | EmailThreadCreateWithoutTeamAccountInput[] | EmailThreadUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTeamAccountInput | EmailThreadCreateOrConnectWithoutTeamAccountInput[]
    createMany?: EmailThreadCreateManyTeamAccountInputEnvelope
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput = {
    create?: XOR<CampaignCreateWithoutTeamAccountsInput, CampaignUncheckedCreateWithoutTeamAccountsInput> | CampaignCreateWithoutTeamAccountsInput[] | CampaignUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamAccountsInput | CampaignCreateOrConnectWithoutTeamAccountsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<NoteCreateWithoutTeamAccountInput, NoteUncheckedCreateWithoutTeamAccountInput> | NoteCreateWithoutTeamAccountInput[] | NoteUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountInput | NoteCreateOrConnectWithoutTeamAccountInput[]
    createMany?: NoteCreateManyTeamAccountInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<TargetContactCreateWithoutTeamAccountInput, TargetContactUncheckedCreateWithoutTeamAccountInput> | TargetContactCreateWithoutTeamAccountInput[] | TargetContactUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutTeamAccountInput | TargetContactCreateOrConnectWithoutTeamAccountInput[]
    createMany?: TargetContactCreateManyTeamAccountInputEnvelope
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput = {
    create?: XOR<EvaluationCreateWithoutTeamAccountInput, EvaluationUncheckedCreateWithoutTeamAccountInput> | EvaluationCreateWithoutTeamAccountInput[] | EvaluationUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTeamAccountInput | EvaluationCreateOrConnectWithoutTeamAccountInput[]
    createMany?: EvaluationCreateManyTeamAccountInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput = {
    create?: XOR<WhitelistCreateWithoutTeamAccountInput, WhitelistUncheckedCreateWithoutTeamAccountInput>
    connectOrCreate?: WhitelistCreateOrConnectWithoutTeamAccountInput
    connect?: WhitelistWhereUniqueInput
  }

  export type TeamAccountUpdateverifiedEmailAddressesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OneTimeCodesUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<OneTimeCodesCreateWithoutTeamAccountInput, OneTimeCodesUncheckedCreateWithoutTeamAccountInput> | OneTimeCodesCreateWithoutTeamAccountInput[] | OneTimeCodesUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: OneTimeCodesCreateOrConnectWithoutTeamAccountInput | OneTimeCodesCreateOrConnectWithoutTeamAccountInput[]
    upsert?: OneTimeCodesUpsertWithWhereUniqueWithoutTeamAccountInput | OneTimeCodesUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: OneTimeCodesCreateManyTeamAccountInputEnvelope
    set?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    disconnect?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    delete?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    connect?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    update?: OneTimeCodesUpdateWithWhereUniqueWithoutTeamAccountInput | OneTimeCodesUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: OneTimeCodesUpdateManyWithWhereWithoutTeamAccountInput | OneTimeCodesUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: OneTimeCodesScalarWhereInput | OneTimeCodesScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTeamAccountsNestedInput = {
    create?: XOR<UserCreateWithoutTeamAccountsInput, UserUncheckedCreateWithoutTeamAccountsInput> | UserCreateWithoutTeamAccountsInput[] | UserUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamAccountsInput | UserCreateOrConnectWithoutTeamAccountsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamAccountsInput | UserUpsertWithWhereUniqueWithoutTeamAccountsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamAccountsInput | UserUpdateWithWhereUniqueWithoutTeamAccountsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamAccountsInput | UserUpdateManyWithWhereWithoutTeamAccountsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutCreatingTeamAccountNestedInput = {
    create?: XOR<ContactCreateWithoutCreatingTeamAccountInput, ContactUncheckedCreateWithoutCreatingTeamAccountInput> | ContactCreateWithoutCreatingTeamAccountInput[] | ContactUncheckedCreateWithoutCreatingTeamAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatingTeamAccountInput | ContactCreateOrConnectWithoutCreatingTeamAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCreatingTeamAccountInput | ContactUpsertWithWhereUniqueWithoutCreatingTeamAccountInput[]
    createMany?: ContactCreateManyCreatingTeamAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCreatingTeamAccountInput | ContactUpdateWithWhereUniqueWithoutCreatingTeamAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCreatingTeamAccountInput | ContactUpdateManyWithWhereWithoutCreatingTeamAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type EmailUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<EmailCreateWithoutTeamAccountInput, EmailUncheckedCreateWithoutTeamAccountInput> | EmailCreateWithoutTeamAccountInput[] | EmailUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTeamAccountInput | EmailCreateOrConnectWithoutTeamAccountInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutTeamAccountInput | EmailUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: EmailCreateManyTeamAccountInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutTeamAccountInput | EmailUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutTeamAccountInput | EmailUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type UserUpdateManyWithoutOwnedTeamAccountsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedTeamAccountsInput, UserUncheckedCreateWithoutOwnedTeamAccountsInput> | UserCreateWithoutOwnedTeamAccountsInput[] | UserUncheckedCreateWithoutOwnedTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedTeamAccountsInput | UserCreateOrConnectWithoutOwnedTeamAccountsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOwnedTeamAccountsInput | UserUpsertWithWhereUniqueWithoutOwnedTeamAccountsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOwnedTeamAccountsInput | UserUpdateWithWhereUniqueWithoutOwnedTeamAccountsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOwnedTeamAccountsInput | UserUpdateManyWithWhereWithoutOwnedTeamAccountsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type EmailThreadUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<EmailThreadCreateWithoutTeamAccountInput, EmailThreadUncheckedCreateWithoutTeamAccountInput> | EmailThreadCreateWithoutTeamAccountInput[] | EmailThreadUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTeamAccountInput | EmailThreadCreateOrConnectWithoutTeamAccountInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutTeamAccountInput | EmailThreadUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: EmailThreadCreateManyTeamAccountInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutTeamAccountInput | EmailThreadUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutTeamAccountInput | EmailThreadUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutTeamAccountsNestedInput = {
    create?: XOR<CampaignCreateWithoutTeamAccountsInput, CampaignUncheckedCreateWithoutTeamAccountsInput> | CampaignCreateWithoutTeamAccountsInput[] | CampaignUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamAccountsInput | CampaignCreateOrConnectWithoutTeamAccountsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTeamAccountsInput | CampaignUpsertWithWhereUniqueWithoutTeamAccountsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTeamAccountsInput | CampaignUpdateWithWhereUniqueWithoutTeamAccountsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTeamAccountsInput | CampaignUpdateManyWithWhereWithoutTeamAccountsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<NoteCreateWithoutTeamAccountInput, NoteUncheckedCreateWithoutTeamAccountInput> | NoteCreateWithoutTeamAccountInput[] | NoteUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountInput | NoteCreateOrConnectWithoutTeamAccountInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutTeamAccountInput | NoteUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: NoteCreateManyTeamAccountInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutTeamAccountInput | NoteUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutTeamAccountInput | NoteUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TargetContactUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<TargetContactCreateWithoutTeamAccountInput, TargetContactUncheckedCreateWithoutTeamAccountInput> | TargetContactCreateWithoutTeamAccountInput[] | TargetContactUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutTeamAccountInput | TargetContactCreateOrConnectWithoutTeamAccountInput[]
    upsert?: TargetContactUpsertWithWhereUniqueWithoutTeamAccountInput | TargetContactUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: TargetContactCreateManyTeamAccountInputEnvelope
    set?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    disconnect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    delete?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    update?: TargetContactUpdateWithWhereUniqueWithoutTeamAccountInput | TargetContactUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: TargetContactUpdateManyWithWhereWithoutTeamAccountInput | TargetContactUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<EvaluationCreateWithoutTeamAccountInput, EvaluationUncheckedCreateWithoutTeamAccountInput> | EvaluationCreateWithoutTeamAccountInput[] | EvaluationUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTeamAccountInput | EvaluationCreateOrConnectWithoutTeamAccountInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutTeamAccountInput | EvaluationUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: EvaluationCreateManyTeamAccountInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutTeamAccountInput | EvaluationUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutTeamAccountInput | EvaluationUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type SubscriptionUpdateOneWithoutTeamAccountsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutTeamAccountsInput, SubscriptionUncheckedCreateWithoutTeamAccountsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutTeamAccountsInput
    upsert?: SubscriptionUpsertWithoutTeamAccountsInput
    disconnect?: boolean
    delete?: SubscriptionWhereInput | boolean
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutTeamAccountsInput, SubscriptionUpdateWithoutTeamAccountsInput>, SubscriptionUncheckedUpdateWithoutTeamAccountsInput>
  }

  export type WhitelistUpdateOneWithoutTeamAccountNestedInput = {
    create?: XOR<WhitelistCreateWithoutTeamAccountInput, WhitelistUncheckedCreateWithoutTeamAccountInput>
    connectOrCreate?: WhitelistCreateOrConnectWithoutTeamAccountInput
    upsert?: WhitelistUpsertWithoutTeamAccountInput
    disconnect?: WhitelistWhereInput | boolean
    delete?: WhitelistWhereInput | boolean
    connect?: WhitelistWhereUniqueInput
    update?: XOR<XOR<WhitelistUpdateToOneWithWhereWithoutTeamAccountInput, WhitelistUpdateWithoutTeamAccountInput>, WhitelistUncheckedUpdateWithoutTeamAccountInput>
  }

  export type TeamAccountUpdateteamAccountUserIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeamAccountUpdateownerIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeamAccountUpdatecampaignIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<OneTimeCodesCreateWithoutTeamAccountInput, OneTimeCodesUncheckedCreateWithoutTeamAccountInput> | OneTimeCodesCreateWithoutTeamAccountInput[] | OneTimeCodesUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: OneTimeCodesCreateOrConnectWithoutTeamAccountInput | OneTimeCodesCreateOrConnectWithoutTeamAccountInput[]
    upsert?: OneTimeCodesUpsertWithWhereUniqueWithoutTeamAccountInput | OneTimeCodesUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: OneTimeCodesCreateManyTeamAccountInputEnvelope
    set?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    disconnect?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    delete?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    connect?: OneTimeCodesWhereUniqueInput | OneTimeCodesWhereUniqueInput[]
    update?: OneTimeCodesUpdateWithWhereUniqueWithoutTeamAccountInput | OneTimeCodesUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: OneTimeCodesUpdateManyWithWhereWithoutTeamAccountInput | OneTimeCodesUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: OneTimeCodesScalarWhereInput | OneTimeCodesScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTeamAccountsNestedInput = {
    create?: XOR<UserCreateWithoutTeamAccountsInput, UserUncheckedCreateWithoutTeamAccountsInput> | UserCreateWithoutTeamAccountsInput[] | UserUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamAccountsInput | UserCreateOrConnectWithoutTeamAccountsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamAccountsInput | UserUpsertWithWhereUniqueWithoutTeamAccountsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamAccountsInput | UserUpdateWithWhereUniqueWithoutTeamAccountsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamAccountsInput | UserUpdateManyWithWhereWithoutTeamAccountsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput = {
    create?: XOR<ContactCreateWithoutCreatingTeamAccountInput, ContactUncheckedCreateWithoutCreatingTeamAccountInput> | ContactCreateWithoutCreatingTeamAccountInput[] | ContactUncheckedCreateWithoutCreatingTeamAccountInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutCreatingTeamAccountInput | ContactCreateOrConnectWithoutCreatingTeamAccountInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutCreatingTeamAccountInput | ContactUpsertWithWhereUniqueWithoutCreatingTeamAccountInput[]
    createMany?: ContactCreateManyCreatingTeamAccountInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutCreatingTeamAccountInput | ContactUpdateWithWhereUniqueWithoutCreatingTeamAccountInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutCreatingTeamAccountInput | ContactUpdateManyWithWhereWithoutCreatingTeamAccountInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type EmailUncheckedUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<EmailCreateWithoutTeamAccountInput, EmailUncheckedCreateWithoutTeamAccountInput> | EmailCreateWithoutTeamAccountInput[] | EmailUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutTeamAccountInput | EmailCreateOrConnectWithoutTeamAccountInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutTeamAccountInput | EmailUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: EmailCreateManyTeamAccountInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutTeamAccountInput | EmailUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutTeamAccountInput | EmailUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedTeamAccountsInput, UserUncheckedCreateWithoutOwnedTeamAccountsInput> | UserCreateWithoutOwnedTeamAccountsInput[] | UserUncheckedCreateWithoutOwnedTeamAccountsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOwnedTeamAccountsInput | UserCreateOrConnectWithoutOwnedTeamAccountsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOwnedTeamAccountsInput | UserUpsertWithWhereUniqueWithoutOwnedTeamAccountsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOwnedTeamAccountsInput | UserUpdateWithWhereUniqueWithoutOwnedTeamAccountsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOwnedTeamAccountsInput | UserUpdateManyWithWhereWithoutOwnedTeamAccountsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<EmailThreadCreateWithoutTeamAccountInput, EmailThreadUncheckedCreateWithoutTeamAccountInput> | EmailThreadCreateWithoutTeamAccountInput[] | EmailThreadUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutTeamAccountInput | EmailThreadCreateOrConnectWithoutTeamAccountInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutTeamAccountInput | EmailThreadUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: EmailThreadCreateManyTeamAccountInputEnvelope
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutTeamAccountInput | EmailThreadUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutTeamAccountInput | EmailThreadUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput = {
    create?: XOR<CampaignCreateWithoutTeamAccountsInput, CampaignUncheckedCreateWithoutTeamAccountsInput> | CampaignCreateWithoutTeamAccountsInput[] | CampaignUncheckedCreateWithoutTeamAccountsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamAccountsInput | CampaignCreateOrConnectWithoutTeamAccountsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTeamAccountsInput | CampaignUpsertWithWhereUniqueWithoutTeamAccountsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTeamAccountsInput | CampaignUpdateWithWhereUniqueWithoutTeamAccountsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTeamAccountsInput | CampaignUpdateManyWithWhereWithoutTeamAccountsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<NoteCreateWithoutTeamAccountInput, NoteUncheckedCreateWithoutTeamAccountInput> | NoteCreateWithoutTeamAccountInput[] | NoteUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutTeamAccountInput | NoteCreateOrConnectWithoutTeamAccountInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutTeamAccountInput | NoteUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: NoteCreateManyTeamAccountInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutTeamAccountInput | NoteUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutTeamAccountInput | NoteUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<TargetContactCreateWithoutTeamAccountInput, TargetContactUncheckedCreateWithoutTeamAccountInput> | TargetContactCreateWithoutTeamAccountInput[] | TargetContactUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutTeamAccountInput | TargetContactCreateOrConnectWithoutTeamAccountInput[]
    upsert?: TargetContactUpsertWithWhereUniqueWithoutTeamAccountInput | TargetContactUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: TargetContactCreateManyTeamAccountInputEnvelope
    set?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    disconnect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    delete?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    update?: TargetContactUpdateWithWhereUniqueWithoutTeamAccountInput | TargetContactUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: TargetContactUpdateManyWithWhereWithoutTeamAccountInput | TargetContactUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput = {
    create?: XOR<EvaluationCreateWithoutTeamAccountInput, EvaluationUncheckedCreateWithoutTeamAccountInput> | EvaluationCreateWithoutTeamAccountInput[] | EvaluationUncheckedCreateWithoutTeamAccountInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTeamAccountInput | EvaluationCreateOrConnectWithoutTeamAccountInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutTeamAccountInput | EvaluationUpsertWithWhereUniqueWithoutTeamAccountInput[]
    createMany?: EvaluationCreateManyTeamAccountInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutTeamAccountInput | EvaluationUpdateWithWhereUniqueWithoutTeamAccountInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutTeamAccountInput | EvaluationUpdateManyWithWhereWithoutTeamAccountInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput = {
    create?: XOR<WhitelistCreateWithoutTeamAccountInput, WhitelistUncheckedCreateWithoutTeamAccountInput>
    connectOrCreate?: WhitelistCreateOrConnectWithoutTeamAccountInput
    upsert?: WhitelistUpsertWithoutTeamAccountInput
    disconnect?: WhitelistWhereInput | boolean
    delete?: WhitelistWhereInput | boolean
    connect?: WhitelistWhereUniqueInput
    update?: XOR<XOR<WhitelistUpdateToOneWithWhereWithoutTeamAccountInput, WhitelistUpdateWithoutTeamAccountInput>, WhitelistUncheckedUpdateWithoutTeamAccountInput>
  }

  export type ContactCreatecontactEmailsInput = {
    set: string[]
  }

  export type TeamAccountCreateNestedOneWithoutContactsInput = {
    create?: XOR<TeamAccountCreateWithoutContactsInput, TeamAccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutContactsInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type EmailCreateNestedManyWithoutContactsInput = {
    create?: XOR<EmailCreateWithoutContactsInput, EmailUncheckedCreateWithoutContactsInput> | EmailCreateWithoutContactsInput[] | EmailUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactsInput | EmailCreateOrConnectWithoutContactsInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailThreadCreateNestedManyWithoutContactsInput = {
    create?: XOR<EmailThreadCreateWithoutContactsInput, EmailThreadUncheckedCreateWithoutContactsInput> | EmailThreadCreateWithoutContactsInput[] | EmailThreadUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutContactsInput | EmailThreadCreateOrConnectWithoutContactsInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type GithubTargetCreateNestedManyWithoutContactsInput = {
    create?: XOR<GithubTargetCreateWithoutContactsInput, GithubTargetUncheckedCreateWithoutContactsInput> | GithubTargetCreateWithoutContactsInput[] | GithubTargetUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutContactsInput | GithubTargetCreateOrConnectWithoutContactsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type ContactCreateemailIdsInput = {
    set: string[]
  }

  export type ContactCreateemailThreadIdsInput = {
    set: string[]
  }

  export type ContactCreatetargetIdsInput = {
    set: string[]
  }

  export type EmailUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<EmailCreateWithoutContactsInput, EmailUncheckedCreateWithoutContactsInput> | EmailCreateWithoutContactsInput[] | EmailUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactsInput | EmailCreateOrConnectWithoutContactsInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<EmailThreadCreateWithoutContactsInput, EmailThreadUncheckedCreateWithoutContactsInput> | EmailThreadCreateWithoutContactsInput[] | EmailThreadUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutContactsInput | EmailThreadCreateOrConnectWithoutContactsInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type GithubTargetUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<GithubTargetCreateWithoutContactsInput, GithubTargetUncheckedCreateWithoutContactsInput> | GithubTargetCreateWithoutContactsInput[] | GithubTargetUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutContactsInput | GithubTargetCreateOrConnectWithoutContactsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type ContactUpdatecontactEmailsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TeamAccountUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<TeamAccountCreateWithoutContactsInput, TeamAccountUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutContactsInput
    upsert?: TeamAccountUpsertWithoutContactsInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutContactsInput, TeamAccountUpdateWithoutContactsInput>, TeamAccountUncheckedUpdateWithoutContactsInput>
  }

  export type EmailUpdateManyWithoutContactsNestedInput = {
    create?: XOR<EmailCreateWithoutContactsInput, EmailUncheckedCreateWithoutContactsInput> | EmailCreateWithoutContactsInput[] | EmailUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactsInput | EmailCreateOrConnectWithoutContactsInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutContactsInput | EmailUpsertWithWhereUniqueWithoutContactsInput[]
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutContactsInput | EmailUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutContactsInput | EmailUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailThreadUpdateManyWithoutContactsNestedInput = {
    create?: XOR<EmailThreadCreateWithoutContactsInput, EmailThreadUncheckedCreateWithoutContactsInput> | EmailThreadCreateWithoutContactsInput[] | EmailThreadUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutContactsInput | EmailThreadCreateOrConnectWithoutContactsInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutContactsInput | EmailThreadUpsertWithWhereUniqueWithoutContactsInput[]
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutContactsInput | EmailThreadUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutContactsInput | EmailThreadUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type GithubTargetUpdateManyWithoutContactsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutContactsInput, GithubTargetUncheckedCreateWithoutContactsInput> | GithubTargetCreateWithoutContactsInput[] | GithubTargetUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutContactsInput | GithubTargetCreateOrConnectWithoutContactsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutContactsInput | GithubTargetUpsertWithWhereUniqueWithoutContactsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutContactsInput | GithubTargetUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutContactsInput | GithubTargetUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type ContactUpdateemailIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContactUpdateemailThreadIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContactUpdatetargetIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<EmailCreateWithoutContactsInput, EmailUncheckedCreateWithoutContactsInput> | EmailCreateWithoutContactsInput[] | EmailUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutContactsInput | EmailCreateOrConnectWithoutContactsInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutContactsInput | EmailUpsertWithWhereUniqueWithoutContactsInput[]
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutContactsInput | EmailUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutContactsInput | EmailUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<EmailThreadCreateWithoutContactsInput, EmailThreadUncheckedCreateWithoutContactsInput> | EmailThreadCreateWithoutContactsInput[] | EmailThreadUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutContactsInput | EmailThreadCreateOrConnectWithoutContactsInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutContactsInput | EmailThreadUpsertWithWhereUniqueWithoutContactsInput[]
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutContactsInput | EmailThreadUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutContactsInput | EmailThreadUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type GithubTargetUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutContactsInput, GithubTargetUncheckedCreateWithoutContactsInput> | GithubTargetCreateWithoutContactsInput[] | GithubTargetUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutContactsInput | GithubTargetCreateOrConnectWithoutContactsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutContactsInput | GithubTargetUpsertWithWhereUniqueWithoutContactsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutContactsInput | GithubTargetUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutContactsInput | GithubTargetUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type EmailCreatetoInput = {
    set: string[]
  }

  export type EmailCreatebccInput = {
    set: string[]
  }

  export type EmailCreateccInput = {
    set: string[]
  }

  export type ContactCreateNestedManyWithoutEmailsInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput> | ContactCreateWithoutEmailsInput[] | ContactUncheckedCreateWithoutEmailsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput | ContactCreateOrConnectWithoutEmailsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TeamAccountCreateNestedOneWithoutEmailsInput = {
    create?: XOR<TeamAccountCreateWithoutEmailsInput, TeamAccountUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutEmailsInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type EmailThreadCreateNestedOneWithoutEmailsInput = {
    create?: XOR<EmailThreadCreateWithoutEmailsInput, EmailThreadUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: EmailThreadCreateOrConnectWithoutEmailsInput
    connect?: EmailThreadWhereUniqueInput
  }

  export type EmailCreatecontactIdsInput = {
    set: string[]
  }

  export type ContactUncheckedCreateNestedManyWithoutEmailsInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput> | ContactCreateWithoutEmailsInput[] | ContactUncheckedCreateWithoutEmailsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput | ContactCreateOrConnectWithoutEmailsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type EmailUpdatetoInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdatebccInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUpdateccInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ContactUpdateManyWithoutEmailsNestedInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput> | ContactCreateWithoutEmailsInput[] | ContactUncheckedCreateWithoutEmailsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput | ContactCreateOrConnectWithoutEmailsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutEmailsInput | ContactUpsertWithWhereUniqueWithoutEmailsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutEmailsInput | ContactUpdateWithWhereUniqueWithoutEmailsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutEmailsInput | ContactUpdateManyWithWhereWithoutEmailsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TeamAccountUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<TeamAccountCreateWithoutEmailsInput, TeamAccountUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutEmailsInput
    upsert?: TeamAccountUpsertWithoutEmailsInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutEmailsInput, TeamAccountUpdateWithoutEmailsInput>, TeamAccountUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailThreadUpdateOneRequiredWithoutEmailsNestedInput = {
    create?: XOR<EmailThreadCreateWithoutEmailsInput, EmailThreadUncheckedCreateWithoutEmailsInput>
    connectOrCreate?: EmailThreadCreateOrConnectWithoutEmailsInput
    upsert?: EmailThreadUpsertWithoutEmailsInput
    connect?: EmailThreadWhereUniqueInput
    update?: XOR<XOR<EmailThreadUpdateToOneWithWhereWithoutEmailsInput, EmailThreadUpdateWithoutEmailsInput>, EmailThreadUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailUpdatecontactIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContactUncheckedUpdateManyWithoutEmailsNestedInput = {
    create?: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput> | ContactCreateWithoutEmailsInput[] | ContactUncheckedCreateWithoutEmailsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailsInput | ContactCreateOrConnectWithoutEmailsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutEmailsInput | ContactUpsertWithWhereUniqueWithoutEmailsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutEmailsInput | ContactUpdateWithWhereUniqueWithoutEmailsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutEmailsInput | ContactUpdateManyWithWhereWithoutEmailsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type EmailCreateNestedManyWithoutEmailThreadInput = {
    create?: XOR<EmailCreateWithoutEmailThreadInput, EmailUncheckedCreateWithoutEmailThreadInput> | EmailCreateWithoutEmailThreadInput[] | EmailUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailThreadInput | EmailCreateOrConnectWithoutEmailThreadInput[]
    createMany?: EmailCreateManyEmailThreadInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type TeamAccountCreateNestedOneWithoutEmailThreadsInput = {
    create?: XOR<TeamAccountCreateWithoutEmailThreadsInput, TeamAccountUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutEmailThreadsInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type ContactCreateNestedManyWithoutEmailThreadsInput = {
    create?: XOR<ContactCreateWithoutEmailThreadsInput, ContactUncheckedCreateWithoutEmailThreadsInput> | ContactCreateWithoutEmailThreadsInput[] | ContactUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailThreadsInput | ContactCreateOrConnectWithoutEmailThreadsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type GithubTargetCreateNestedManyWithoutEmailThreadsInput = {
    create?: XOR<GithubTargetCreateWithoutEmailThreadsInput, GithubTargetUncheckedCreateWithoutEmailThreadsInput> | GithubTargetCreateWithoutEmailThreadsInput[] | GithubTargetUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutEmailThreadsInput | GithubTargetCreateOrConnectWithoutEmailThreadsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type EmailThreadCreatecontactIdsInput = {
    set: string[]
  }

  export type EmailThreadCreatetargetIdsInput = {
    set: string[]
  }

  export type EmailUncheckedCreateNestedManyWithoutEmailThreadInput = {
    create?: XOR<EmailCreateWithoutEmailThreadInput, EmailUncheckedCreateWithoutEmailThreadInput> | EmailCreateWithoutEmailThreadInput[] | EmailUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailThreadInput | EmailCreateOrConnectWithoutEmailThreadInput[]
    createMany?: EmailCreateManyEmailThreadInputEnvelope
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutEmailThreadsInput = {
    create?: XOR<ContactCreateWithoutEmailThreadsInput, ContactUncheckedCreateWithoutEmailThreadsInput> | ContactCreateWithoutEmailThreadsInput[] | ContactUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailThreadsInput | ContactCreateOrConnectWithoutEmailThreadsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type GithubTargetUncheckedCreateNestedManyWithoutEmailThreadsInput = {
    create?: XOR<GithubTargetCreateWithoutEmailThreadsInput, GithubTargetUncheckedCreateWithoutEmailThreadsInput> | GithubTargetCreateWithoutEmailThreadsInput[] | GithubTargetUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutEmailThreadsInput | GithubTargetCreateOrConnectWithoutEmailThreadsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type EmailUpdateManyWithoutEmailThreadNestedInput = {
    create?: XOR<EmailCreateWithoutEmailThreadInput, EmailUncheckedCreateWithoutEmailThreadInput> | EmailCreateWithoutEmailThreadInput[] | EmailUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailThreadInput | EmailCreateOrConnectWithoutEmailThreadInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutEmailThreadInput | EmailUpsertWithWhereUniqueWithoutEmailThreadInput[]
    createMany?: EmailCreateManyEmailThreadInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutEmailThreadInput | EmailUpdateWithWhereUniqueWithoutEmailThreadInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutEmailThreadInput | EmailUpdateManyWithWhereWithoutEmailThreadInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type TeamAccountUpdateOneRequiredWithoutEmailThreadsNestedInput = {
    create?: XOR<TeamAccountCreateWithoutEmailThreadsInput, TeamAccountUncheckedCreateWithoutEmailThreadsInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutEmailThreadsInput
    upsert?: TeamAccountUpsertWithoutEmailThreadsInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutEmailThreadsInput, TeamAccountUpdateWithoutEmailThreadsInput>, TeamAccountUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type ContactUpdateManyWithoutEmailThreadsNestedInput = {
    create?: XOR<ContactCreateWithoutEmailThreadsInput, ContactUncheckedCreateWithoutEmailThreadsInput> | ContactCreateWithoutEmailThreadsInput[] | ContactUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailThreadsInput | ContactCreateOrConnectWithoutEmailThreadsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutEmailThreadsInput | ContactUpsertWithWhereUniqueWithoutEmailThreadsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutEmailThreadsInput | ContactUpdateWithWhereUniqueWithoutEmailThreadsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutEmailThreadsInput | ContactUpdateManyWithWhereWithoutEmailThreadsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type GithubTargetUpdateManyWithoutEmailThreadsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutEmailThreadsInput, GithubTargetUncheckedCreateWithoutEmailThreadsInput> | GithubTargetCreateWithoutEmailThreadsInput[] | GithubTargetUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutEmailThreadsInput | GithubTargetCreateOrConnectWithoutEmailThreadsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutEmailThreadsInput | GithubTargetUpsertWithWhereUniqueWithoutEmailThreadsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutEmailThreadsInput | GithubTargetUpdateWithWhereUniqueWithoutEmailThreadsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutEmailThreadsInput | GithubTargetUpdateManyWithWhereWithoutEmailThreadsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type EmailThreadUpdatecontactIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailThreadUpdatetargetIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmailUncheckedUpdateManyWithoutEmailThreadNestedInput = {
    create?: XOR<EmailCreateWithoutEmailThreadInput, EmailUncheckedCreateWithoutEmailThreadInput> | EmailCreateWithoutEmailThreadInput[] | EmailUncheckedCreateWithoutEmailThreadInput[]
    connectOrCreate?: EmailCreateOrConnectWithoutEmailThreadInput | EmailCreateOrConnectWithoutEmailThreadInput[]
    upsert?: EmailUpsertWithWhereUniqueWithoutEmailThreadInput | EmailUpsertWithWhereUniqueWithoutEmailThreadInput[]
    createMany?: EmailCreateManyEmailThreadInputEnvelope
    set?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    disconnect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    delete?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    connect?: EmailWhereUniqueInput | EmailWhereUniqueInput[]
    update?: EmailUpdateWithWhereUniqueWithoutEmailThreadInput | EmailUpdateWithWhereUniqueWithoutEmailThreadInput[]
    updateMany?: EmailUpdateManyWithWhereWithoutEmailThreadInput | EmailUpdateManyWithWhereWithoutEmailThreadInput[]
    deleteMany?: EmailScalarWhereInput | EmailScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutEmailThreadsNestedInput = {
    create?: XOR<ContactCreateWithoutEmailThreadsInput, ContactUncheckedCreateWithoutEmailThreadsInput> | ContactCreateWithoutEmailThreadsInput[] | ContactUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutEmailThreadsInput | ContactCreateOrConnectWithoutEmailThreadsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutEmailThreadsInput | ContactUpsertWithWhereUniqueWithoutEmailThreadsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutEmailThreadsInput | ContactUpdateWithWhereUniqueWithoutEmailThreadsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutEmailThreadsInput | ContactUpdateManyWithWhereWithoutEmailThreadsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type GithubTargetUncheckedUpdateManyWithoutEmailThreadsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutEmailThreadsInput, GithubTargetUncheckedCreateWithoutEmailThreadsInput> | GithubTargetCreateWithoutEmailThreadsInput[] | GithubTargetUncheckedCreateWithoutEmailThreadsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutEmailThreadsInput | GithubTargetCreateOrConnectWithoutEmailThreadsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutEmailThreadsInput | GithubTargetUpsertWithWhereUniqueWithoutEmailThreadsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutEmailThreadsInput | GithubTargetUpdateWithWhereUniqueWithoutEmailThreadsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutEmailThreadsInput | GithubTargetUpdateManyWithWhereWithoutEmailThreadsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type TeamAccountCreateNestedOneWithoutNotesInput = {
    create?: XOR<TeamAccountCreateWithoutNotesInput, TeamAccountUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutNotesInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotesInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    connect?: UserWhereUniqueInput
  }

  export type GithubTargetCreateNestedOneWithoutNotesInput = {
    create?: XOR<GithubTargetCreateWithoutNotesInput, GithubTargetUncheckedCreateWithoutNotesInput>
    connectOrCreate?: GithubTargetCreateOrConnectWithoutNotesInput
    connect?: GithubTargetWhereUniqueInput
  }

  export type TeamAccountUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<TeamAccountCreateWithoutNotesInput, TeamAccountUncheckedCreateWithoutNotesInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutNotesInput
    upsert?: TeamAccountUpsertWithoutNotesInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutNotesInput, TeamAccountUpdateWithoutNotesInput>, TeamAccountUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotesInput
    upsert?: UserUpsertWithoutNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotesInput, UserUpdateWithoutNotesInput>, UserUncheckedUpdateWithoutNotesInput>
  }

  export type GithubTargetUpdateOneWithoutNotesNestedInput = {
    create?: XOR<GithubTargetCreateWithoutNotesInput, GithubTargetUncheckedCreateWithoutNotesInput>
    connectOrCreate?: GithubTargetCreateOrConnectWithoutNotesInput
    upsert?: GithubTargetUpsertWithoutNotesInput
    disconnect?: boolean
    delete?: GithubTargetWhereInput | boolean
    connect?: GithubTargetWhereUniqueInput
    update?: XOR<XOR<GithubTargetUpdateToOneWithWhereWithoutNotesInput, GithubTargetUpdateWithoutNotesInput>, GithubTargetUncheckedUpdateWithoutNotesInput>
  }

  export type TargetScoutFilterNullableCreateEnvelopeInput = {
    set?: TargetScoutFilterCreateInput | null
  }

  export type TargetScoutFilterCreateInput = {
    repoOwners?: string | null
    repoCreatedDate?: string | null
    repoStars?: string | null
    repoForks?: string | null
    userLocation?: string | null
    userFollowers?: string | null
    userRepositories?: string | null
    userLanguages?: string | null
  }

  export type CampaignCreateNestedOneWithoutTargetScoutsInput = {
    create?: XOR<CampaignCreateWithoutTargetScoutsInput, CampaignUncheckedCreateWithoutTargetScoutsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTargetScoutsInput
    connect?: CampaignWhereUniqueInput
  }

  export type TargetScoutFilterNullableUpdateEnvelopeInput = {
    set?: TargetScoutFilterCreateInput | null
    upsert?: TargetScoutFilterUpsertInput
    unset?: boolean
  }

  export type CampaignUpdateOneRequiredWithoutTargetScoutsNestedInput = {
    create?: XOR<CampaignCreateWithoutTargetScoutsInput, CampaignUncheckedCreateWithoutTargetScoutsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTargetScoutsInput
    upsert?: CampaignUpsertWithoutTargetScoutsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTargetScoutsInput, CampaignUpdateWithoutTargetScoutsInput>, CampaignUncheckedUpdateWithoutTargetScoutsInput>
  }

  export type CampaignCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<CampaignCreateWithoutCustomFieldsInput, CampaignUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCustomFieldsInput
    connect?: CampaignWhereUniqueInput
  }

  export type CustomFieldValueCreateNestedManyWithoutCustomFieldInput = {
    create?: XOR<CustomFieldValueCreateWithoutCustomFieldInput, CustomFieldValueUncheckedCreateWithoutCustomFieldInput> | CustomFieldValueCreateWithoutCustomFieldInput[] | CustomFieldValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutCustomFieldInput | CustomFieldValueCreateOrConnectWithoutCustomFieldInput[]
    createMany?: CustomFieldValueCreateManyCustomFieldInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type CustomFieldValueUncheckedCreateNestedManyWithoutCustomFieldInput = {
    create?: XOR<CustomFieldValueCreateWithoutCustomFieldInput, CustomFieldValueUncheckedCreateWithoutCustomFieldInput> | CustomFieldValueCreateWithoutCustomFieldInput[] | CustomFieldValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutCustomFieldInput | CustomFieldValueCreateOrConnectWithoutCustomFieldInput[]
    createMany?: CustomFieldValueCreateManyCustomFieldInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<CampaignCreateWithoutCustomFieldsInput, CampaignUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutCustomFieldsInput
    upsert?: CampaignUpsertWithoutCustomFieldsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutCustomFieldsInput, CampaignUpdateWithoutCustomFieldsInput>, CampaignUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type CustomFieldValueUpdateManyWithoutCustomFieldNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutCustomFieldInput, CustomFieldValueUncheckedCreateWithoutCustomFieldInput> | CustomFieldValueCreateWithoutCustomFieldInput[] | CustomFieldValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutCustomFieldInput | CustomFieldValueCreateOrConnectWithoutCustomFieldInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutCustomFieldInput | CustomFieldValueUpsertWithWhereUniqueWithoutCustomFieldInput[]
    createMany?: CustomFieldValueCreateManyCustomFieldInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutCustomFieldInput | CustomFieldValueUpdateWithWhereUniqueWithoutCustomFieldInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutCustomFieldInput | CustomFieldValueUpdateManyWithWhereWithoutCustomFieldInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutCustomFieldNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutCustomFieldInput, CustomFieldValueUncheckedCreateWithoutCustomFieldInput> | CustomFieldValueCreateWithoutCustomFieldInput[] | CustomFieldValueUncheckedCreateWithoutCustomFieldInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutCustomFieldInput | CustomFieldValueCreateOrConnectWithoutCustomFieldInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutCustomFieldInput | CustomFieldValueUpsertWithWhereUniqueWithoutCustomFieldInput[]
    createMany?: CustomFieldValueCreateManyCustomFieldInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutCustomFieldInput | CustomFieldValueUpdateWithWhereUniqueWithoutCustomFieldInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutCustomFieldInput | CustomFieldValueUpdateManyWithWhereWithoutCustomFieldInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CustomFieldCreateNestedOneWithoutCustomFieldValuesInput = {
    create?: XOR<CustomFieldCreateWithoutCustomFieldValuesInput, CustomFieldUncheckedCreateWithoutCustomFieldValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutCustomFieldValuesInput
    connect?: CustomFieldWhereUniqueInput
  }

  export type TargetContactCreateNestedOneWithoutCustomFieldValueInput = {
    create?: XOR<TargetContactCreateWithoutCustomFieldValueInput, TargetContactUncheckedCreateWithoutCustomFieldValueInput>
    connectOrCreate?: TargetContactCreateOrConnectWithoutCustomFieldValueInput
    connect?: TargetContactWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CustomFieldUpdateOneWithoutCustomFieldValuesNestedInput = {
    create?: XOR<CustomFieldCreateWithoutCustomFieldValuesInput, CustomFieldUncheckedCreateWithoutCustomFieldValuesInput>
    connectOrCreate?: CustomFieldCreateOrConnectWithoutCustomFieldValuesInput
    upsert?: CustomFieldUpsertWithoutCustomFieldValuesInput
    disconnect?: boolean
    delete?: CustomFieldWhereInput | boolean
    connect?: CustomFieldWhereUniqueInput
    update?: XOR<XOR<CustomFieldUpdateToOneWithWhereWithoutCustomFieldValuesInput, CustomFieldUpdateWithoutCustomFieldValuesInput>, CustomFieldUncheckedUpdateWithoutCustomFieldValuesInput>
  }

  export type TargetContactUpdateOneRequiredWithoutCustomFieldValueNestedInput = {
    create?: XOR<TargetContactCreateWithoutCustomFieldValueInput, TargetContactUncheckedCreateWithoutCustomFieldValueInput>
    connectOrCreate?: TargetContactCreateOrConnectWithoutCustomFieldValueInput
    upsert?: TargetContactUpsertWithoutCustomFieldValueInput
    connect?: TargetContactWhereUniqueInput
    update?: XOR<XOR<TargetContactUpdateToOneWithWhereWithoutCustomFieldValueInput, TargetContactUpdateWithoutCustomFieldValueInput>, TargetContactUncheckedUpdateWithoutCustomFieldValueInput>
  }

  export type GithubTargetCreateNestedOneWithoutTargetContactsInput = {
    create?: XOR<GithubTargetCreateWithoutTargetContactsInput, GithubTargetUncheckedCreateWithoutTargetContactsInput>
    connectOrCreate?: GithubTargetCreateOrConnectWithoutTargetContactsInput
    connect?: GithubTargetWhereUniqueInput
  }

  export type TeamAccountCreateNestedOneWithoutTargetContactInput = {
    create?: XOR<TeamAccountCreateWithoutTargetContactInput, TeamAccountUncheckedCreateWithoutTargetContactInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutTargetContactInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutTargetContactsInput = {
    create?: XOR<CampaignCreateWithoutTargetContactsInput, CampaignUncheckedCreateWithoutTargetContactsInput> | CampaignCreateWithoutTargetContactsInput[] | CampaignUncheckedCreateWithoutTargetContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTargetContactsInput | CampaignCreateOrConnectWithoutTargetContactsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CustomFieldValueCreateNestedManyWithoutTargetContactInput = {
    create?: XOR<CustomFieldValueCreateWithoutTargetContactInput, CustomFieldValueUncheckedCreateWithoutTargetContactInput> | CustomFieldValueCreateWithoutTargetContactInput[] | CustomFieldValueUncheckedCreateWithoutTargetContactInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutTargetContactInput | CustomFieldValueCreateOrConnectWithoutTargetContactInput[]
    createMany?: CustomFieldValueCreateManyTargetContactInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type TargetContactCreatecampaignIdsInput = {
    set: string[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutTargetContactsInput = {
    create?: XOR<CampaignCreateWithoutTargetContactsInput, CampaignUncheckedCreateWithoutTargetContactsInput> | CampaignCreateWithoutTargetContactsInput[] | CampaignUncheckedCreateWithoutTargetContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTargetContactsInput | CampaignCreateOrConnectWithoutTargetContactsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CustomFieldValueUncheckedCreateNestedManyWithoutTargetContactInput = {
    create?: XOR<CustomFieldValueCreateWithoutTargetContactInput, CustomFieldValueUncheckedCreateWithoutTargetContactInput> | CustomFieldValueCreateWithoutTargetContactInput[] | CustomFieldValueUncheckedCreateWithoutTargetContactInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutTargetContactInput | CustomFieldValueCreateOrConnectWithoutTargetContactInput[]
    createMany?: CustomFieldValueCreateManyTargetContactInputEnvelope
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
  }

  export type GithubTargetUpdateOneWithoutTargetContactsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutTargetContactsInput, GithubTargetUncheckedCreateWithoutTargetContactsInput>
    connectOrCreate?: GithubTargetCreateOrConnectWithoutTargetContactsInput
    upsert?: GithubTargetUpsertWithoutTargetContactsInput
    disconnect?: boolean
    delete?: GithubTargetWhereInput | boolean
    connect?: GithubTargetWhereUniqueInput
    update?: XOR<XOR<GithubTargetUpdateToOneWithWhereWithoutTargetContactsInput, GithubTargetUpdateWithoutTargetContactsInput>, GithubTargetUncheckedUpdateWithoutTargetContactsInput>
  }

  export type TeamAccountUpdateOneRequiredWithoutTargetContactNestedInput = {
    create?: XOR<TeamAccountCreateWithoutTargetContactInput, TeamAccountUncheckedCreateWithoutTargetContactInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutTargetContactInput
    upsert?: TeamAccountUpsertWithoutTargetContactInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutTargetContactInput, TeamAccountUpdateWithoutTargetContactInput>, TeamAccountUncheckedUpdateWithoutTargetContactInput>
  }

  export type CampaignUpdateManyWithoutTargetContactsNestedInput = {
    create?: XOR<CampaignCreateWithoutTargetContactsInput, CampaignUncheckedCreateWithoutTargetContactsInput> | CampaignCreateWithoutTargetContactsInput[] | CampaignUncheckedCreateWithoutTargetContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTargetContactsInput | CampaignCreateOrConnectWithoutTargetContactsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTargetContactsInput | CampaignUpsertWithWhereUniqueWithoutTargetContactsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTargetContactsInput | CampaignUpdateWithWhereUniqueWithoutTargetContactsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTargetContactsInput | CampaignUpdateManyWithWhereWithoutTargetContactsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CustomFieldValueUpdateManyWithoutTargetContactNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutTargetContactInput, CustomFieldValueUncheckedCreateWithoutTargetContactInput> | CustomFieldValueCreateWithoutTargetContactInput[] | CustomFieldValueUncheckedCreateWithoutTargetContactInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutTargetContactInput | CustomFieldValueCreateOrConnectWithoutTargetContactInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutTargetContactInput | CustomFieldValueUpsertWithWhereUniqueWithoutTargetContactInput[]
    createMany?: CustomFieldValueCreateManyTargetContactInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutTargetContactInput | CustomFieldValueUpdateWithWhereUniqueWithoutTargetContactInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutTargetContactInput | CustomFieldValueUpdateManyWithWhereWithoutTargetContactInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type TargetContactUpdatecampaignIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUncheckedUpdateManyWithoutTargetContactsNestedInput = {
    create?: XOR<CampaignCreateWithoutTargetContactsInput, CampaignUncheckedCreateWithoutTargetContactsInput> | CampaignCreateWithoutTargetContactsInput[] | CampaignUncheckedCreateWithoutTargetContactsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutTargetContactsInput | CampaignCreateOrConnectWithoutTargetContactsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutTargetContactsInput | CampaignUpsertWithWhereUniqueWithoutTargetContactsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutTargetContactsInput | CampaignUpdateWithWhereUniqueWithoutTargetContactsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutTargetContactsInput | CampaignUpdateManyWithWhereWithoutTargetContactsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutTargetContactNestedInput = {
    create?: XOR<CustomFieldValueCreateWithoutTargetContactInput, CustomFieldValueUncheckedCreateWithoutTargetContactInput> | CustomFieldValueCreateWithoutTargetContactInput[] | CustomFieldValueUncheckedCreateWithoutTargetContactInput[]
    connectOrCreate?: CustomFieldValueCreateOrConnectWithoutTargetContactInput | CustomFieldValueCreateOrConnectWithoutTargetContactInput[]
    upsert?: CustomFieldValueUpsertWithWhereUniqueWithoutTargetContactInput | CustomFieldValueUpsertWithWhereUniqueWithoutTargetContactInput[]
    createMany?: CustomFieldValueCreateManyTargetContactInputEnvelope
    set?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    disconnect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    delete?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    connect?: CustomFieldValueWhereUniqueInput | CustomFieldValueWhereUniqueInput[]
    update?: CustomFieldValueUpdateWithWhereUniqueWithoutTargetContactInput | CustomFieldValueUpdateWithWhereUniqueWithoutTargetContactInput[]
    updateMany?: CustomFieldValueUpdateManyWithWhereWithoutTargetContactInput | CustomFieldValueUpdateManyWithWhereWithoutTargetContactInput[]
    deleteMany?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
  }

  export type CampaignCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<CampaignCreateWithoutGithubTargetsInput, CampaignUncheckedCreateWithoutGithubTargetsInput> | CampaignCreateWithoutGithubTargetsInput[] | CampaignUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGithubTargetsInput | CampaignCreateOrConnectWithoutGithubTargetsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<ReportCreateWithoutGithubTargetsInput, ReportUncheckedCreateWithoutGithubTargetsInput> | ReportCreateWithoutGithubTargetsInput[] | ReportUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGithubTargetsInput | ReportCreateOrConnectWithoutGithubTargetsInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutGithubTargetInput = {
    create?: XOR<EvaluationCreateWithoutGithubTargetInput, EvaluationUncheckedCreateWithoutGithubTargetInput> | EvaluationCreateWithoutGithubTargetInput[] | EvaluationUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutGithubTargetInput | EvaluationCreateOrConnectWithoutGithubTargetInput[]
    createMany?: EvaluationCreateManyGithubTargetInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<ContactCreateWithoutGithubTargetsInput, ContactUncheckedCreateWithoutGithubTargetsInput> | ContactCreateWithoutGithubTargetsInput[] | ContactUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutGithubTargetsInput | ContactCreateOrConnectWithoutGithubTargetsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TargetContactCreateNestedManyWithoutGithubTargetInput = {
    create?: XOR<TargetContactCreateWithoutGithubTargetInput, TargetContactUncheckedCreateWithoutGithubTargetInput> | TargetContactCreateWithoutGithubTargetInput[] | TargetContactUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutGithubTargetInput | TargetContactCreateOrConnectWithoutGithubTargetInput[]
    createMany?: TargetContactCreateManyGithubTargetInputEnvelope
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
  }

  export type NoteCreateNestedManyWithoutGithubTargetInput = {
    create?: XOR<NoteCreateWithoutGithubTargetInput, NoteUncheckedCreateWithoutGithubTargetInput> | NoteCreateWithoutGithubTargetInput[] | NoteUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGithubTargetInput | NoteCreateOrConnectWithoutGithubTargetInput[]
    createMany?: NoteCreateManyGithubTargetInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EmailThreadCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<EmailThreadCreateWithoutGithubTargetsInput, EmailThreadUncheckedCreateWithoutGithubTargetsInput> | EmailThreadCreateWithoutGithubTargetsInput[] | EmailThreadUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutGithubTargetsInput | EmailThreadCreateOrConnectWithoutGithubTargetsInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type GithubTargetCreatecampaignIdsInput = {
    set: string[]
  }

  export type GithubTargetCreatereportIdsInput = {
    set: string[]
  }

  export type GithubTargetCreatecontactIdsInput = {
    set: string[]
  }

  export type GithubTargetCreateemailThreadIdsInput = {
    set: string[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<CampaignCreateWithoutGithubTargetsInput, CampaignUncheckedCreateWithoutGithubTargetsInput> | CampaignCreateWithoutGithubTargetsInput[] | CampaignUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGithubTargetsInput | CampaignCreateOrConnectWithoutGithubTargetsInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<ReportCreateWithoutGithubTargetsInput, ReportUncheckedCreateWithoutGithubTargetsInput> | ReportCreateWithoutGithubTargetsInput[] | ReportUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGithubTargetsInput | ReportCreateOrConnectWithoutGithubTargetsInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput = {
    create?: XOR<EvaluationCreateWithoutGithubTargetInput, EvaluationUncheckedCreateWithoutGithubTargetInput> | EvaluationCreateWithoutGithubTargetInput[] | EvaluationUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutGithubTargetInput | EvaluationCreateOrConnectWithoutGithubTargetInput[]
    createMany?: EvaluationCreateManyGithubTargetInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<ContactCreateWithoutGithubTargetsInput, ContactUncheckedCreateWithoutGithubTargetsInput> | ContactCreateWithoutGithubTargetsInput[] | ContactUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutGithubTargetsInput | ContactCreateOrConnectWithoutGithubTargetsInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput = {
    create?: XOR<TargetContactCreateWithoutGithubTargetInput, TargetContactUncheckedCreateWithoutGithubTargetInput> | TargetContactCreateWithoutGithubTargetInput[] | TargetContactUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutGithubTargetInput | TargetContactCreateOrConnectWithoutGithubTargetInput[]
    createMany?: TargetContactCreateManyGithubTargetInputEnvelope
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
  }

  export type NoteUncheckedCreateNestedManyWithoutGithubTargetInput = {
    create?: XOR<NoteCreateWithoutGithubTargetInput, NoteUncheckedCreateWithoutGithubTargetInput> | NoteCreateWithoutGithubTargetInput[] | NoteUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGithubTargetInput | NoteCreateOrConnectWithoutGithubTargetInput[]
    createMany?: NoteCreateManyGithubTargetInputEnvelope
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
  }

  export type EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput = {
    create?: XOR<EmailThreadCreateWithoutGithubTargetsInput, EmailThreadUncheckedCreateWithoutGithubTargetsInput> | EmailThreadCreateWithoutGithubTargetsInput[] | EmailThreadUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutGithubTargetsInput | EmailThreadCreateOrConnectWithoutGithubTargetsInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
  }

  export type CampaignUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<CampaignCreateWithoutGithubTargetsInput, CampaignUncheckedCreateWithoutGithubTargetsInput> | CampaignCreateWithoutGithubTargetsInput[] | CampaignUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGithubTargetsInput | CampaignCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutGithubTargetsInput | CampaignUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutGithubTargetsInput | CampaignUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutGithubTargetsInput | CampaignUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<ReportCreateWithoutGithubTargetsInput, ReportUncheckedCreateWithoutGithubTargetsInput> | ReportCreateWithoutGithubTargetsInput[] | ReportUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGithubTargetsInput | ReportCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGithubTargetsInput | ReportUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGithubTargetsInput | ReportUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGithubTargetsInput | ReportUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutGithubTargetNestedInput = {
    create?: XOR<EvaluationCreateWithoutGithubTargetInput, EvaluationUncheckedCreateWithoutGithubTargetInput> | EvaluationCreateWithoutGithubTargetInput[] | EvaluationUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutGithubTargetInput | EvaluationCreateOrConnectWithoutGithubTargetInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutGithubTargetInput | EvaluationUpsertWithWhereUniqueWithoutGithubTargetInput[]
    createMany?: EvaluationCreateManyGithubTargetInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutGithubTargetInput | EvaluationUpdateWithWhereUniqueWithoutGithubTargetInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutGithubTargetInput | EvaluationUpdateManyWithWhereWithoutGithubTargetInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<ContactCreateWithoutGithubTargetsInput, ContactUncheckedCreateWithoutGithubTargetsInput> | ContactCreateWithoutGithubTargetsInput[] | ContactUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutGithubTargetsInput | ContactCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutGithubTargetsInput | ContactUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutGithubTargetsInput | ContactUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutGithubTargetsInput | ContactUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TargetContactUpdateManyWithoutGithubTargetNestedInput = {
    create?: XOR<TargetContactCreateWithoutGithubTargetInput, TargetContactUncheckedCreateWithoutGithubTargetInput> | TargetContactCreateWithoutGithubTargetInput[] | TargetContactUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutGithubTargetInput | TargetContactCreateOrConnectWithoutGithubTargetInput[]
    upsert?: TargetContactUpsertWithWhereUniqueWithoutGithubTargetInput | TargetContactUpsertWithWhereUniqueWithoutGithubTargetInput[]
    createMany?: TargetContactCreateManyGithubTargetInputEnvelope
    set?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    disconnect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    delete?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    update?: TargetContactUpdateWithWhereUniqueWithoutGithubTargetInput | TargetContactUpdateWithWhereUniqueWithoutGithubTargetInput[]
    updateMany?: TargetContactUpdateManyWithWhereWithoutGithubTargetInput | TargetContactUpdateManyWithWhereWithoutGithubTargetInput[]
    deleteMany?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
  }

  export type NoteUpdateManyWithoutGithubTargetNestedInput = {
    create?: XOR<NoteCreateWithoutGithubTargetInput, NoteUncheckedCreateWithoutGithubTargetInput> | NoteCreateWithoutGithubTargetInput[] | NoteUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGithubTargetInput | NoteCreateOrConnectWithoutGithubTargetInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutGithubTargetInput | NoteUpsertWithWhereUniqueWithoutGithubTargetInput[]
    createMany?: NoteCreateManyGithubTargetInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutGithubTargetInput | NoteUpdateWithWhereUniqueWithoutGithubTargetInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutGithubTargetInput | NoteUpdateManyWithWhereWithoutGithubTargetInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type EmailThreadUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<EmailThreadCreateWithoutGithubTargetsInput, EmailThreadUncheckedCreateWithoutGithubTargetsInput> | EmailThreadCreateWithoutGithubTargetsInput[] | EmailThreadUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutGithubTargetsInput | EmailThreadCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutGithubTargetsInput | EmailThreadUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutGithubTargetsInput | EmailThreadUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutGithubTargetsInput | EmailThreadUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type GithubTargetUpdatecampaignIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GithubTargetUpdatereportIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GithubTargetUpdatecontactIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GithubTargetUpdateemailThreadIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<CampaignCreateWithoutGithubTargetsInput, CampaignUncheckedCreateWithoutGithubTargetsInput> | CampaignCreateWithoutGithubTargetsInput[] | CampaignUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutGithubTargetsInput | CampaignCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutGithubTargetsInput | CampaignUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutGithubTargetsInput | CampaignUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutGithubTargetsInput | CampaignUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<ReportCreateWithoutGithubTargetsInput, ReportUncheckedCreateWithoutGithubTargetsInput> | ReportCreateWithoutGithubTargetsInput[] | ReportUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGithubTargetsInput | ReportCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGithubTargetsInput | ReportUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGithubTargetsInput | ReportUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGithubTargetsInput | ReportUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput = {
    create?: XOR<EvaluationCreateWithoutGithubTargetInput, EvaluationUncheckedCreateWithoutGithubTargetInput> | EvaluationCreateWithoutGithubTargetInput[] | EvaluationUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutGithubTargetInput | EvaluationCreateOrConnectWithoutGithubTargetInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutGithubTargetInput | EvaluationUpsertWithWhereUniqueWithoutGithubTargetInput[]
    createMany?: EvaluationCreateManyGithubTargetInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutGithubTargetInput | EvaluationUpdateWithWhereUniqueWithoutGithubTargetInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutGithubTargetInput | EvaluationUpdateManyWithWhereWithoutGithubTargetInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<ContactCreateWithoutGithubTargetsInput, ContactUncheckedCreateWithoutGithubTargetsInput> | ContactCreateWithoutGithubTargetsInput[] | ContactUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutGithubTargetsInput | ContactCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutGithubTargetsInput | ContactUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutGithubTargetsInput | ContactUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutGithubTargetsInput | ContactUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput = {
    create?: XOR<TargetContactCreateWithoutGithubTargetInput, TargetContactUncheckedCreateWithoutGithubTargetInput> | TargetContactCreateWithoutGithubTargetInput[] | TargetContactUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutGithubTargetInput | TargetContactCreateOrConnectWithoutGithubTargetInput[]
    upsert?: TargetContactUpsertWithWhereUniqueWithoutGithubTargetInput | TargetContactUpsertWithWhereUniqueWithoutGithubTargetInput[]
    createMany?: TargetContactCreateManyGithubTargetInputEnvelope
    set?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    disconnect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    delete?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    update?: TargetContactUpdateWithWhereUniqueWithoutGithubTargetInput | TargetContactUpdateWithWhereUniqueWithoutGithubTargetInput[]
    updateMany?: TargetContactUpdateManyWithWhereWithoutGithubTargetInput | TargetContactUpdateManyWithWhereWithoutGithubTargetInput[]
    deleteMany?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
  }

  export type NoteUncheckedUpdateManyWithoutGithubTargetNestedInput = {
    create?: XOR<NoteCreateWithoutGithubTargetInput, NoteUncheckedCreateWithoutGithubTargetInput> | NoteCreateWithoutGithubTargetInput[] | NoteUncheckedCreateWithoutGithubTargetInput[]
    connectOrCreate?: NoteCreateOrConnectWithoutGithubTargetInput | NoteCreateOrConnectWithoutGithubTargetInput[]
    upsert?: NoteUpsertWithWhereUniqueWithoutGithubTargetInput | NoteUpsertWithWhereUniqueWithoutGithubTargetInput[]
    createMany?: NoteCreateManyGithubTargetInputEnvelope
    set?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    disconnect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    delete?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    connect?: NoteWhereUniqueInput | NoteWhereUniqueInput[]
    update?: NoteUpdateWithWhereUniqueWithoutGithubTargetInput | NoteUpdateWithWhereUniqueWithoutGithubTargetInput[]
    updateMany?: NoteUpdateManyWithWhereWithoutGithubTargetInput | NoteUpdateManyWithWhereWithoutGithubTargetInput[]
    deleteMany?: NoteScalarWhereInput | NoteScalarWhereInput[]
  }

  export type EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput = {
    create?: XOR<EmailThreadCreateWithoutGithubTargetsInput, EmailThreadUncheckedCreateWithoutGithubTargetsInput> | EmailThreadCreateWithoutGithubTargetsInput[] | EmailThreadUncheckedCreateWithoutGithubTargetsInput[]
    connectOrCreate?: EmailThreadCreateOrConnectWithoutGithubTargetsInput | EmailThreadCreateOrConnectWithoutGithubTargetsInput[]
    upsert?: EmailThreadUpsertWithWhereUniqueWithoutGithubTargetsInput | EmailThreadUpsertWithWhereUniqueWithoutGithubTargetsInput[]
    set?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    disconnect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    delete?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    connect?: EmailThreadWhereUniqueInput | EmailThreadWhereUniqueInput[]
    update?: EmailThreadUpdateWithWhereUniqueWithoutGithubTargetsInput | EmailThreadUpdateWithWhereUniqueWithoutGithubTargetsInput[]
    updateMany?: EmailThreadUpdateManyWithWhereWithoutGithubTargetsInput | EmailThreadUpdateManyWithWhereWithoutGithubTargetsInput[]
    deleteMany?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
  }

  export type CampaignCreatetargetScoutIdsInput = {
    set: string[]
  }

  export type GithubTargetCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<GithubTargetCreateWithoutCampaignsInput, GithubTargetUncheckedCreateWithoutCampaignsInput> | GithubTargetCreateWithoutCampaignsInput[] | GithubTargetUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutCampaignsInput | GithubTargetCreateOrConnectWithoutCampaignsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type TeamAccountCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<TeamAccountCreateWithoutCampaignsInput, TeamAccountUncheckedCreateWithoutCampaignsInput> | TeamAccountCreateWithoutCampaignsInput[] | TeamAccountUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutCampaignsInput | TeamAccountCreateOrConnectWithoutCampaignsInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type TargetScoutCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TargetScoutCreateWithoutCampaignInput, TargetScoutUncheckedCreateWithoutCampaignInput> | TargetScoutCreateWithoutCampaignInput[] | TargetScoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetScoutCreateOrConnectWithoutCampaignInput | TargetScoutCreateOrConnectWithoutCampaignInput[]
    createMany?: TargetScoutCreateManyCampaignInputEnvelope
    connect?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
  }

  export type TrackerCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TrackerCreateWithoutCampaignInput, TrackerUncheckedCreateWithoutCampaignInput> | TrackerCreateWithoutCampaignInput[] | TrackerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TrackerCreateOrConnectWithoutCampaignInput | TrackerCreateOrConnectWithoutCampaignInput[]
    createMany?: TrackerCreateManyCampaignInputEnvelope
    connect?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
  }

  export type EvaluationCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EvaluationCreateWithoutCampaignInput, EvaluationUncheckedCreateWithoutCampaignInput> | EvaluationCreateWithoutCampaignInput[] | EvaluationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCampaignInput | EvaluationCreateOrConnectWithoutCampaignInput[]
    createMany?: EvaluationCreateManyCampaignInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type TargetContactCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<TargetContactCreateWithoutCampaignsInput, TargetContactUncheckedCreateWithoutCampaignsInput> | TargetContactCreateWithoutCampaignsInput[] | TargetContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutCampaignsInput | TargetContactCreateOrConnectWithoutCampaignsInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
  }

  export type CustomFieldCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomFieldCreateWithoutCampaignInput, CustomFieldUncheckedCreateWithoutCampaignInput> | CustomFieldCreateWithoutCampaignInput[] | CustomFieldUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutCampaignInput | CustomFieldCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomFieldCreateManyCampaignInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type CampaignCreatetargetIdsInput = {
    set: string[]
  }

  export type CampaignCreateteamAccountIdsInput = {
    set: string[]
  }

  export type CampaignCreatetargetContactIdsInput = {
    set: string[]
  }

  export type GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<GithubTargetCreateWithoutCampaignsInput, GithubTargetUncheckedCreateWithoutCampaignsInput> | GithubTargetCreateWithoutCampaignsInput[] | GithubTargetUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutCampaignsInput | GithubTargetCreateOrConnectWithoutCampaignsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<TeamAccountCreateWithoutCampaignsInput, TeamAccountUncheckedCreateWithoutCampaignsInput> | TeamAccountCreateWithoutCampaignsInput[] | TeamAccountUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutCampaignsInput | TeamAccountCreateOrConnectWithoutCampaignsInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
  }

  export type TargetScoutUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TargetScoutCreateWithoutCampaignInput, TargetScoutUncheckedCreateWithoutCampaignInput> | TargetScoutCreateWithoutCampaignInput[] | TargetScoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetScoutCreateOrConnectWithoutCampaignInput | TargetScoutCreateOrConnectWithoutCampaignInput[]
    createMany?: TargetScoutCreateManyCampaignInputEnvelope
    connect?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
  }

  export type TrackerUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TrackerCreateWithoutCampaignInput, TrackerUncheckedCreateWithoutCampaignInput> | TrackerCreateWithoutCampaignInput[] | TrackerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TrackerCreateOrConnectWithoutCampaignInput | TrackerCreateOrConnectWithoutCampaignInput[]
    createMany?: TrackerCreateManyCampaignInputEnvelope
    connect?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<EvaluationCreateWithoutCampaignInput, EvaluationUncheckedCreateWithoutCampaignInput> | EvaluationCreateWithoutCampaignInput[] | EvaluationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCampaignInput | EvaluationCreateOrConnectWithoutCampaignInput[]
    createMany?: EvaluationCreateManyCampaignInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type TargetContactUncheckedCreateNestedManyWithoutCampaignsInput = {
    create?: XOR<TargetContactCreateWithoutCampaignsInput, TargetContactUncheckedCreateWithoutCampaignsInput> | TargetContactCreateWithoutCampaignsInput[] | TargetContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutCampaignsInput | TargetContactCreateOrConnectWithoutCampaignsInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
  }

  export type CustomFieldUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CustomFieldCreateWithoutCampaignInput, CustomFieldUncheckedCreateWithoutCampaignInput> | CustomFieldCreateWithoutCampaignInput[] | CustomFieldUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutCampaignInput | CustomFieldCreateOrConnectWithoutCampaignInput[]
    createMany?: CustomFieldCreateManyCampaignInputEnvelope
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
  }

  export type CampaignUpdatetargetScoutIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type GithubTargetUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutCampaignsInput, GithubTargetUncheckedCreateWithoutCampaignsInput> | GithubTargetCreateWithoutCampaignsInput[] | GithubTargetUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutCampaignsInput | GithubTargetCreateOrConnectWithoutCampaignsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutCampaignsInput | GithubTargetUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutCampaignsInput | GithubTargetUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutCampaignsInput | GithubTargetUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type TeamAccountUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<TeamAccountCreateWithoutCampaignsInput, TeamAccountUncheckedCreateWithoutCampaignsInput> | TeamAccountCreateWithoutCampaignsInput[] | TeamAccountUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutCampaignsInput | TeamAccountCreateOrConnectWithoutCampaignsInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutCampaignsInput | TeamAccountUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutCampaignsInput | TeamAccountUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutCampaignsInput | TeamAccountUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type TargetScoutUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TargetScoutCreateWithoutCampaignInput, TargetScoutUncheckedCreateWithoutCampaignInput> | TargetScoutCreateWithoutCampaignInput[] | TargetScoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetScoutCreateOrConnectWithoutCampaignInput | TargetScoutCreateOrConnectWithoutCampaignInput[]
    upsert?: TargetScoutUpsertWithWhereUniqueWithoutCampaignInput | TargetScoutUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TargetScoutCreateManyCampaignInputEnvelope
    set?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    disconnect?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    delete?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    connect?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    update?: TargetScoutUpdateWithWhereUniqueWithoutCampaignInput | TargetScoutUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TargetScoutUpdateManyWithWhereWithoutCampaignInput | TargetScoutUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TargetScoutScalarWhereInput | TargetScoutScalarWhereInput[]
  }

  export type TrackerUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TrackerCreateWithoutCampaignInput, TrackerUncheckedCreateWithoutCampaignInput> | TrackerCreateWithoutCampaignInput[] | TrackerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TrackerCreateOrConnectWithoutCampaignInput | TrackerCreateOrConnectWithoutCampaignInput[]
    upsert?: TrackerUpsertWithWhereUniqueWithoutCampaignInput | TrackerUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TrackerCreateManyCampaignInputEnvelope
    set?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    disconnect?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    delete?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    connect?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    update?: TrackerUpdateWithWhereUniqueWithoutCampaignInput | TrackerUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TrackerUpdateManyWithWhereWithoutCampaignInput | TrackerUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TrackerScalarWhereInput | TrackerScalarWhereInput[]
  }

  export type EvaluationUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EvaluationCreateWithoutCampaignInput, EvaluationUncheckedCreateWithoutCampaignInput> | EvaluationCreateWithoutCampaignInput[] | EvaluationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCampaignInput | EvaluationCreateOrConnectWithoutCampaignInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCampaignInput | EvaluationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EvaluationCreateManyCampaignInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCampaignInput | EvaluationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCampaignInput | EvaluationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type TargetContactUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<TargetContactCreateWithoutCampaignsInput, TargetContactUncheckedCreateWithoutCampaignsInput> | TargetContactCreateWithoutCampaignsInput[] | TargetContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutCampaignsInput | TargetContactCreateOrConnectWithoutCampaignsInput[]
    upsert?: TargetContactUpsertWithWhereUniqueWithoutCampaignsInput | TargetContactUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    disconnect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    delete?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    update?: TargetContactUpdateWithWhereUniqueWithoutCampaignsInput | TargetContactUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: TargetContactUpdateManyWithWhereWithoutCampaignsInput | TargetContactUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
  }

  export type CustomFieldUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomFieldCreateWithoutCampaignInput, CustomFieldUncheckedCreateWithoutCampaignInput> | CustomFieldCreateWithoutCampaignInput[] | CustomFieldUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutCampaignInput | CustomFieldCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutCampaignInput | CustomFieldUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomFieldCreateManyCampaignInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutCampaignInput | CustomFieldUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutCampaignInput | CustomFieldUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type CampaignUpdatetargetIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdateteamAccountIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdatetargetContactIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutCampaignsInput, GithubTargetUncheckedCreateWithoutCampaignsInput> | GithubTargetCreateWithoutCampaignsInput[] | GithubTargetUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutCampaignsInput | GithubTargetCreateOrConnectWithoutCampaignsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutCampaignsInput | GithubTargetUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutCampaignsInput | GithubTargetUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutCampaignsInput | GithubTargetUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<TeamAccountCreateWithoutCampaignsInput, TeamAccountUncheckedCreateWithoutCampaignsInput> | TeamAccountCreateWithoutCampaignsInput[] | TeamAccountUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TeamAccountCreateOrConnectWithoutCampaignsInput | TeamAccountCreateOrConnectWithoutCampaignsInput[]
    upsert?: TeamAccountUpsertWithWhereUniqueWithoutCampaignsInput | TeamAccountUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    disconnect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    delete?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    connect?: TeamAccountWhereUniqueInput | TeamAccountWhereUniqueInput[]
    update?: TeamAccountUpdateWithWhereUniqueWithoutCampaignsInput | TeamAccountUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: TeamAccountUpdateManyWithWhereWithoutCampaignsInput | TeamAccountUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
  }

  export type TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TargetScoutCreateWithoutCampaignInput, TargetScoutUncheckedCreateWithoutCampaignInput> | TargetScoutCreateWithoutCampaignInput[] | TargetScoutUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TargetScoutCreateOrConnectWithoutCampaignInput | TargetScoutCreateOrConnectWithoutCampaignInput[]
    upsert?: TargetScoutUpsertWithWhereUniqueWithoutCampaignInput | TargetScoutUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TargetScoutCreateManyCampaignInputEnvelope
    set?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    disconnect?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    delete?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    connect?: TargetScoutWhereUniqueInput | TargetScoutWhereUniqueInput[]
    update?: TargetScoutUpdateWithWhereUniqueWithoutCampaignInput | TargetScoutUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TargetScoutUpdateManyWithWhereWithoutCampaignInput | TargetScoutUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TargetScoutScalarWhereInput | TargetScoutScalarWhereInput[]
  }

  export type TrackerUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TrackerCreateWithoutCampaignInput, TrackerUncheckedCreateWithoutCampaignInput> | TrackerCreateWithoutCampaignInput[] | TrackerUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TrackerCreateOrConnectWithoutCampaignInput | TrackerCreateOrConnectWithoutCampaignInput[]
    upsert?: TrackerUpsertWithWhereUniqueWithoutCampaignInput | TrackerUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TrackerCreateManyCampaignInputEnvelope
    set?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    disconnect?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    delete?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    connect?: TrackerWhereUniqueInput | TrackerWhereUniqueInput[]
    update?: TrackerUpdateWithWhereUniqueWithoutCampaignInput | TrackerUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TrackerUpdateManyWithWhereWithoutCampaignInput | TrackerUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TrackerScalarWhereInput | TrackerScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<EvaluationCreateWithoutCampaignInput, EvaluationUncheckedCreateWithoutCampaignInput> | EvaluationCreateWithoutCampaignInput[] | EvaluationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutCampaignInput | EvaluationCreateOrConnectWithoutCampaignInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutCampaignInput | EvaluationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: EvaluationCreateManyCampaignInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutCampaignInput | EvaluationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutCampaignInput | EvaluationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput = {
    create?: XOR<TargetContactCreateWithoutCampaignsInput, TargetContactUncheckedCreateWithoutCampaignsInput> | TargetContactCreateWithoutCampaignsInput[] | TargetContactUncheckedCreateWithoutCampaignsInput[]
    connectOrCreate?: TargetContactCreateOrConnectWithoutCampaignsInput | TargetContactCreateOrConnectWithoutCampaignsInput[]
    upsert?: TargetContactUpsertWithWhereUniqueWithoutCampaignsInput | TargetContactUpsertWithWhereUniqueWithoutCampaignsInput[]
    set?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    disconnect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    delete?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    connect?: TargetContactWhereUniqueInput | TargetContactWhereUniqueInput[]
    update?: TargetContactUpdateWithWhereUniqueWithoutCampaignsInput | TargetContactUpdateWithWhereUniqueWithoutCampaignsInput[]
    updateMany?: TargetContactUpdateManyWithWhereWithoutCampaignsInput | TargetContactUpdateManyWithWhereWithoutCampaignsInput[]
    deleteMany?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
  }

  export type CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CustomFieldCreateWithoutCampaignInput, CustomFieldUncheckedCreateWithoutCampaignInput> | CustomFieldCreateWithoutCampaignInput[] | CustomFieldUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CustomFieldCreateOrConnectWithoutCampaignInput | CustomFieldCreateOrConnectWithoutCampaignInput[]
    upsert?: CustomFieldUpsertWithWhereUniqueWithoutCampaignInput | CustomFieldUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CustomFieldCreateManyCampaignInputEnvelope
    set?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    disconnect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    delete?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    connect?: CustomFieldWhereUniqueInput | CustomFieldWhereUniqueInput[]
    update?: CustomFieldUpdateWithWhereUniqueWithoutCampaignInput | CustomFieldUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CustomFieldUpdateManyWithWhereWithoutCampaignInput | CustomFieldUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
  }

  export type TrackerCreatedependenciesInput = {
    set: string[]
  }

  export type TrackerCreatedefaultFileNamesInput = {
    set: string[]
  }

  export type TrackerCreatecustomFileNamesInput = {
    set: string[]
  }

  export type CampaignCreateNestedOneWithoutTrackersInput = {
    create?: XOR<CampaignCreateWithoutTrackersInput, CampaignUncheckedCreateWithoutTrackersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTrackersInput
    connect?: CampaignWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutTrackerInput = {
    create?: XOR<EvaluationCreateWithoutTrackerInput, EvaluationUncheckedCreateWithoutTrackerInput> | EvaluationCreateWithoutTrackerInput[] | EvaluationUncheckedCreateWithoutTrackerInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTrackerInput | EvaluationCreateOrConnectWithoutTrackerInput[]
    createMany?: EvaluationCreateManyTrackerInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type EvaluationUncheckedCreateNestedManyWithoutTrackerInput = {
    create?: XOR<EvaluationCreateWithoutTrackerInput, EvaluationUncheckedCreateWithoutTrackerInput> | EvaluationCreateWithoutTrackerInput[] | EvaluationUncheckedCreateWithoutTrackerInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTrackerInput | EvaluationCreateOrConnectWithoutTrackerInput[]
    createMany?: EvaluationCreateManyTrackerInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type TrackerUpdatedependenciesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TrackerUpdatedefaultFileNamesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TrackerUpdatecustomFileNamesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CampaignUpdateOneRequiredWithoutTrackersNestedInput = {
    create?: XOR<CampaignCreateWithoutTrackersInput, CampaignUncheckedCreateWithoutTrackersInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTrackersInput
    upsert?: CampaignUpsertWithoutTrackersInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTrackersInput, CampaignUpdateWithoutTrackersInput>, CampaignUncheckedUpdateWithoutTrackersInput>
  }

  export type EvaluationUpdateManyWithoutTrackerNestedInput = {
    create?: XOR<EvaluationCreateWithoutTrackerInput, EvaluationUncheckedCreateWithoutTrackerInput> | EvaluationCreateWithoutTrackerInput[] | EvaluationUncheckedCreateWithoutTrackerInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTrackerInput | EvaluationCreateOrConnectWithoutTrackerInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutTrackerInput | EvaluationUpsertWithWhereUniqueWithoutTrackerInput[]
    createMany?: EvaluationCreateManyTrackerInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutTrackerInput | EvaluationUpdateWithWhereUniqueWithoutTrackerInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutTrackerInput | EvaluationUpdateManyWithWhereWithoutTrackerInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type EvaluationUncheckedUpdateManyWithoutTrackerNestedInput = {
    create?: XOR<EvaluationCreateWithoutTrackerInput, EvaluationUncheckedCreateWithoutTrackerInput> | EvaluationCreateWithoutTrackerInput[] | EvaluationUncheckedCreateWithoutTrackerInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutTrackerInput | EvaluationCreateOrConnectWithoutTrackerInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutTrackerInput | EvaluationUpsertWithWhereUniqueWithoutTrackerInput[]
    createMany?: EvaluationCreateManyTrackerInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutTrackerInput | EvaluationUpdateWithWhereUniqueWithoutTrackerInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutTrackerInput | EvaluationUpdateManyWithWhereWithoutTrackerInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<CampaignCreateWithoutEvaluationInput, CampaignUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEvaluationInput
    connect?: CampaignWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<AccountCreateWithoutEvaluationInput, AccountUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEvaluationInput
    connect?: AccountWhereUniqueInput
  }

  export type TeamAccountCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<TeamAccountCreateWithoutEvaluationInput, TeamAccountUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutEvaluationInput
    connect?: TeamAccountWhereUniqueInput
  }

  export type GithubTargetCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<GithubTargetCreateWithoutEvaluationsInput, GithubTargetUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: GithubTargetCreateOrConnectWithoutEvaluationsInput
    connect?: GithubTargetWhereUniqueInput
  }

  export type EvaluationCreateNestedOneWithoutChildrenInput = {
    create?: XOR<EvaluationCreateWithoutChildrenInput, EvaluationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutChildrenInput
    connect?: EvaluationWhereUniqueInput
  }

  export type EvaluationCreateNestedManyWithoutParentInput = {
    create?: XOR<EvaluationCreateWithoutParentInput, EvaluationUncheckedCreateWithoutParentInput> | EvaluationCreateWithoutParentInput[] | EvaluationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutParentInput | EvaluationCreateOrConnectWithoutParentInput[]
    createMany?: EvaluationCreateManyParentInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type TrackerCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<TrackerCreateWithoutEvaluationsInput, TrackerUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: TrackerCreateOrConnectWithoutEvaluationsInput
    connect?: TrackerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<UserCreateWithoutEvaluationInput, UserUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationInput
    connect?: UserWhereUniqueInput
  }

  export type EvaluationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<EvaluationCreateWithoutParentInput, EvaluationUncheckedCreateWithoutParentInput> | EvaluationCreateWithoutParentInput[] | EvaluationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutParentInput | EvaluationCreateOrConnectWithoutParentInput[]
    createMany?: EvaluationCreateManyParentInputEnvelope
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutEvaluationNestedInput = {
    create?: XOR<CampaignCreateWithoutEvaluationInput, CampaignUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutEvaluationInput
    upsert?: CampaignUpsertWithoutEvaluationInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutEvaluationInput, CampaignUpdateWithoutEvaluationInput>, CampaignUncheckedUpdateWithoutEvaluationInput>
  }

  export type AccountUpdateOneRequiredWithoutEvaluationNestedInput = {
    create?: XOR<AccountCreateWithoutEvaluationInput, AccountUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEvaluationInput
    upsert?: AccountUpsertWithoutEvaluationInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutEvaluationInput, AccountUpdateWithoutEvaluationInput>, AccountUncheckedUpdateWithoutEvaluationInput>
  }

  export type TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput = {
    create?: XOR<TeamAccountCreateWithoutEvaluationInput, TeamAccountUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: TeamAccountCreateOrConnectWithoutEvaluationInput
    upsert?: TeamAccountUpsertWithoutEvaluationInput
    connect?: TeamAccountWhereUniqueInput
    update?: XOR<XOR<TeamAccountUpdateToOneWithWhereWithoutEvaluationInput, TeamAccountUpdateWithoutEvaluationInput>, TeamAccountUncheckedUpdateWithoutEvaluationInput>
  }

  export type GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutEvaluationsInput, GithubTargetUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: GithubTargetCreateOrConnectWithoutEvaluationsInput
    upsert?: GithubTargetUpsertWithoutEvaluationsInput
    connect?: GithubTargetWhereUniqueInput
    update?: XOR<XOR<GithubTargetUpdateToOneWithWhereWithoutEvaluationsInput, GithubTargetUpdateWithoutEvaluationsInput>, GithubTargetUncheckedUpdateWithoutEvaluationsInput>
  }

  export type EvaluationUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<EvaluationCreateWithoutChildrenInput, EvaluationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: EvaluationCreateOrConnectWithoutChildrenInput
    upsert?: EvaluationUpsertWithoutChildrenInput
    disconnect?: boolean
    delete?: EvaluationWhereInput | boolean
    connect?: EvaluationWhereUniqueInput
    update?: XOR<XOR<EvaluationUpdateToOneWithWhereWithoutChildrenInput, EvaluationUpdateWithoutChildrenInput>, EvaluationUncheckedUpdateWithoutChildrenInput>
  }

  export type EvaluationUpdateManyWithoutParentNestedInput = {
    create?: XOR<EvaluationCreateWithoutParentInput, EvaluationUncheckedCreateWithoutParentInput> | EvaluationCreateWithoutParentInput[] | EvaluationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutParentInput | EvaluationCreateOrConnectWithoutParentInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutParentInput | EvaluationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EvaluationCreateManyParentInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutParentInput | EvaluationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutParentInput | EvaluationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type TrackerUpdateOneWithoutEvaluationsNestedInput = {
    create?: XOR<TrackerCreateWithoutEvaluationsInput, TrackerUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: TrackerCreateOrConnectWithoutEvaluationsInput
    upsert?: TrackerUpsertWithoutEvaluationsInput
    disconnect?: boolean
    delete?: TrackerWhereInput | boolean
    connect?: TrackerWhereUniqueInput
    update?: XOR<XOR<TrackerUpdateToOneWithWhereWithoutEvaluationsInput, TrackerUpdateWithoutEvaluationsInput>, TrackerUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserUpdateOneWithoutEvaluationNestedInput = {
    create?: XOR<UserCreateWithoutEvaluationInput, UserUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationInput
    upsert?: UserUpsertWithoutEvaluationInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvaluationInput, UserUpdateWithoutEvaluationInput>, UserUncheckedUpdateWithoutEvaluationInput>
  }

  export type EvaluationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<EvaluationCreateWithoutParentInput, EvaluationUncheckedCreateWithoutParentInput> | EvaluationCreateWithoutParentInput[] | EvaluationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EvaluationCreateOrConnectWithoutParentInput | EvaluationCreateOrConnectWithoutParentInput[]
    upsert?: EvaluationUpsertWithWhereUniqueWithoutParentInput | EvaluationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EvaluationCreateManyParentInputEnvelope
    set?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    disconnect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    delete?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    connect?: EvaluationWhereUniqueInput | EvaluationWhereUniqueInput[]
    update?: EvaluationUpdateWithWhereUniqueWithoutParentInput | EvaluationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EvaluationUpdateManyWithWhereWithoutParentInput | EvaluationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
  }

  export type GithubTargetCreateNestedManyWithoutReportsInput = {
    create?: XOR<GithubTargetCreateWithoutReportsInput, GithubTargetUncheckedCreateWithoutReportsInput> | GithubTargetCreateWithoutReportsInput[] | GithubTargetUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutReportsInput | GithubTargetCreateOrConnectWithoutReportsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type ReportCreatetargetIdsInput = {
    set: string[]
  }

  export type GithubTargetUncheckedCreateNestedManyWithoutReportsInput = {
    create?: XOR<GithubTargetCreateWithoutReportsInput, GithubTargetUncheckedCreateWithoutReportsInput> | GithubTargetCreateWithoutReportsInput[] | GithubTargetUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutReportsInput | GithubTargetCreateOrConnectWithoutReportsInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
  }

  export type GithubTargetUpdateManyWithoutReportsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutReportsInput, GithubTargetUncheckedCreateWithoutReportsInput> | GithubTargetCreateWithoutReportsInput[] | GithubTargetUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutReportsInput | GithubTargetCreateOrConnectWithoutReportsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutReportsInput | GithubTargetUpsertWithWhereUniqueWithoutReportsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutReportsInput | GithubTargetUpdateWithWhereUniqueWithoutReportsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutReportsInput | GithubTargetUpdateManyWithWhereWithoutReportsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type ReportUpdatetargetIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type GithubTargetUncheckedUpdateManyWithoutReportsNestedInput = {
    create?: XOR<GithubTargetCreateWithoutReportsInput, GithubTargetUncheckedCreateWithoutReportsInput> | GithubTargetCreateWithoutReportsInput[] | GithubTargetUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: GithubTargetCreateOrConnectWithoutReportsInput | GithubTargetCreateOrConnectWithoutReportsInput[]
    upsert?: GithubTargetUpsertWithWhereUniqueWithoutReportsInput | GithubTargetUpsertWithWhereUniqueWithoutReportsInput[]
    set?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    disconnect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    delete?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    connect?: GithubTargetWhereUniqueInput | GithubTargetWhereUniqueInput[]
    update?: GithubTargetUpdateWithWhereUniqueWithoutReportsInput | GithubTargetUpdateWithWhereUniqueWithoutReportsInput[]
    updateMany?: GithubTargetUpdateManyWithWhereWithoutReportsInput | GithubTargetUpdateManyWithWhereWithoutReportsInput[]
    deleteMany?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
  }

  export type GithubRepositoryBranchListCreateEnvelopeInput = {
    set?: GithubRepositoryBranchCreateInput | GithubRepositoryBranchCreateInput[]
  }

  export type GithubRepositoryBranchCreateInput = {
    name: string
    isDefault: boolean
    commits?: GithubRepositoryCommitCreateInput | GithubRepositoryCommitCreateInput[]
  }

  export type GithubRepositoryBranchListUpdateEnvelopeInput = {
    set?: GithubRepositoryBranchCreateInput | GithubRepositoryBranchCreateInput[]
    push?: GithubRepositoryBranchCreateInput | GithubRepositoryBranchCreateInput[]
    updateMany?: GithubRepositoryBranchUpdateManyInput
    deleteMany?: GithubRepositoryBranchDeleteManyInput
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TargetScoutFilterWhereInput = {
    AND?: TargetScoutFilterWhereInput | TargetScoutFilterWhereInput[]
    OR?: TargetScoutFilterWhereInput[]
    NOT?: TargetScoutFilterWhereInput | TargetScoutFilterWhereInput[]
    repoOwners?: StringNullableFilter<"TargetScoutFilter"> | string | null
    repoCreatedDate?: StringNullableFilter<"TargetScoutFilter"> | string | null
    repoStars?: StringNullableFilter<"TargetScoutFilter"> | string | null
    repoForks?: StringNullableFilter<"TargetScoutFilter"> | string | null
    userLocation?: StringNullableFilter<"TargetScoutFilter"> | string | null
    userFollowers?: StringNullableFilter<"TargetScoutFilter"> | string | null
    userRepositories?: StringNullableFilter<"TargetScoutFilter"> | string | null
    userLanguages?: StringNullableFilter<"TargetScoutFilter"> | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type GithubRepositoryBranchWhereInput = {
    AND?: GithubRepositoryBranchWhereInput | GithubRepositoryBranchWhereInput[]
    OR?: GithubRepositoryBranchWhereInput[]
    NOT?: GithubRepositoryBranchWhereInput | GithubRepositoryBranchWhereInput[]
    name?: StringFilter<"GithubRepositoryBranch"> | string
    isDefault?: BoolFilter<"GithubRepositoryBranch"> | boolean
    commits?: GithubRepositoryCommitCompositeListFilter | GithubRepositoryCommitObjectEqualityInput[]
  }

  export type GithubRepositoryCommitObjectEqualityInput = {
    hash: string
    date: string
    message: string
    additions: number
    deletions: number
    filesChanged: number
    authorName: string
    authorEmail: string
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type EvaluationCreateWithoutAccountInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutAccountInput = {
    id?: string
    campaignId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutAccountInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutAccountInput, EvaluationUncheckedCreateWithoutAccountInput>
  }

  export type EvaluationCreateManyAccountInputEnvelope = {
    data: EvaluationCreateManyAccountInput | EvaluationCreateManyAccountInput[]
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutAccountInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutAccountInput, EvaluationUncheckedUpdateWithoutAccountInput>
    create: XOR<EvaluationCreateWithoutAccountInput, EvaluationUncheckedCreateWithoutAccountInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutAccountInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutAccountInput, EvaluationUncheckedUpdateWithoutAccountInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutAccountInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutAccountInput>
  }

  export type EvaluationScalarWhereInput = {
    AND?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    OR?: EvaluationScalarWhereInput[]
    NOT?: EvaluationScalarWhereInput | EvaluationScalarWhereInput[]
    id?: StringFilter<"Evaluation"> | string
    campaignId?: StringFilter<"Evaluation"> | string
    accountId?: StringFilter<"Evaluation"> | string
    teamAccountId?: StringFilter<"Evaluation"> | string
    githubTargetId?: StringFilter<"Evaluation"> | string
    type?: StringFilter<"Evaluation"> | string
    params?: JsonNullableFilter<"Evaluation">
    query?: StringNullableFilter<"Evaluation"> | string | null
    queryVariables?: JsonNullableFilter<"Evaluation">
    paginators?: JsonNullableFilter<"Evaluation">
    maxPerPage?: IntFilter<"Evaluation"> | number
    dataId?: StringNullableFilter<"Evaluation"> | string | null
    result?: JsonNullableFilter<"Evaluation">
    status?: StringFilter<"Evaluation"> | string
    error?: StringNullableFilter<"Evaluation"> | string | null
    parentId?: StringNullableFilter<"Evaluation"> | string | null
    createdAt?: DateTimeFilter<"Evaluation"> | Date | string
    updatedAt?: DateTimeFilter<"Evaluation"> | Date | string
    trackerId?: StringNullableFilter<"Evaluation"> | string | null
    userId?: StringNullableFilter<"Evaluation"> | string | null
  }

  export type TeamAccountCreateWithoutWhitelistInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
  }

  export type TeamAccountUncheckedCreateWithoutWhitelistInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutWhitelistInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutWhitelistInput, TeamAccountUncheckedCreateWithoutWhitelistInput>
  }

  export type TeamAccountUpsertWithoutWhitelistInput = {
    update: XOR<TeamAccountUpdateWithoutWhitelistInput, TeamAccountUncheckedUpdateWithoutWhitelistInput>
    create: XOR<TeamAccountCreateWithoutWhitelistInput, TeamAccountUncheckedCreateWithoutWhitelistInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutWhitelistInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutWhitelistInput, TeamAccountUncheckedUpdateWithoutWhitelistInput>
  }

  export type TeamAccountUpdateWithoutWhitelistInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutWhitelistInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    Evaluation?: EvaluationCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    Evaluation?: EvaluationUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type TeamAccountCreateWithoutOwnersInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutOwnersInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutOwnersInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutOwnersInput, TeamAccountUncheckedCreateWithoutOwnersInput>
  }

  export type TeamAccountCreateWithoutTeamAccountUsersInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutTeamAccountUsersInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutTeamAccountUsersInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutTeamAccountUsersInput, TeamAccountUncheckedCreateWithoutTeamAccountUsersInput>
  }

  export type NoteCreateWithoutTeamAccountUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: string
    text: string
    teamAccount: TeamAccountCreateNestedOneWithoutNotesInput
    githubTarget?: GithubTargetCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutTeamAccountUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccountId: string
    subject?: string
    text: string
    githubTargetId?: string | null
  }

  export type NoteCreateOrConnectWithoutTeamAccountUserInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutTeamAccountUserInput, NoteUncheckedCreateWithoutTeamAccountUserInput>
  }

  export type NoteCreateManyTeamAccountUserInputEnvelope = {
    data: NoteCreateManyTeamAccountUserInput | NoteCreateManyTeamAccountUserInput[]
  }

  export type EvaluationCreateWithoutUserInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
  }

  export type EvaluationUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutUserInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutUserInput, EvaluationUncheckedCreateWithoutUserInput>
  }

  export type EvaluationCreateManyUserInputEnvelope = {
    data: EvaluationCreateManyUserInput | EvaluationCreateManyUserInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    refresh_token_expires_in?: IntNullableFilter<"Account"> | number | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type TeamAccountUpsertWithWhereUniqueWithoutOwnersInput = {
    where: TeamAccountWhereUniqueInput
    update: XOR<TeamAccountUpdateWithoutOwnersInput, TeamAccountUncheckedUpdateWithoutOwnersInput>
    create: XOR<TeamAccountCreateWithoutOwnersInput, TeamAccountUncheckedCreateWithoutOwnersInput>
  }

  export type TeamAccountUpdateWithWhereUniqueWithoutOwnersInput = {
    where: TeamAccountWhereUniqueInput
    data: XOR<TeamAccountUpdateWithoutOwnersInput, TeamAccountUncheckedUpdateWithoutOwnersInput>
  }

  export type TeamAccountUpdateManyWithWhereWithoutOwnersInput = {
    where: TeamAccountScalarWhereInput
    data: XOR<TeamAccountUpdateManyMutationInput, TeamAccountUncheckedUpdateManyWithoutOwnersInput>
  }

  export type TeamAccountScalarWhereInput = {
    AND?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
    OR?: TeamAccountScalarWhereInput[]
    NOT?: TeamAccountScalarWhereInput | TeamAccountScalarWhereInput[]
    id?: StringFilter<"TeamAccount"> | string
    name?: StringFilter<"TeamAccount"> | string
    aliasEmail?: StringFilter<"TeamAccount"> | string
    verifiedEmailAddresses?: StringNullableListFilter<"TeamAccount">
    teamAccountUserIds?: StringNullableListFilter<"TeamAccount">
    ownerIds?: StringNullableListFilter<"TeamAccount">
    campaignIds?: StringNullableListFilter<"TeamAccount">
    subscriptionId?: StringNullableFilter<"TeamAccount"> | string | null
  }

  export type TeamAccountUpsertWithWhereUniqueWithoutTeamAccountUsersInput = {
    where: TeamAccountWhereUniqueInput
    update: XOR<TeamAccountUpdateWithoutTeamAccountUsersInput, TeamAccountUncheckedUpdateWithoutTeamAccountUsersInput>
    create: XOR<TeamAccountCreateWithoutTeamAccountUsersInput, TeamAccountUncheckedCreateWithoutTeamAccountUsersInput>
  }

  export type TeamAccountUpdateWithWhereUniqueWithoutTeamAccountUsersInput = {
    where: TeamAccountWhereUniqueInput
    data: XOR<TeamAccountUpdateWithoutTeamAccountUsersInput, TeamAccountUncheckedUpdateWithoutTeamAccountUsersInput>
  }

  export type TeamAccountUpdateManyWithWhereWithoutTeamAccountUsersInput = {
    where: TeamAccountScalarWhereInput
    data: XOR<TeamAccountUpdateManyMutationInput, TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutTeamAccountUserInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutTeamAccountUserInput, NoteUncheckedUpdateWithoutTeamAccountUserInput>
    create: XOR<NoteCreateWithoutTeamAccountUserInput, NoteUncheckedCreateWithoutTeamAccountUserInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutTeamAccountUserInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutTeamAccountUserInput, NoteUncheckedUpdateWithoutTeamAccountUserInput>
  }

  export type NoteUpdateManyWithWhereWithoutTeamAccountUserInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutTeamAccountUserInput>
  }

  export type NoteScalarWhereInput = {
    AND?: NoteScalarWhereInput | NoteScalarWhereInput[]
    OR?: NoteScalarWhereInput[]
    NOT?: NoteScalarWhereInput | NoteScalarWhereInput[]
    id?: StringFilter<"Note"> | string
    createdAt?: DateTimeFilter<"Note"> | Date | string
    updatedAt?: DateTimeFilter<"Note"> | Date | string
    teamAccountId?: StringFilter<"Note"> | string
    subject?: StringFilter<"Note"> | string
    text?: StringFilter<"Note"> | string
    teamAccountUserId?: StringFilter<"Note"> | string
    githubTargetId?: StringNullableFilter<"Note"> | string | null
  }

  export type EvaluationUpsertWithWhereUniqueWithoutUserInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutUserInput, EvaluationUncheckedUpdateWithoutUserInput>
    create: XOR<EvaluationCreateWithoutUserInput, EvaluationUncheckedCreateWithoutUserInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutUserInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutUserInput, EvaluationUncheckedUpdateWithoutUserInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutUserInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamAccountCreateWithoutInviteCodesInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutInviteCodesInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutInviteCodesInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutInviteCodesInput, TeamAccountUncheckedCreateWithoutInviteCodesInput>
  }

  export type TeamAccountUpsertWithoutInviteCodesInput = {
    update: XOR<TeamAccountUpdateWithoutInviteCodesInput, TeamAccountUncheckedUpdateWithoutInviteCodesInput>
    create: XOR<TeamAccountCreateWithoutInviteCodesInput, TeamAccountUncheckedCreateWithoutInviteCodesInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutInviteCodesInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutInviteCodesInput, TeamAccountUncheckedUpdateWithoutInviteCodesInput>
  }

  export type TeamAccountUpdateWithoutInviteCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutInviteCodesInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutSubscriptionInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutSubscriptionInput, TeamAccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type TeamAccountCreateManySubscriptionInputEnvelope = {
    data: TeamAccountCreateManySubscriptionInput | TeamAccountCreateManySubscriptionInput[]
  }

  export type TeamAccountUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: TeamAccountWhereUniqueInput
    update: XOR<TeamAccountUpdateWithoutSubscriptionInput, TeamAccountUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<TeamAccountCreateWithoutSubscriptionInput, TeamAccountUncheckedCreateWithoutSubscriptionInput>
  }

  export type TeamAccountUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: TeamAccountWhereUniqueInput
    data: XOR<TeamAccountUpdateWithoutSubscriptionInput, TeamAccountUncheckedUpdateWithoutSubscriptionInput>
  }

  export type TeamAccountUpdateManyWithWhereWithoutSubscriptionInput = {
    where: TeamAccountScalarWhereInput
    data: XOR<TeamAccountUpdateManyMutationInput, TeamAccountUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type OneTimeCodesCreateWithoutTeamAccountInput = {
    id?: string
    code: string
    expires: Date | string
    type?: string
    email: string
    createdAt?: Date | string
  }

  export type OneTimeCodesUncheckedCreateWithoutTeamAccountInput = {
    id?: string
    code: string
    expires: Date | string
    type?: string
    email: string
    createdAt?: Date | string
  }

  export type OneTimeCodesCreateOrConnectWithoutTeamAccountInput = {
    where: OneTimeCodesWhereUniqueInput
    create: XOR<OneTimeCodesCreateWithoutTeamAccountInput, OneTimeCodesUncheckedCreateWithoutTeamAccountInput>
  }

  export type OneTimeCodesCreateManyTeamAccountInputEnvelope = {
    data: OneTimeCodesCreateManyTeamAccountInput | OneTimeCodesCreateManyTeamAccountInput[]
  }

  export type UserCreateWithoutTeamAccountsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountCreateNestedManyWithoutOwnersInput
    notes?: NoteCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamAccountsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutOwnersInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamAccountsInput, UserUncheckedCreateWithoutTeamAccountsInput>
  }

  export type ContactCreateWithoutCreatingTeamAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    emails?: EmailCreateNestedManyWithoutContactsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutCreatingTeamAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutContactsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactCreateOrConnectWithoutCreatingTeamAccountInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCreatingTeamAccountInput, ContactUncheckedCreateWithoutCreatingTeamAccountInput>
  }

  export type ContactCreateManyCreatingTeamAccountInputEnvelope = {
    data: ContactCreateManyCreatingTeamAccountInput | ContactCreateManyCreatingTeamAccountInput[]
  }

  export type EmailCreateWithoutTeamAccountInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    messageId: string
    contacts?: ContactCreateNestedManyWithoutEmailsInput
    emailThread: EmailThreadCreateNestedOneWithoutEmailsInput
  }

  export type EmailUncheckedCreateWithoutTeamAccountInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    messageId: string
    emailThreadId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailsInput
  }

  export type EmailCreateOrConnectWithoutTeamAccountInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutTeamAccountInput, EmailUncheckedCreateWithoutTeamAccountInput>
  }

  export type EmailCreateManyTeamAccountInputEnvelope = {
    data: EmailCreateManyTeamAccountInput | EmailCreateManyTeamAccountInput[]
  }

  export type UserCreateWithoutOwnedTeamAccountsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOwnedTeamAccountsInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOwnedTeamAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedTeamAccountsInput, UserUncheckedCreateWithoutOwnedTeamAccountsInput>
  }

  export type EmailThreadCreateWithoutTeamAccountInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailCreateNestedManyWithoutEmailThreadInput
    contacts?: ContactCreateNestedManyWithoutEmailThreadsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadUncheckedCreateWithoutTeamAccountInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutEmailThreadInput
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailThreadsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadCreateOrConnectWithoutTeamAccountInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutTeamAccountInput, EmailThreadUncheckedCreateWithoutTeamAccountInput>
  }

  export type EmailThreadCreateManyTeamAccountInputEnvelope = {
    data: EmailThreadCreateManyTeamAccountInput | EmailThreadCreateManyTeamAccountInput[]
  }

  export type CampaignCreateWithoutTeamAccountsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTeamAccountsInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTeamAccountsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTeamAccountsInput, CampaignUncheckedCreateWithoutTeamAccountsInput>
  }

  export type NoteCreateWithoutTeamAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: string
    text: string
    teamAccountUser: UserCreateNestedOneWithoutNotesInput
    githubTarget?: GithubTargetCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutTeamAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: string
    text: string
    teamAccountUserId: string
    githubTargetId?: string | null
  }

  export type NoteCreateOrConnectWithoutTeamAccountInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutTeamAccountInput, NoteUncheckedCreateWithoutTeamAccountInput>
  }

  export type NoteCreateManyTeamAccountInputEnvelope = {
    data: NoteCreateManyTeamAccountInput | NoteCreateManyTeamAccountInput[]
  }

  export type TargetContactCreateWithoutTeamAccountInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    githubTarget?: GithubTargetCreateNestedOneWithoutTargetContactsInput
    campaigns?: CampaignCreateNestedManyWithoutTargetContactsInput
    customFieldValue?: CustomFieldValueCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactUncheckedCreateWithoutTeamAccountInput = {
    id?: string
    githubTargetId?: string | null
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTargetContactsInput
    customFieldValue?: CustomFieldValueUncheckedCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactCreateOrConnectWithoutTeamAccountInput = {
    where: TargetContactWhereUniqueInput
    create: XOR<TargetContactCreateWithoutTeamAccountInput, TargetContactUncheckedCreateWithoutTeamAccountInput>
  }

  export type TargetContactCreateManyTeamAccountInputEnvelope = {
    data: TargetContactCreateManyTeamAccountInput | TargetContactCreateManyTeamAccountInput[]
  }

  export type EvaluationCreateWithoutTeamAccountInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutTeamAccountInput = {
    id?: string
    campaignId: string
    accountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutTeamAccountInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutTeamAccountInput, EvaluationUncheckedCreateWithoutTeamAccountInput>
  }

  export type EvaluationCreateManyTeamAccountInputEnvelope = {
    data: EvaluationCreateManyTeamAccountInput | EvaluationCreateManyTeamAccountInput[]
  }

  export type SubscriptionCreateWithoutTeamAccountsInput = {
    id?: string
    featureList?: SubscriptionCreatefeatureListInput | string[]
  }

  export type SubscriptionUncheckedCreateWithoutTeamAccountsInput = {
    id?: string
    featureList?: SubscriptionCreatefeatureListInput | string[]
  }

  export type SubscriptionCreateOrConnectWithoutTeamAccountsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutTeamAccountsInput, SubscriptionUncheckedCreateWithoutTeamAccountsInput>
  }

  export type WhitelistCreateWithoutTeamAccountInput = {
    id?: string
    githubName: string
    quantity?: number
    createdAt?: Date | string | null
  }

  export type WhitelistUncheckedCreateWithoutTeamAccountInput = {
    id?: string
    githubName: string
    quantity?: number
    createdAt?: Date | string | null
  }

  export type WhitelistCreateOrConnectWithoutTeamAccountInput = {
    where: WhitelistWhereUniqueInput
    create: XOR<WhitelistCreateWithoutTeamAccountInput, WhitelistUncheckedCreateWithoutTeamAccountInput>
  }

  export type OneTimeCodesUpsertWithWhereUniqueWithoutTeamAccountInput = {
    where: OneTimeCodesWhereUniqueInput
    update: XOR<OneTimeCodesUpdateWithoutTeamAccountInput, OneTimeCodesUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<OneTimeCodesCreateWithoutTeamAccountInput, OneTimeCodesUncheckedCreateWithoutTeamAccountInput>
  }

  export type OneTimeCodesUpdateWithWhereUniqueWithoutTeamAccountInput = {
    where: OneTimeCodesWhereUniqueInput
    data: XOR<OneTimeCodesUpdateWithoutTeamAccountInput, OneTimeCodesUncheckedUpdateWithoutTeamAccountInput>
  }

  export type OneTimeCodesUpdateManyWithWhereWithoutTeamAccountInput = {
    where: OneTimeCodesScalarWhereInput
    data: XOR<OneTimeCodesUpdateManyMutationInput, OneTimeCodesUncheckedUpdateManyWithoutTeamAccountInput>
  }

  export type OneTimeCodesScalarWhereInput = {
    AND?: OneTimeCodesScalarWhereInput | OneTimeCodesScalarWhereInput[]
    OR?: OneTimeCodesScalarWhereInput[]
    NOT?: OneTimeCodesScalarWhereInput | OneTimeCodesScalarWhereInput[]
    id?: StringFilter<"OneTimeCodes"> | string
    code?: StringFilter<"OneTimeCodes"> | string
    expires?: DateTimeFilter<"OneTimeCodes"> | Date | string
    type?: StringFilter<"OneTimeCodes"> | string
    email?: StringFilter<"OneTimeCodes"> | string
    createdAt?: DateTimeFilter<"OneTimeCodes"> | Date | string
    teamAccountId?: StringFilter<"OneTimeCodes"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutTeamAccountsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamAccountsInput, UserUncheckedUpdateWithoutTeamAccountsInput>
    create: XOR<UserCreateWithoutTeamAccountsInput, UserUncheckedCreateWithoutTeamAccountsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamAccountsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamAccountsInput, UserUncheckedUpdateWithoutTeamAccountsInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamAccountsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTeamAccountsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    contactEmail?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    lastSeen?: DateTimeFilter<"User"> | Date | string
    ownedTeamAccountIds?: StringNullableListFilter<"User">
    teamAccountIds?: StringNullableListFilter<"User">
  }

  export type ContactUpsertWithWhereUniqueWithoutCreatingTeamAccountInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutCreatingTeamAccountInput, ContactUncheckedUpdateWithoutCreatingTeamAccountInput>
    create: XOR<ContactCreateWithoutCreatingTeamAccountInput, ContactUncheckedCreateWithoutCreatingTeamAccountInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutCreatingTeamAccountInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutCreatingTeamAccountInput, ContactUncheckedUpdateWithoutCreatingTeamAccountInput>
  }

  export type ContactUpdateManyWithWhereWithoutCreatingTeamAccountInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutCreatingTeamAccountInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    name?: StringFilter<"Contact"> | string
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    email?: StringNullableFilter<"Contact"> | string | null
    contactEmails?: StringNullableListFilter<"Contact">
    teamAccountId?: StringFilter<"Contact"> | string
    emailIds?: StringNullableListFilter<"Contact">
    emailThreadIds?: StringNullableListFilter<"Contact">
    targetIds?: StringNullableListFilter<"Contact">
  }

  export type EmailUpsertWithWhereUniqueWithoutTeamAccountInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutTeamAccountInput, EmailUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<EmailCreateWithoutTeamAccountInput, EmailUncheckedCreateWithoutTeamAccountInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutTeamAccountInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutTeamAccountInput, EmailUncheckedUpdateWithoutTeamAccountInput>
  }

  export type EmailUpdateManyWithWhereWithoutTeamAccountInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutTeamAccountInput>
  }

  export type EmailScalarWhereInput = {
    AND?: EmailScalarWhereInput | EmailScalarWhereInput[]
    OR?: EmailScalarWhereInput[]
    NOT?: EmailScalarWhereInput | EmailScalarWhereInput[]
    id?: StringFilter<"Email"> | string
    to?: StringNullableListFilter<"Email">
    bcc?: StringNullableListFilter<"Email">
    cc?: StringNullableListFilter<"Email">
    from?: StringFilter<"Email"> | string
    subject?: StringFilter<"Email"> | string
    text?: StringFilter<"Email"> | string
    sentByUser?: BoolFilter<"Email"> | boolean
    sentAt?: DateTimeFilter<"Email"> | Date | string
    contactIds?: StringNullableListFilter<"Email">
    teamAccountId?: StringFilter<"Email"> | string
    messageId?: StringFilter<"Email"> | string
    emailThreadId?: StringFilter<"Email"> | string
  }

  export type UserUpsertWithWhereUniqueWithoutOwnedTeamAccountsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOwnedTeamAccountsInput, UserUncheckedUpdateWithoutOwnedTeamAccountsInput>
    create: XOR<UserCreateWithoutOwnedTeamAccountsInput, UserUncheckedCreateWithoutOwnedTeamAccountsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOwnedTeamAccountsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOwnedTeamAccountsInput, UserUncheckedUpdateWithoutOwnedTeamAccountsInput>
  }

  export type UserUpdateManyWithWhereWithoutOwnedTeamAccountsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOwnedTeamAccountsInput>
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutTeamAccountInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutTeamAccountInput, EmailThreadUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<EmailThreadCreateWithoutTeamAccountInput, EmailThreadUncheckedCreateWithoutTeamAccountInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutTeamAccountInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutTeamAccountInput, EmailThreadUncheckedUpdateWithoutTeamAccountInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutTeamAccountInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutTeamAccountInput>
  }

  export type EmailThreadScalarWhereInput = {
    AND?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
    OR?: EmailThreadScalarWhereInput[]
    NOT?: EmailThreadScalarWhereInput | EmailThreadScalarWhereInput[]
    id?: StringFilter<"EmailThread"> | string
    createdAt?: DateTimeFilter<"EmailThread"> | Date | string
    updatedAt?: DateTimeFilter<"EmailThread"> | Date | string
    contactIds?: StringNullableListFilter<"EmailThread">
    teamAccountId?: StringFilter<"EmailThread"> | string
    targetIds?: StringNullableListFilter<"EmailThread">
  }

  export type CampaignUpsertWithWhereUniqueWithoutTeamAccountsInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTeamAccountsInput, CampaignUncheckedUpdateWithoutTeamAccountsInput>
    create: XOR<CampaignCreateWithoutTeamAccountsInput, CampaignUncheckedCreateWithoutTeamAccountsInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTeamAccountsInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTeamAccountsInput, CampaignUncheckedUpdateWithoutTeamAccountsInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTeamAccountsInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTeamAccountsInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    targetIds?: StringNullableListFilter<"Campaign">
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    dependenciesInfo?: JsonNullableFilter<"Campaign">
    teamAccountIds?: StringNullableListFilter<"Campaign">
    targetScoutIds?: StringNullableListFilter<"Campaign">
    budget?: IntFilter<"Campaign"> | number
    lightMode?: BoolNullableFilter<"Campaign"> | boolean | null
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    targetContactIds?: StringNullableListFilter<"Campaign">
    archived?: BoolFilter<"Campaign"> | boolean
    archivedAt?: DateTimeNullableFilter<"Campaign"> | Date | string | null
  }

  export type NoteUpsertWithWhereUniqueWithoutTeamAccountInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutTeamAccountInput, NoteUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<NoteCreateWithoutTeamAccountInput, NoteUncheckedCreateWithoutTeamAccountInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutTeamAccountInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutTeamAccountInput, NoteUncheckedUpdateWithoutTeamAccountInput>
  }

  export type NoteUpdateManyWithWhereWithoutTeamAccountInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutTeamAccountInput>
  }

  export type TargetContactUpsertWithWhereUniqueWithoutTeamAccountInput = {
    where: TargetContactWhereUniqueInput
    update: XOR<TargetContactUpdateWithoutTeamAccountInput, TargetContactUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<TargetContactCreateWithoutTeamAccountInput, TargetContactUncheckedCreateWithoutTeamAccountInput>
  }

  export type TargetContactUpdateWithWhereUniqueWithoutTeamAccountInput = {
    where: TargetContactWhereUniqueInput
    data: XOR<TargetContactUpdateWithoutTeamAccountInput, TargetContactUncheckedUpdateWithoutTeamAccountInput>
  }

  export type TargetContactUpdateManyWithWhereWithoutTeamAccountInput = {
    where: TargetContactScalarWhereInput
    data: XOR<TargetContactUpdateManyMutationInput, TargetContactUncheckedUpdateManyWithoutTeamAccountInput>
  }

  export type TargetContactScalarWhereInput = {
    AND?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
    OR?: TargetContactScalarWhereInput[]
    NOT?: TargetContactScalarWhereInput | TargetContactScalarWhereInput[]
    id?: StringFilter<"TargetContact"> | string
    githubTargetId?: StringNullableFilter<"TargetContact"> | string | null
    industry?: StringNullableFilter<"TargetContact"> | string | null
    projectOwner?: StringNullableFilter<"TargetContact"> | string | null
    projectName?: StringNullableFilter<"TargetContact"> | string | null
    type?: StringFilter<"TargetContact"> | string
    location?: StringNullableFilter<"TargetContact"> | string | null
    teamAccountId?: StringFilter<"TargetContact"> | string
    status?: StringNullableFilter<"TargetContact"> | string | null
    campaignIds?: StringNullableListFilter<"TargetContact">
  }

  export type EvaluationUpsertWithWhereUniqueWithoutTeamAccountInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutTeamAccountInput, EvaluationUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<EvaluationCreateWithoutTeamAccountInput, EvaluationUncheckedCreateWithoutTeamAccountInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutTeamAccountInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutTeamAccountInput, EvaluationUncheckedUpdateWithoutTeamAccountInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutTeamAccountInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutTeamAccountInput>
  }

  export type SubscriptionUpsertWithoutTeamAccountsInput = {
    update: XOR<SubscriptionUpdateWithoutTeamAccountsInput, SubscriptionUncheckedUpdateWithoutTeamAccountsInput>
    create: XOR<SubscriptionCreateWithoutTeamAccountsInput, SubscriptionUncheckedCreateWithoutTeamAccountsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutTeamAccountsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutTeamAccountsInput, SubscriptionUncheckedUpdateWithoutTeamAccountsInput>
  }

  export type SubscriptionUpdateWithoutTeamAccountsInput = {
    featureList?: SubscriptionUpdatefeatureListInput | string[]
  }

  export type SubscriptionUncheckedUpdateWithoutTeamAccountsInput = {
    featureList?: SubscriptionUpdatefeatureListInput | string[]
  }

  export type WhitelistUpsertWithoutTeamAccountInput = {
    update: XOR<WhitelistUpdateWithoutTeamAccountInput, WhitelistUncheckedUpdateWithoutTeamAccountInput>
    create: XOR<WhitelistCreateWithoutTeamAccountInput, WhitelistUncheckedCreateWithoutTeamAccountInput>
    where?: WhitelistWhereInput
  }

  export type WhitelistUpdateToOneWithWhereWithoutTeamAccountInput = {
    where?: WhitelistWhereInput
    data: XOR<WhitelistUpdateWithoutTeamAccountInput, WhitelistUncheckedUpdateWithoutTeamAccountInput>
  }

  export type WhitelistUpdateWithoutTeamAccountInput = {
    githubName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhitelistUncheckedUpdateWithoutTeamAccountInput = {
    githubName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamAccountCreateWithoutContactsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutContactsInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutContactsInput, TeamAccountUncheckedCreateWithoutContactsInput>
  }

  export type EmailCreateWithoutContactsInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    messageId: string
    teamAccount: TeamAccountCreateNestedOneWithoutEmailsInput
    emailThread: EmailThreadCreateNestedOneWithoutEmailsInput
  }

  export type EmailUncheckedCreateWithoutContactsInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    teamAccountId: string
    messageId: string
    emailThreadId: string
  }

  export type EmailCreateOrConnectWithoutContactsInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutContactsInput, EmailUncheckedCreateWithoutContactsInput>
  }

  export type EmailThreadCreateWithoutContactsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailCreateNestedManyWithoutEmailThreadInput
    teamAccount: TeamAccountCreateNestedOneWithoutEmailThreadsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadUncheckedCreateWithoutContactsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    teamAccountId: string
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutEmailThreadInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadCreateOrConnectWithoutContactsInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutContactsInput, EmailThreadUncheckedCreateWithoutContactsInput>
  }

  export type GithubTargetCreateWithoutContactsInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateWithoutContactsInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetCreateOrConnectWithoutContactsInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutContactsInput, GithubTargetUncheckedCreateWithoutContactsInput>
  }

  export type TeamAccountUpsertWithoutContactsInput = {
    update: XOR<TeamAccountUpdateWithoutContactsInput, TeamAccountUncheckedUpdateWithoutContactsInput>
    create: XOR<TeamAccountCreateWithoutContactsInput, TeamAccountUncheckedCreateWithoutContactsInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutContactsInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutContactsInput, TeamAccountUncheckedUpdateWithoutContactsInput>
  }

  export type TeamAccountUpdateWithoutContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type EmailUpsertWithWhereUniqueWithoutContactsInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutContactsInput, EmailUncheckedUpdateWithoutContactsInput>
    create: XOR<EmailCreateWithoutContactsInput, EmailUncheckedCreateWithoutContactsInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutContactsInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutContactsInput, EmailUncheckedUpdateWithoutContactsInput>
  }

  export type EmailUpdateManyWithWhereWithoutContactsInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutContactsInput>
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutContactsInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutContactsInput, EmailThreadUncheckedUpdateWithoutContactsInput>
    create: XOR<EmailThreadCreateWithoutContactsInput, EmailThreadUncheckedCreateWithoutContactsInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutContactsInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutContactsInput, EmailThreadUncheckedUpdateWithoutContactsInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutContactsInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutContactsInput>
  }

  export type GithubTargetUpsertWithWhereUniqueWithoutContactsInput = {
    where: GithubTargetWhereUniqueInput
    update: XOR<GithubTargetUpdateWithoutContactsInput, GithubTargetUncheckedUpdateWithoutContactsInput>
    create: XOR<GithubTargetCreateWithoutContactsInput, GithubTargetUncheckedCreateWithoutContactsInput>
  }

  export type GithubTargetUpdateWithWhereUniqueWithoutContactsInput = {
    where: GithubTargetWhereUniqueInput
    data: XOR<GithubTargetUpdateWithoutContactsInput, GithubTargetUncheckedUpdateWithoutContactsInput>
  }

  export type GithubTargetUpdateManyWithWhereWithoutContactsInput = {
    where: GithubTargetScalarWhereInput
    data: XOR<GithubTargetUpdateManyMutationInput, GithubTargetUncheckedUpdateManyWithoutContactsInput>
  }

  export type GithubTargetScalarWhereInput = {
    AND?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
    OR?: GithubTargetScalarWhereInput[]
    NOT?: GithubTargetScalarWhereInput | GithubTargetScalarWhereInput[]
    id?: StringFilter<"GithubTarget"> | string
    githubGraphqlId?: StringFilter<"GithubTarget"> | string
    campaignIds?: StringNullableListFilter<"GithubTarget">
    reportIds?: StringNullableListFilter<"GithubTarget">
    type?: StringFilter<"GithubTarget"> | string
    metadata?: JsonFilter<"GithubTarget">
    displayName?: StringFilter<"GithubTarget"> | string
    createdAt?: DateTimeFilter<"GithubTarget"> | Date | string
    updatedAt?: DateTimeFilter<"GithubTarget"> | Date | string
    contactIds?: StringNullableListFilter<"GithubTarget">
    emailThreadIds?: StringNullableListFilter<"GithubTarget">
  }

  export type ContactCreateWithoutEmailsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    creatingTeamAccount: TeamAccountCreateNestedOneWithoutContactsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutEmailsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    teamAccountId: string
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactCreateOrConnectWithoutEmailsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
  }

  export type TeamAccountCreateWithoutEmailsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutEmailsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutEmailsInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutEmailsInput, TeamAccountUncheckedCreateWithoutEmailsInput>
  }

  export type EmailThreadCreateWithoutEmailsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccount: TeamAccountCreateNestedOneWithoutEmailThreadsInput
    contacts?: ContactCreateNestedManyWithoutEmailThreadsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadUncheckedCreateWithoutEmailsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    teamAccountId: string
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailThreadsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadCreateOrConnectWithoutEmailsInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutEmailsInput, EmailThreadUncheckedCreateWithoutEmailsInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutEmailsInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutEmailsInput, ContactUncheckedUpdateWithoutEmailsInput>
    create: XOR<ContactCreateWithoutEmailsInput, ContactUncheckedCreateWithoutEmailsInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutEmailsInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutEmailsInput, ContactUncheckedUpdateWithoutEmailsInput>
  }

  export type ContactUpdateManyWithWhereWithoutEmailsInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutEmailsInput>
  }

  export type TeamAccountUpsertWithoutEmailsInput = {
    update: XOR<TeamAccountUpdateWithoutEmailsInput, TeamAccountUncheckedUpdateWithoutEmailsInput>
    create: XOR<TeamAccountCreateWithoutEmailsInput, TeamAccountUncheckedCreateWithoutEmailsInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutEmailsInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutEmailsInput, TeamAccountUncheckedUpdateWithoutEmailsInput>
  }

  export type TeamAccountUpdateWithoutEmailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutEmailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type EmailThreadUpsertWithoutEmailsInput = {
    update: XOR<EmailThreadUpdateWithoutEmailsInput, EmailThreadUncheckedUpdateWithoutEmailsInput>
    create: XOR<EmailThreadCreateWithoutEmailsInput, EmailThreadUncheckedCreateWithoutEmailsInput>
    where?: EmailThreadWhereInput
  }

  export type EmailThreadUpdateToOneWithWhereWithoutEmailsInput = {
    where?: EmailThreadWhereInput
    data: XOR<EmailThreadUpdateWithoutEmailsInput, EmailThreadUncheckedUpdateWithoutEmailsInput>
  }

  export type EmailThreadUpdateWithoutEmailsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailThreadsNestedInput
    contacts?: ContactUpdateManyWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutEmailsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
    contacts?: ContactUncheckedUpdateManyWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailCreateWithoutEmailThreadInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    messageId: string
    contacts?: ContactCreateNestedManyWithoutEmailsInput
    teamAccount: TeamAccountCreateNestedOneWithoutEmailsInput
  }

  export type EmailUncheckedCreateWithoutEmailThreadInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    teamAccountId: string
    messageId: string
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailsInput
  }

  export type EmailCreateOrConnectWithoutEmailThreadInput = {
    where: EmailWhereUniqueInput
    create: XOR<EmailCreateWithoutEmailThreadInput, EmailUncheckedCreateWithoutEmailThreadInput>
  }

  export type EmailCreateManyEmailThreadInputEnvelope = {
    data: EmailCreateManyEmailThreadInput | EmailCreateManyEmailThreadInput[]
  }

  export type TeamAccountCreateWithoutEmailThreadsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutEmailThreadsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutEmailThreadsInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutEmailThreadsInput, TeamAccountUncheckedCreateWithoutEmailThreadsInput>
  }

  export type ContactCreateWithoutEmailThreadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    creatingTeamAccount: TeamAccountCreateNestedOneWithoutContactsInput
    emails?: EmailCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetCreateNestedManyWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutEmailThreadsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    teamAccountId: string
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutContactsInput
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactCreateOrConnectWithoutEmailThreadsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutEmailThreadsInput, ContactUncheckedCreateWithoutEmailThreadsInput>
  }

  export type GithubTargetCreateWithoutEmailThreadsInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
  }

  export type GithubTargetUncheckedCreateWithoutEmailThreadsInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
  }

  export type GithubTargetCreateOrConnectWithoutEmailThreadsInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutEmailThreadsInput, GithubTargetUncheckedCreateWithoutEmailThreadsInput>
  }

  export type EmailUpsertWithWhereUniqueWithoutEmailThreadInput = {
    where: EmailWhereUniqueInput
    update: XOR<EmailUpdateWithoutEmailThreadInput, EmailUncheckedUpdateWithoutEmailThreadInput>
    create: XOR<EmailCreateWithoutEmailThreadInput, EmailUncheckedCreateWithoutEmailThreadInput>
  }

  export type EmailUpdateWithWhereUniqueWithoutEmailThreadInput = {
    where: EmailWhereUniqueInput
    data: XOR<EmailUpdateWithoutEmailThreadInput, EmailUncheckedUpdateWithoutEmailThreadInput>
  }

  export type EmailUpdateManyWithWhereWithoutEmailThreadInput = {
    where: EmailScalarWhereInput
    data: XOR<EmailUpdateManyMutationInput, EmailUncheckedUpdateManyWithoutEmailThreadInput>
  }

  export type TeamAccountUpsertWithoutEmailThreadsInput = {
    update: XOR<TeamAccountUpdateWithoutEmailThreadsInput, TeamAccountUncheckedUpdateWithoutEmailThreadsInput>
    create: XOR<TeamAccountCreateWithoutEmailThreadsInput, TeamAccountUncheckedCreateWithoutEmailThreadsInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutEmailThreadsInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutEmailThreadsInput, TeamAccountUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type TeamAccountUpdateWithoutEmailThreadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutEmailThreadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type ContactUpsertWithWhereUniqueWithoutEmailThreadsInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutEmailThreadsInput, ContactUncheckedUpdateWithoutEmailThreadsInput>
    create: XOR<ContactCreateWithoutEmailThreadsInput, ContactUncheckedCreateWithoutEmailThreadsInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutEmailThreadsInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutEmailThreadsInput, ContactUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type ContactUpdateManyWithWhereWithoutEmailThreadsInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutEmailThreadsInput>
  }

  export type GithubTargetUpsertWithWhereUniqueWithoutEmailThreadsInput = {
    where: GithubTargetWhereUniqueInput
    update: XOR<GithubTargetUpdateWithoutEmailThreadsInput, GithubTargetUncheckedUpdateWithoutEmailThreadsInput>
    create: XOR<GithubTargetCreateWithoutEmailThreadsInput, GithubTargetUncheckedCreateWithoutEmailThreadsInput>
  }

  export type GithubTargetUpdateWithWhereUniqueWithoutEmailThreadsInput = {
    where: GithubTargetWhereUniqueInput
    data: XOR<GithubTargetUpdateWithoutEmailThreadsInput, GithubTargetUncheckedUpdateWithoutEmailThreadsInput>
  }

  export type GithubTargetUpdateManyWithWhereWithoutEmailThreadsInput = {
    where: GithubTargetScalarWhereInput
    data: XOR<GithubTargetUpdateManyMutationInput, GithubTargetUncheckedUpdateManyWithoutEmailThreadsInput>
  }

  export type TeamAccountCreateWithoutNotesInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutNotesInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutNotesInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutNotesInput, TeamAccountUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutNotesInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutTeamAccountUsersInput
    evaluation?: EvaluationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotesInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
  }

  export type GithubTargetCreateWithoutNotesInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateWithoutNotesInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetCreateOrConnectWithoutNotesInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutNotesInput, GithubTargetUncheckedCreateWithoutNotesInput>
  }

  export type TeamAccountUpsertWithoutNotesInput = {
    update: XOR<TeamAccountUpdateWithoutNotesInput, TeamAccountUncheckedUpdateWithoutNotesInput>
    create: XOR<TeamAccountCreateWithoutNotesInput, TeamAccountUncheckedCreateWithoutNotesInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutNotesInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutNotesInput, TeamAccountUncheckedUpdateWithoutNotesInput>
  }

  export type TeamAccountUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type UserUpsertWithoutNotesInput = {
    update: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
    create: XOR<UserCreateWithoutNotesInput, UserUncheckedCreateWithoutNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotesInput, UserUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput
    evaluation?: EvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GithubTargetUpsertWithoutNotesInput = {
    update: XOR<GithubTargetUpdateWithoutNotesInput, GithubTargetUncheckedUpdateWithoutNotesInput>
    create: XOR<GithubTargetCreateWithoutNotesInput, GithubTargetUncheckedCreateWithoutNotesInput>
    where?: GithubTargetWhereInput
  }

  export type GithubTargetUpdateToOneWithWhereWithoutNotesInput = {
    where?: GithubTargetWhereInput
    data: XOR<GithubTargetUpdateWithoutNotesInput, GithubTargetUncheckedUpdateWithoutNotesInput>
  }

  export type GithubTargetUpdateWithoutNotesInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutNotesInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type CampaignCreateWithoutTargetScoutsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTargetScoutsInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTargetScoutsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTargetScoutsInput, CampaignUncheckedCreateWithoutTargetScoutsInput>
  }

  export type TargetScoutFilterUpsertInput = {
    set: TargetScoutFilterCreateInput | null
    update: TargetScoutFilterUpdateInput
  }

  export type CampaignUpsertWithoutTargetScoutsInput = {
    update: XOR<CampaignUpdateWithoutTargetScoutsInput, CampaignUncheckedUpdateWithoutTargetScoutsInput>
    create: XOR<CampaignCreateWithoutTargetScoutsInput, CampaignUncheckedCreateWithoutTargetScoutsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTargetScoutsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTargetScoutsInput, CampaignUncheckedUpdateWithoutTargetScoutsInput>
  }

  export type CampaignUpdateWithoutTargetScoutsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTargetScoutsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutCustomFieldsInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
  }

  export type CampaignCreateOrConnectWithoutCustomFieldsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCustomFieldsInput, CampaignUncheckedCreateWithoutCustomFieldsInput>
  }

  export type CustomFieldValueCreateWithoutCustomFieldInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    targetContact: TargetContactCreateNestedOneWithoutCustomFieldValueInput
  }

  export type CustomFieldValueUncheckedCreateWithoutCustomFieldInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    targetContactId: string
  }

  export type CustomFieldValueCreateOrConnectWithoutCustomFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    create: XOR<CustomFieldValueCreateWithoutCustomFieldInput, CustomFieldValueUncheckedCreateWithoutCustomFieldInput>
  }

  export type CustomFieldValueCreateManyCustomFieldInputEnvelope = {
    data: CustomFieldValueCreateManyCustomFieldInput | CustomFieldValueCreateManyCustomFieldInput[]
  }

  export type CampaignUpsertWithoutCustomFieldsInput = {
    update: XOR<CampaignUpdateWithoutCustomFieldsInput, CampaignUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<CampaignCreateWithoutCustomFieldsInput, CampaignUncheckedCreateWithoutCustomFieldsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutCustomFieldsInput, CampaignUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type CampaignUpdateWithoutCustomFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCustomFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
  }

  export type CustomFieldValueUpsertWithWhereUniqueWithoutCustomFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    update: XOR<CustomFieldValueUpdateWithoutCustomFieldInput, CustomFieldValueUncheckedUpdateWithoutCustomFieldInput>
    create: XOR<CustomFieldValueCreateWithoutCustomFieldInput, CustomFieldValueUncheckedCreateWithoutCustomFieldInput>
  }

  export type CustomFieldValueUpdateWithWhereUniqueWithoutCustomFieldInput = {
    where: CustomFieldValueWhereUniqueInput
    data: XOR<CustomFieldValueUpdateWithoutCustomFieldInput, CustomFieldValueUncheckedUpdateWithoutCustomFieldInput>
  }

  export type CustomFieldValueUpdateManyWithWhereWithoutCustomFieldInput = {
    where: CustomFieldValueScalarWhereInput
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyWithoutCustomFieldInput>
  }

  export type CustomFieldValueScalarWhereInput = {
    AND?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
    OR?: CustomFieldValueScalarWhereInput[]
    NOT?: CustomFieldValueScalarWhereInput | CustomFieldValueScalarWhereInput[]
    id?: StringFilter<"CustomFieldValue"> | string
    value_string?: StringFilter<"CustomFieldValue"> | string
    value_number?: FloatFilter<"CustomFieldValue"> | number
    value_date?: DateTimeFilter<"CustomFieldValue"> | Date | string
    value_boolean?: BoolFilter<"CustomFieldValue"> | boolean
    customFieldId?: StringFilter<"CustomFieldValue"> | string
    targetContactId?: StringFilter<"CustomFieldValue"> | string
  }

  export type CustomFieldCreateWithoutCustomFieldValuesInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    campaign: CampaignCreateNestedOneWithoutCustomFieldsInput
  }

  export type CustomFieldUncheckedCreateWithoutCustomFieldValuesInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    campaignId: string
  }

  export type CustomFieldCreateOrConnectWithoutCustomFieldValuesInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutCustomFieldValuesInput, CustomFieldUncheckedCreateWithoutCustomFieldValuesInput>
  }

  export type TargetContactCreateWithoutCustomFieldValueInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    githubTarget?: GithubTargetCreateNestedOneWithoutTargetContactsInput
    teamAccount: TeamAccountCreateNestedOneWithoutTargetContactInput
    campaigns?: CampaignCreateNestedManyWithoutTargetContactsInput
  }

  export type TargetContactUncheckedCreateWithoutCustomFieldValueInput = {
    id?: string
    githubTargetId?: string | null
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    teamAccountId: string
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTargetContactsInput
  }

  export type TargetContactCreateOrConnectWithoutCustomFieldValueInput = {
    where: TargetContactWhereUniqueInput
    create: XOR<TargetContactCreateWithoutCustomFieldValueInput, TargetContactUncheckedCreateWithoutCustomFieldValueInput>
  }

  export type CustomFieldUpsertWithoutCustomFieldValuesInput = {
    update: XOR<CustomFieldUpdateWithoutCustomFieldValuesInput, CustomFieldUncheckedUpdateWithoutCustomFieldValuesInput>
    create: XOR<CustomFieldCreateWithoutCustomFieldValuesInput, CustomFieldUncheckedCreateWithoutCustomFieldValuesInput>
    where?: CustomFieldWhereInput
  }

  export type CustomFieldUpdateToOneWithWhereWithoutCustomFieldValuesInput = {
    where?: CustomFieldWhereInput
    data: XOR<CustomFieldUpdateWithoutCustomFieldValuesInput, CustomFieldUncheckedUpdateWithoutCustomFieldValuesInput>
  }

  export type CustomFieldUpdateWithoutCustomFieldValuesInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    campaign?: CampaignUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type CustomFieldUncheckedUpdateWithoutCustomFieldValuesInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
  }

  export type TargetContactUpsertWithoutCustomFieldValueInput = {
    update: XOR<TargetContactUpdateWithoutCustomFieldValueInput, TargetContactUncheckedUpdateWithoutCustomFieldValueInput>
    create: XOR<TargetContactCreateWithoutCustomFieldValueInput, TargetContactUncheckedCreateWithoutCustomFieldValueInput>
    where?: TargetContactWhereInput
  }

  export type TargetContactUpdateToOneWithWhereWithoutCustomFieldValueInput = {
    where?: TargetContactWhereInput
    data: XOR<TargetContactUpdateWithoutCustomFieldValueInput, TargetContactUncheckedUpdateWithoutCustomFieldValueInput>
  }

  export type TargetContactUpdateWithoutCustomFieldValueInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    githubTarget?: GithubTargetUpdateOneWithoutTargetContactsNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutTargetContactNestedInput
    campaigns?: CampaignUpdateManyWithoutTargetContactsNestedInput
  }

  export type TargetContactUncheckedUpdateWithoutCustomFieldValueInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutTargetContactsNestedInput
  }

  export type GithubTargetCreateWithoutTargetContactsInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateWithoutTargetContactsInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetCreateOrConnectWithoutTargetContactsInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutTargetContactsInput, GithubTargetUncheckedCreateWithoutTargetContactsInput>
  }

  export type TeamAccountCreateWithoutTargetContactInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutTargetContactInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutTargetContactInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutTargetContactInput, TeamAccountUncheckedCreateWithoutTargetContactInput>
  }

  export type CampaignCreateWithoutTargetContactsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTargetContactsInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTargetContactsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTargetContactsInput, CampaignUncheckedCreateWithoutTargetContactsInput>
  }

  export type CustomFieldValueCreateWithoutTargetContactInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    customField?: CustomFieldCreateNestedOneWithoutCustomFieldValuesInput
  }

  export type CustomFieldValueUncheckedCreateWithoutTargetContactInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    customFieldId: string
  }

  export type CustomFieldValueCreateOrConnectWithoutTargetContactInput = {
    where: CustomFieldValueWhereUniqueInput
    create: XOR<CustomFieldValueCreateWithoutTargetContactInput, CustomFieldValueUncheckedCreateWithoutTargetContactInput>
  }

  export type CustomFieldValueCreateManyTargetContactInputEnvelope = {
    data: CustomFieldValueCreateManyTargetContactInput | CustomFieldValueCreateManyTargetContactInput[]
  }

  export type GithubTargetUpsertWithoutTargetContactsInput = {
    update: XOR<GithubTargetUpdateWithoutTargetContactsInput, GithubTargetUncheckedUpdateWithoutTargetContactsInput>
    create: XOR<GithubTargetCreateWithoutTargetContactsInput, GithubTargetUncheckedCreateWithoutTargetContactsInput>
    where?: GithubTargetWhereInput
  }

  export type GithubTargetUpdateToOneWithWhereWithoutTargetContactsInput = {
    where?: GithubTargetWhereInput
    data: XOR<GithubTargetUpdateWithoutTargetContactsInput, GithubTargetUncheckedUpdateWithoutTargetContactsInput>
  }

  export type GithubTargetUpdateWithoutTargetContactsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutTargetContactsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type TeamAccountUpsertWithoutTargetContactInput = {
    update: XOR<TeamAccountUpdateWithoutTargetContactInput, TeamAccountUncheckedUpdateWithoutTargetContactInput>
    create: XOR<TeamAccountCreateWithoutTargetContactInput, TeamAccountUncheckedCreateWithoutTargetContactInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutTargetContactInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutTargetContactInput, TeamAccountUncheckedUpdateWithoutTargetContactInput>
  }

  export type TeamAccountUpdateWithoutTargetContactInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutTargetContactInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutTargetContactsInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutTargetContactsInput, CampaignUncheckedUpdateWithoutTargetContactsInput>
    create: XOR<CampaignCreateWithoutTargetContactsInput, CampaignUncheckedCreateWithoutTargetContactsInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutTargetContactsInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutTargetContactsInput, CampaignUncheckedUpdateWithoutTargetContactsInput>
  }

  export type CampaignUpdateManyWithWhereWithoutTargetContactsInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutTargetContactsInput>
  }

  export type CustomFieldValueUpsertWithWhereUniqueWithoutTargetContactInput = {
    where: CustomFieldValueWhereUniqueInput
    update: XOR<CustomFieldValueUpdateWithoutTargetContactInput, CustomFieldValueUncheckedUpdateWithoutTargetContactInput>
    create: XOR<CustomFieldValueCreateWithoutTargetContactInput, CustomFieldValueUncheckedCreateWithoutTargetContactInput>
  }

  export type CustomFieldValueUpdateWithWhereUniqueWithoutTargetContactInput = {
    where: CustomFieldValueWhereUniqueInput
    data: XOR<CustomFieldValueUpdateWithoutTargetContactInput, CustomFieldValueUncheckedUpdateWithoutTargetContactInput>
  }

  export type CustomFieldValueUpdateManyWithWhereWithoutTargetContactInput = {
    where: CustomFieldValueScalarWhereInput
    data: XOR<CustomFieldValueUpdateManyMutationInput, CustomFieldValueUncheckedUpdateManyWithoutTargetContactInput>
  }

  export type CampaignCreateWithoutGithubTargetsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutGithubTargetsInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutGithubTargetsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutGithubTargetsInput, CampaignUncheckedCreateWithoutGithubTargetsInput>
  }

  export type ReportCreateWithoutGithubTargetsInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    title: string
    body: string
    createdAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutGithubTargetsInput = {
    id?: string
    targetIds?: ReportCreatetargetIdsInput | string[]
    type: string
    params?: InputJsonValue | null
    title: string
    body: string
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutGithubTargetsInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutGithubTargetsInput, ReportUncheckedCreateWithoutGithubTargetsInput>
  }

  export type EvaluationCreateWithoutGithubTargetInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutGithubTargetInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutGithubTargetInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutGithubTargetInput, EvaluationUncheckedCreateWithoutGithubTargetInput>
  }

  export type EvaluationCreateManyGithubTargetInputEnvelope = {
    data: EvaluationCreateManyGithubTargetInput | EvaluationCreateManyGithubTargetInput[]
  }

  export type ContactCreateWithoutGithubTargetsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    creatingTeamAccount: TeamAccountCreateNestedOneWithoutContactsInput
    emails?: EmailCreateNestedManyWithoutContactsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutContactsInput
  }

  export type ContactUncheckedCreateWithoutGithubTargetsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    teamAccountId: string
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutContactsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutContactsInput
  }

  export type ContactCreateOrConnectWithoutGithubTargetsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutGithubTargetsInput, ContactUncheckedCreateWithoutGithubTargetsInput>
  }

  export type TargetContactCreateWithoutGithubTargetInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    teamAccount: TeamAccountCreateNestedOneWithoutTargetContactInput
    campaigns?: CampaignCreateNestedManyWithoutTargetContactsInput
    customFieldValue?: CustomFieldValueCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactUncheckedCreateWithoutGithubTargetInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    teamAccountId: string
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTargetContactsInput
    customFieldValue?: CustomFieldValueUncheckedCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactCreateOrConnectWithoutGithubTargetInput = {
    where: TargetContactWhereUniqueInput
    create: XOR<TargetContactCreateWithoutGithubTargetInput, TargetContactUncheckedCreateWithoutGithubTargetInput>
  }

  export type TargetContactCreateManyGithubTargetInputEnvelope = {
    data: TargetContactCreateManyGithubTargetInput | TargetContactCreateManyGithubTargetInput[]
  }

  export type NoteCreateWithoutGithubTargetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: string
    text: string
    teamAccount: TeamAccountCreateNestedOneWithoutNotesInput
    teamAccountUser: UserCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutGithubTargetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccountId: string
    subject?: string
    text: string
    teamAccountUserId: string
  }

  export type NoteCreateOrConnectWithoutGithubTargetInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutGithubTargetInput, NoteUncheckedCreateWithoutGithubTargetInput>
  }

  export type NoteCreateManyGithubTargetInputEnvelope = {
    data: NoteCreateManyGithubTargetInput | NoteCreateManyGithubTargetInput[]
  }

  export type EmailThreadCreateWithoutGithubTargetsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emails?: EmailCreateNestedManyWithoutEmailThreadInput
    teamAccount: TeamAccountCreateNestedOneWithoutEmailThreadsInput
    contacts?: ContactCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadUncheckedCreateWithoutGithubTargetsInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    teamAccountId: string
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
    emails?: EmailUncheckedCreateNestedManyWithoutEmailThreadInput
    contacts?: ContactUncheckedCreateNestedManyWithoutEmailThreadsInput
  }

  export type EmailThreadCreateOrConnectWithoutGithubTargetsInput = {
    where: EmailThreadWhereUniqueInput
    create: XOR<EmailThreadCreateWithoutGithubTargetsInput, EmailThreadUncheckedCreateWithoutGithubTargetsInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutGithubTargetsInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutGithubTargetsInput, CampaignUncheckedUpdateWithoutGithubTargetsInput>
    create: XOR<CampaignCreateWithoutGithubTargetsInput, CampaignUncheckedCreateWithoutGithubTargetsInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutGithubTargetsInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutGithubTargetsInput, CampaignUncheckedUpdateWithoutGithubTargetsInput>
  }

  export type CampaignUpdateManyWithWhereWithoutGithubTargetsInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutGithubTargetsInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutGithubTargetsInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutGithubTargetsInput, ReportUncheckedUpdateWithoutGithubTargetsInput>
    create: XOR<ReportCreateWithoutGithubTargetsInput, ReportUncheckedCreateWithoutGithubTargetsInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutGithubTargetsInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutGithubTargetsInput, ReportUncheckedUpdateWithoutGithubTargetsInput>
  }

  export type ReportUpdateManyWithWhereWithoutGithubTargetsInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutGithubTargetsInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    targetIds?: StringNullableListFilter<"Report">
    type?: StringFilter<"Report"> | string
    params?: JsonNullableFilter<"Report">
    title?: StringFilter<"Report"> | string
    body?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type EvaluationUpsertWithWhereUniqueWithoutGithubTargetInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutGithubTargetInput, EvaluationUncheckedUpdateWithoutGithubTargetInput>
    create: XOR<EvaluationCreateWithoutGithubTargetInput, EvaluationUncheckedCreateWithoutGithubTargetInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutGithubTargetInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutGithubTargetInput, EvaluationUncheckedUpdateWithoutGithubTargetInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutGithubTargetInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutGithubTargetInput>
  }

  export type ContactUpsertWithWhereUniqueWithoutGithubTargetsInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutGithubTargetsInput, ContactUncheckedUpdateWithoutGithubTargetsInput>
    create: XOR<ContactCreateWithoutGithubTargetsInput, ContactUncheckedCreateWithoutGithubTargetsInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutGithubTargetsInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutGithubTargetsInput, ContactUncheckedUpdateWithoutGithubTargetsInput>
  }

  export type ContactUpdateManyWithWhereWithoutGithubTargetsInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutGithubTargetsInput>
  }

  export type TargetContactUpsertWithWhereUniqueWithoutGithubTargetInput = {
    where: TargetContactWhereUniqueInput
    update: XOR<TargetContactUpdateWithoutGithubTargetInput, TargetContactUncheckedUpdateWithoutGithubTargetInput>
    create: XOR<TargetContactCreateWithoutGithubTargetInput, TargetContactUncheckedCreateWithoutGithubTargetInput>
  }

  export type TargetContactUpdateWithWhereUniqueWithoutGithubTargetInput = {
    where: TargetContactWhereUniqueInput
    data: XOR<TargetContactUpdateWithoutGithubTargetInput, TargetContactUncheckedUpdateWithoutGithubTargetInput>
  }

  export type TargetContactUpdateManyWithWhereWithoutGithubTargetInput = {
    where: TargetContactScalarWhereInput
    data: XOR<TargetContactUpdateManyMutationInput, TargetContactUncheckedUpdateManyWithoutGithubTargetInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutGithubTargetInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutGithubTargetInput, NoteUncheckedUpdateWithoutGithubTargetInput>
    create: XOR<NoteCreateWithoutGithubTargetInput, NoteUncheckedCreateWithoutGithubTargetInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutGithubTargetInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutGithubTargetInput, NoteUncheckedUpdateWithoutGithubTargetInput>
  }

  export type NoteUpdateManyWithWhereWithoutGithubTargetInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutGithubTargetInput>
  }

  export type EmailThreadUpsertWithWhereUniqueWithoutGithubTargetsInput = {
    where: EmailThreadWhereUniqueInput
    update: XOR<EmailThreadUpdateWithoutGithubTargetsInput, EmailThreadUncheckedUpdateWithoutGithubTargetsInput>
    create: XOR<EmailThreadCreateWithoutGithubTargetsInput, EmailThreadUncheckedCreateWithoutGithubTargetsInput>
  }

  export type EmailThreadUpdateWithWhereUniqueWithoutGithubTargetsInput = {
    where: EmailThreadWhereUniqueInput
    data: XOR<EmailThreadUpdateWithoutGithubTargetsInput, EmailThreadUncheckedUpdateWithoutGithubTargetsInput>
  }

  export type EmailThreadUpdateManyWithWhereWithoutGithubTargetsInput = {
    where: EmailThreadScalarWhereInput
    data: XOR<EmailThreadUpdateManyMutationInput, EmailThreadUncheckedUpdateManyWithoutGithubTargetsInput>
  }

  export type GithubTargetCreateWithoutCampaignsInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateWithoutCampaignsInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetCreateOrConnectWithoutCampaignsInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutCampaignsInput, GithubTargetUncheckedCreateWithoutCampaignsInput>
  }

  export type TeamAccountCreateWithoutCampaignsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutCampaignsInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutCampaignsInput, TeamAccountUncheckedCreateWithoutCampaignsInput>
  }

  export type TargetScoutCreateWithoutCampaignInput = {
    id?: string
    dependencyName: string
    dependencyFilename: string
    filter?: XOR<TargetScoutFilterNullableCreateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutUncheckedCreateWithoutCampaignInput = {
    id?: string
    dependencyName: string
    dependencyFilename: string
    filter?: XOR<TargetScoutFilterNullableCreateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutCreateOrConnectWithoutCampaignInput = {
    where: TargetScoutWhereUniqueInput
    create: XOR<TargetScoutCreateWithoutCampaignInput, TargetScoutUncheckedCreateWithoutCampaignInput>
  }

  export type TargetScoutCreateManyCampaignInputEnvelope = {
    data: TargetScoutCreateManyCampaignInput | TargetScoutCreateManyCampaignInput[]
  }

  export type TrackerCreateWithoutCampaignInput = {
    id?: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
    evaluations?: EvaluationCreateNestedManyWithoutTrackerInput
  }

  export type TrackerUncheckedCreateWithoutCampaignInput = {
    id?: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutTrackerInput
  }

  export type TrackerCreateOrConnectWithoutCampaignInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutCampaignInput, TrackerUncheckedCreateWithoutCampaignInput>
  }

  export type TrackerCreateManyCampaignInputEnvelope = {
    data: TrackerCreateManyCampaignInput | TrackerCreateManyCampaignInput[]
  }

  export type EvaluationCreateWithoutCampaignInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutCampaignInput = {
    id?: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutCampaignInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutCampaignInput, EvaluationUncheckedCreateWithoutCampaignInput>
  }

  export type EvaluationCreateManyCampaignInputEnvelope = {
    data: EvaluationCreateManyCampaignInput | EvaluationCreateManyCampaignInput[]
  }

  export type TargetContactCreateWithoutCampaignsInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    githubTarget?: GithubTargetCreateNestedOneWithoutTargetContactsInput
    teamAccount: TeamAccountCreateNestedOneWithoutTargetContactInput
    customFieldValue?: CustomFieldValueCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactUncheckedCreateWithoutCampaignsInput = {
    id?: string
    githubTargetId?: string | null
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    teamAccountId: string
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
    customFieldValue?: CustomFieldValueUncheckedCreateNestedManyWithoutTargetContactInput
  }

  export type TargetContactCreateOrConnectWithoutCampaignsInput = {
    where: TargetContactWhereUniqueInput
    create: XOR<TargetContactCreateWithoutCampaignsInput, TargetContactUncheckedCreateWithoutCampaignsInput>
  }

  export type CustomFieldCreateWithoutCampaignInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    customFieldValues?: CustomFieldValueCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldUncheckedCreateWithoutCampaignInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
    customFieldValues?: CustomFieldValueUncheckedCreateNestedManyWithoutCustomFieldInput
  }

  export type CustomFieldCreateOrConnectWithoutCampaignInput = {
    where: CustomFieldWhereUniqueInput
    create: XOR<CustomFieldCreateWithoutCampaignInput, CustomFieldUncheckedCreateWithoutCampaignInput>
  }

  export type CustomFieldCreateManyCampaignInputEnvelope = {
    data: CustomFieldCreateManyCampaignInput | CustomFieldCreateManyCampaignInput[]
  }

  export type GithubTargetUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: GithubTargetWhereUniqueInput
    update: XOR<GithubTargetUpdateWithoutCampaignsInput, GithubTargetUncheckedUpdateWithoutCampaignsInput>
    create: XOR<GithubTargetCreateWithoutCampaignsInput, GithubTargetUncheckedCreateWithoutCampaignsInput>
  }

  export type GithubTargetUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: GithubTargetWhereUniqueInput
    data: XOR<GithubTargetUpdateWithoutCampaignsInput, GithubTargetUncheckedUpdateWithoutCampaignsInput>
  }

  export type GithubTargetUpdateManyWithWhereWithoutCampaignsInput = {
    where: GithubTargetScalarWhereInput
    data: XOR<GithubTargetUpdateManyMutationInput, GithubTargetUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type TeamAccountUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: TeamAccountWhereUniqueInput
    update: XOR<TeamAccountUpdateWithoutCampaignsInput, TeamAccountUncheckedUpdateWithoutCampaignsInput>
    create: XOR<TeamAccountCreateWithoutCampaignsInput, TeamAccountUncheckedCreateWithoutCampaignsInput>
  }

  export type TeamAccountUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: TeamAccountWhereUniqueInput
    data: XOR<TeamAccountUpdateWithoutCampaignsInput, TeamAccountUncheckedUpdateWithoutCampaignsInput>
  }

  export type TeamAccountUpdateManyWithWhereWithoutCampaignsInput = {
    where: TeamAccountScalarWhereInput
    data: XOR<TeamAccountUpdateManyMutationInput, TeamAccountUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type TargetScoutUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TargetScoutWhereUniqueInput
    update: XOR<TargetScoutUpdateWithoutCampaignInput, TargetScoutUncheckedUpdateWithoutCampaignInput>
    create: XOR<TargetScoutCreateWithoutCampaignInput, TargetScoutUncheckedCreateWithoutCampaignInput>
  }

  export type TargetScoutUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TargetScoutWhereUniqueInput
    data: XOR<TargetScoutUpdateWithoutCampaignInput, TargetScoutUncheckedUpdateWithoutCampaignInput>
  }

  export type TargetScoutUpdateManyWithWhereWithoutCampaignInput = {
    where: TargetScoutScalarWhereInput
    data: XOR<TargetScoutUpdateManyMutationInput, TargetScoutUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TargetScoutScalarWhereInput = {
    AND?: TargetScoutScalarWhereInput | TargetScoutScalarWhereInput[]
    OR?: TargetScoutScalarWhereInput[]
    NOT?: TargetScoutScalarWhereInput | TargetScoutScalarWhereInput[]
    id?: StringFilter<"TargetScout"> | string
    campaignId?: StringFilter<"TargetScout"> | string
    dependencyName?: StringFilter<"TargetScout"> | string
    dependencyFilename?: StringFilter<"TargetScout"> | string
  }

  export type TrackerUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TrackerWhereUniqueInput
    update: XOR<TrackerUpdateWithoutCampaignInput, TrackerUncheckedUpdateWithoutCampaignInput>
    create: XOR<TrackerCreateWithoutCampaignInput, TrackerUncheckedCreateWithoutCampaignInput>
  }

  export type TrackerUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TrackerWhereUniqueInput
    data: XOR<TrackerUpdateWithoutCampaignInput, TrackerUncheckedUpdateWithoutCampaignInput>
  }

  export type TrackerUpdateManyWithWhereWithoutCampaignInput = {
    where: TrackerScalarWhereInput
    data: XOR<TrackerUpdateManyMutationInput, TrackerUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TrackerScalarWhereInput = {
    AND?: TrackerScalarWhereInput | TrackerScalarWhereInput[]
    OR?: TrackerScalarWhereInput[]
    NOT?: TrackerScalarWhereInput | TrackerScalarWhereInput[]
    id?: StringFilter<"Tracker"> | string
    campaignId?: StringFilter<"Tracker"> | string
    trackerName?: StringFilter<"Tracker"> | string
    dependencies?: StringNullableListFilter<"Tracker">
    defaultFileNames?: StringNullableListFilter<"Tracker">
    customFileNames?: StringNullableListFilter<"Tracker">
  }

  export type EvaluationUpsertWithWhereUniqueWithoutCampaignInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutCampaignInput, EvaluationUncheckedUpdateWithoutCampaignInput>
    create: XOR<EvaluationCreateWithoutCampaignInput, EvaluationUncheckedCreateWithoutCampaignInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutCampaignInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutCampaignInput, EvaluationUncheckedUpdateWithoutCampaignInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutCampaignInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TargetContactUpsertWithWhereUniqueWithoutCampaignsInput = {
    where: TargetContactWhereUniqueInput
    update: XOR<TargetContactUpdateWithoutCampaignsInput, TargetContactUncheckedUpdateWithoutCampaignsInput>
    create: XOR<TargetContactCreateWithoutCampaignsInput, TargetContactUncheckedCreateWithoutCampaignsInput>
  }

  export type TargetContactUpdateWithWhereUniqueWithoutCampaignsInput = {
    where: TargetContactWhereUniqueInput
    data: XOR<TargetContactUpdateWithoutCampaignsInput, TargetContactUncheckedUpdateWithoutCampaignsInput>
  }

  export type TargetContactUpdateManyWithWhereWithoutCampaignsInput = {
    where: TargetContactScalarWhereInput
    data: XOR<TargetContactUpdateManyMutationInput, TargetContactUncheckedUpdateManyWithoutCampaignsInput>
  }

  export type CustomFieldUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CustomFieldWhereUniqueInput
    update: XOR<CustomFieldUpdateWithoutCampaignInput, CustomFieldUncheckedUpdateWithoutCampaignInput>
    create: XOR<CustomFieldCreateWithoutCampaignInput, CustomFieldUncheckedCreateWithoutCampaignInput>
  }

  export type CustomFieldUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CustomFieldWhereUniqueInput
    data: XOR<CustomFieldUpdateWithoutCampaignInput, CustomFieldUncheckedUpdateWithoutCampaignInput>
  }

  export type CustomFieldUpdateManyWithWhereWithoutCampaignInput = {
    where: CustomFieldScalarWhereInput
    data: XOR<CustomFieldUpdateManyMutationInput, CustomFieldUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CustomFieldScalarWhereInput = {
    AND?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    OR?: CustomFieldScalarWhereInput[]
    NOT?: CustomFieldScalarWhereInput | CustomFieldScalarWhereInput[]
    id?: StringFilter<"CustomField"> | string
    key?: StringFilter<"CustomField"> | string
    bgColor?: StringNullableFilter<"CustomField"> | string | null
    type?: StringFilter<"CustomField"> | string
    targetType?: StringFilter<"CustomField"> | string
    campaignId?: StringFilter<"CustomField"> | string
  }

  export type CampaignCreateWithoutTrackersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTrackersInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    evaluation?: EvaluationUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTrackersInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTrackersInput, CampaignUncheckedCreateWithoutTrackersInput>
  }

  export type EvaluationCreateWithoutTrackerInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutTrackerInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutTrackerInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutTrackerInput, EvaluationUncheckedCreateWithoutTrackerInput>
  }

  export type EvaluationCreateManyTrackerInputEnvelope = {
    data: EvaluationCreateManyTrackerInput | EvaluationCreateManyTrackerInput[]
  }

  export type CampaignUpsertWithoutTrackersInput = {
    update: XOR<CampaignUpdateWithoutTrackersInput, CampaignUncheckedUpdateWithoutTrackersInput>
    create: XOR<CampaignCreateWithoutTrackersInput, CampaignUncheckedCreateWithoutTrackersInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTrackersInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTrackersInput, CampaignUncheckedUpdateWithoutTrackersInput>
  }

  export type CampaignUpdateWithoutTrackersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTrackersInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type EvaluationUpsertWithWhereUniqueWithoutTrackerInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutTrackerInput, EvaluationUncheckedUpdateWithoutTrackerInput>
    create: XOR<EvaluationCreateWithoutTrackerInput, EvaluationUncheckedCreateWithoutTrackerInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutTrackerInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutTrackerInput, EvaluationUncheckedUpdateWithoutTrackerInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutTrackerInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutTrackerInput>
  }

  export type CampaignCreateWithoutEvaluationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutCreateNestedManyWithoutCampaignInput
    trackers?: TrackerCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutEvaluationInput = {
    id?: string
    name: string
    targetIds?: CampaignCreatetargetIdsInput | string[]
    createdAt?: Date | string
    dependenciesInfo?: InputJsonValue | null
    teamAccountIds?: CampaignCreateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignCreatetargetScoutIdsInput | string[]
    budget?: number
    lightMode?: boolean | null
    startDate?: Date | string
    endDate?: Date | string | null
    targetContactIds?: CampaignCreatetargetContactIdsInput | string[]
    archived: boolean
    archivedAt?: Date | string | null
    githubTargets?: GithubTargetUncheckedCreateNestedManyWithoutCampaignsInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutCampaignsInput
    targetScouts?: TargetScoutUncheckedCreateNestedManyWithoutCampaignInput
    trackers?: TrackerUncheckedCreateNestedManyWithoutCampaignInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutCampaignsInput
    customFields?: CustomFieldUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutEvaluationInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutEvaluationInput, CampaignUncheckedCreateWithoutEvaluationInput>
  }

  export type AccountCreateWithoutEvaluationInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateWithoutEvaluationInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutEvaluationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutEvaluationInput, AccountUncheckedCreateWithoutEvaluationInput>
  }

  export type TeamAccountCreateWithoutEvaluationInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailCreateNestedManyWithoutTeamAccountInput
    owners?: UserCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactCreateNestedManyWithoutTeamAccountInput
    subscription?: SubscriptionCreateNestedOneWithoutTeamAccountsInput
    whitelist?: WhitelistCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountUncheckedCreateWithoutEvaluationInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
    subscriptionId?: string | null
    inviteCodes?: OneTimeCodesUncheckedCreateNestedManyWithoutTeamAccountInput
    teamAccountUsers?: UserUncheckedCreateNestedManyWithoutTeamAccountsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutCreatingTeamAccountInput
    emails?: EmailUncheckedCreateNestedManyWithoutTeamAccountInput
    owners?: UserUncheckedCreateNestedManyWithoutOwnedTeamAccountsInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutTeamAccountInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutTeamAccountsInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountInput
    targetContact?: TargetContactUncheckedCreateNestedManyWithoutTeamAccountInput
    whitelist?: WhitelistUncheckedCreateNestedOneWithoutTeamAccountInput
  }

  export type TeamAccountCreateOrConnectWithoutEvaluationInput = {
    where: TeamAccountWhereUniqueInput
    create: XOR<TeamAccountCreateWithoutEvaluationInput, TeamAccountUncheckedCreateWithoutEvaluationInput>
  }

  export type GithubTargetCreateWithoutEvaluationsInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportCreateNestedManyWithoutGithubTargetsInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    reports?: ReportUncheckedCreateNestedManyWithoutGithubTargetsInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetCreateOrConnectWithoutEvaluationsInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutEvaluationsInput, GithubTargetUncheckedCreateWithoutEvaluationsInput>
  }

  export type EvaluationCreateWithoutChildrenInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    parent?: EvaluationCreateNestedOneWithoutChildrenInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutChildrenInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type EvaluationCreateOrConnectWithoutChildrenInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutChildrenInput, EvaluationUncheckedCreateWithoutChildrenInput>
  }

  export type EvaluationCreateWithoutParentInput = {
    id?: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutEvaluationInput
    account: AccountCreateNestedOneWithoutEvaluationInput
    teamAccount: TeamAccountCreateNestedOneWithoutEvaluationInput
    githubTarget: GithubTargetCreateNestedOneWithoutEvaluationsInput
    children?: EvaluationCreateNestedManyWithoutParentInput
    tracker?: TrackerCreateNestedOneWithoutEvaluationsInput
    User?: UserCreateNestedOneWithoutEvaluationInput
  }

  export type EvaluationUncheckedCreateWithoutParentInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
    children?: EvaluationUncheckedCreateNestedManyWithoutParentInput
  }

  export type EvaluationCreateOrConnectWithoutParentInput = {
    where: EvaluationWhereUniqueInput
    create: XOR<EvaluationCreateWithoutParentInput, EvaluationUncheckedCreateWithoutParentInput>
  }

  export type EvaluationCreateManyParentInputEnvelope = {
    data: EvaluationCreateManyParentInput | EvaluationCreateManyParentInput[]
  }

  export type TrackerCreateWithoutEvaluationsInput = {
    id?: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
    campaign: CampaignCreateNestedOneWithoutTrackersInput
  }

  export type TrackerUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    campaignId: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
  }

  export type TrackerCreateOrConnectWithoutEvaluationsInput = {
    where: TrackerWhereUniqueInput
    create: XOR<TrackerCreateWithoutEvaluationsInput, TrackerUncheckedCreateWithoutEvaluationsInput>
  }

  export type UserCreateWithoutEvaluationInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteCreateNestedManyWithoutTeamAccountUserInput
  }

  export type UserUncheckedCreateWithoutEvaluationInput = {
    id?: string
    name: string
    role?: string
    email: string
    emailVerified?: Date | string | null
    contactEmail?: string | null
    image?: string | null
    firstName?: string
    lastName?: string
    lastSeen?: Date | string
    ownedTeamAccountIds?: UserCreateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserCreateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    ownedTeamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutOwnersInput
    teamAccounts?: TeamAccountUncheckedCreateNestedManyWithoutTeamAccountUsersInput
    notes?: NoteUncheckedCreateNestedManyWithoutTeamAccountUserInput
  }

  export type UserCreateOrConnectWithoutEvaluationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvaluationInput, UserUncheckedCreateWithoutEvaluationInput>
  }

  export type CampaignUpsertWithoutEvaluationInput = {
    update: XOR<CampaignUpdateWithoutEvaluationInput, CampaignUncheckedUpdateWithoutEvaluationInput>
    create: XOR<CampaignCreateWithoutEvaluationInput, CampaignUncheckedCreateWithoutEvaluationInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutEvaluationInput, CampaignUncheckedUpdateWithoutEvaluationInput>
  }

  export type CampaignUpdateWithoutEvaluationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutEvaluationInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type AccountUpsertWithoutEvaluationInput = {
    update: XOR<AccountUpdateWithoutEvaluationInput, AccountUncheckedUpdateWithoutEvaluationInput>
    create: XOR<AccountCreateWithoutEvaluationInput, AccountUncheckedCreateWithoutEvaluationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutEvaluationInput, AccountUncheckedUpdateWithoutEvaluationInput>
  }

  export type AccountUpdateWithoutEvaluationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateWithoutEvaluationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamAccountUpsertWithoutEvaluationInput = {
    update: XOR<TeamAccountUpdateWithoutEvaluationInput, TeamAccountUncheckedUpdateWithoutEvaluationInput>
    create: XOR<TeamAccountCreateWithoutEvaluationInput, TeamAccountUncheckedCreateWithoutEvaluationInput>
    where?: TeamAccountWhereInput
  }

  export type TeamAccountUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: TeamAccountWhereInput
    data: XOR<TeamAccountUpdateWithoutEvaluationInput, TeamAccountUncheckedUpdateWithoutEvaluationInput>
  }

  export type TeamAccountUpdateWithoutEvaluationInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutEvaluationInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type GithubTargetUpsertWithoutEvaluationsInput = {
    update: XOR<GithubTargetUpdateWithoutEvaluationsInput, GithubTargetUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<GithubTargetCreateWithoutEvaluationsInput, GithubTargetUncheckedCreateWithoutEvaluationsInput>
    where?: GithubTargetWhereInput
  }

  export type GithubTargetUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: GithubTargetWhereInput
    data: XOR<GithubTargetUpdateWithoutEvaluationsInput, GithubTargetUncheckedUpdateWithoutEvaluationsInput>
  }

  export type GithubTargetUpdateWithoutEvaluationsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutEvaluationsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type EvaluationUpsertWithoutChildrenInput = {
    update: XOR<EvaluationUpdateWithoutChildrenInput, EvaluationUncheckedUpdateWithoutChildrenInput>
    create: XOR<EvaluationCreateWithoutChildrenInput, EvaluationUncheckedCreateWithoutChildrenInput>
    where?: EvaluationWhereInput
  }

  export type EvaluationUpdateToOneWithWhereWithoutChildrenInput = {
    where?: EvaluationWhereInput
    data: XOR<EvaluationUpdateWithoutChildrenInput, EvaluationUncheckedUpdateWithoutChildrenInput>
  }

  export type EvaluationUpdateWithoutChildrenInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutChildrenInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationUpsertWithWhereUniqueWithoutParentInput = {
    where: EvaluationWhereUniqueInput
    update: XOR<EvaluationUpdateWithoutParentInput, EvaluationUncheckedUpdateWithoutParentInput>
    create: XOR<EvaluationCreateWithoutParentInput, EvaluationUncheckedCreateWithoutParentInput>
  }

  export type EvaluationUpdateWithWhereUniqueWithoutParentInput = {
    where: EvaluationWhereUniqueInput
    data: XOR<EvaluationUpdateWithoutParentInput, EvaluationUncheckedUpdateWithoutParentInput>
  }

  export type EvaluationUpdateManyWithWhereWithoutParentInput = {
    where: EvaluationScalarWhereInput
    data: XOR<EvaluationUpdateManyMutationInput, EvaluationUncheckedUpdateManyWithoutParentInput>
  }

  export type TrackerUpsertWithoutEvaluationsInput = {
    update: XOR<TrackerUpdateWithoutEvaluationsInput, TrackerUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<TrackerCreateWithoutEvaluationsInput, TrackerUncheckedCreateWithoutEvaluationsInput>
    where?: TrackerWhereInput
  }

  export type TrackerUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: TrackerWhereInput
    data: XOR<TrackerUpdateWithoutEvaluationsInput, TrackerUncheckedUpdateWithoutEvaluationsInput>
  }

  export type TrackerUpdateWithoutEvaluationsInput = {
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
    campaign?: CampaignUpdateOneRequiredWithoutTrackersNestedInput
  }

  export type TrackerUncheckedUpdateWithoutEvaluationsInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
  }

  export type UserUpsertWithoutEvaluationInput = {
    update: XOR<UserUpdateWithoutEvaluationInput, UserUncheckedUpdateWithoutEvaluationInput>
    create: XOR<UserCreateWithoutEvaluationInput, UserUncheckedCreateWithoutEvaluationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvaluationInput, UserUncheckedUpdateWithoutEvaluationInput>
  }

  export type UserUpdateWithoutEvaluationInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvaluationInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput
  }

  export type GithubTargetCreateWithoutReportsInput = {
    id?: string
    githubGraphqlId: string
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactCreateNestedManyWithoutGithubTargetInput
    notes?: NoteCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetUncheckedCreateWithoutReportsInput = {
    id?: string
    githubGraphqlId: string
    campaignIds?: GithubTargetCreatecampaignIdsInput | string[]
    reportIds?: GithubTargetCreatereportIdsInput | string[]
    type: string
    metadata: InputJsonValue
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: GithubTargetCreatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetCreateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedCreateNestedManyWithoutGithubTargetsInput
    evaluations?: EvaluationUncheckedCreateNestedManyWithoutGithubTargetInput
    contacts?: ContactUncheckedCreateNestedManyWithoutGithubTargetsInput
    targetContacts?: TargetContactUncheckedCreateNestedManyWithoutGithubTargetInput
    notes?: NoteUncheckedCreateNestedManyWithoutGithubTargetInput
    emailThreads?: EmailThreadUncheckedCreateNestedManyWithoutGithubTargetsInput
  }

  export type GithubTargetCreateOrConnectWithoutReportsInput = {
    where: GithubTargetWhereUniqueInput
    create: XOR<GithubTargetCreateWithoutReportsInput, GithubTargetUncheckedCreateWithoutReportsInput>
  }

  export type GithubTargetUpsertWithWhereUniqueWithoutReportsInput = {
    where: GithubTargetWhereUniqueInput
    update: XOR<GithubTargetUpdateWithoutReportsInput, GithubTargetUncheckedUpdateWithoutReportsInput>
    create: XOR<GithubTargetCreateWithoutReportsInput, GithubTargetUncheckedCreateWithoutReportsInput>
  }

  export type GithubTargetUpdateWithWhereUniqueWithoutReportsInput = {
    where: GithubTargetWhereUniqueInput
    data: XOR<GithubTargetUpdateWithoutReportsInput, GithubTargetUncheckedUpdateWithoutReportsInput>
  }

  export type GithubTargetUpdateManyWithWhereWithoutReportsInput = {
    where: GithubTargetScalarWhereInput
    data: XOR<GithubTargetUpdateManyMutationInput, GithubTargetUncheckedUpdateManyWithoutReportsInput>
  }

  export type GithubRepositoryCommitCreateInput = {
    hash: string
    date: string
    message: string
    additions: number
    deletions: number
    filesChanged: number
    authorName: string
    authorEmail: string
  }

  export type GithubRepositoryBranchUpdateManyInput = {
    where: GithubRepositoryBranchWhereInput
    data: GithubRepositoryBranchUpdateInput
  }

  export type GithubRepositoryBranchDeleteManyInput = {
    where: GithubRepositoryBranchWhereInput
  }

  export type GithubRepositoryCommitCompositeListFilter = {
    equals?: GithubRepositoryCommitObjectEqualityInput[]
    every?: GithubRepositoryCommitWhereInput
    some?: GithubRepositoryCommitWhereInput
    none?: GithubRepositoryCommitWhereInput
    isEmpty?: boolean
    isSet?: boolean
  }

  export type EvaluationCreateManyAccountInput = {
    id?: string
    campaignId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type EvaluationUpdateWithoutAccountInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutAccountInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutAccountInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    refresh_token_expires_in?: number | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type NoteCreateManyTeamAccountUserInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccountId: string
    subject?: string
    text: string
    githubTargetId?: string | null
  }

  export type EvaluationCreateManyUserInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    Evaluation?: EvaluationUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    Evaluation?: EvaluationUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token_expires_in?: NullableIntFieldUpdateOperationsInput | number | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamAccountUpdateWithoutOwnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutOwnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateManyWithoutOwnersInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamAccountUpdateWithoutTeamAccountUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutTeamAccountUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoteUpdateWithoutTeamAccountUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccount?: TeamAccountUpdateOneRequiredWithoutNotesNestedInput
    githubTarget?: GithubTargetUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutTeamAccountUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoteUncheckedUpdateManyWithoutTeamAccountUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutUserInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutUserInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamAccountCreateManySubscriptionInput = {
    id?: string
    name: string
    aliasEmail: string
    verifiedEmailAddresses?: TeamAccountCreateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountCreateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountCreateownerIdsInput | string[]
    campaignIds?: TeamAccountCreatecampaignIdsInput | string[]
  }

  export type TeamAccountUpdateWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutTeamAccountsNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateManyWithoutSubscriptionInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
  }

  export type OneTimeCodesCreateManyTeamAccountInput = {
    id?: string
    code: string
    expires: Date | string
    type?: string
    email: string
    createdAt?: Date | string
  }

  export type ContactCreateManyCreatingTeamAccountInput = {
    id?: string
    name: string
    createdAt?: Date | string
    email?: string | null
    contactEmails?: ContactCreatecontactEmailsInput | string[]
    emailIds?: ContactCreateemailIdsInput | string[]
    emailThreadIds?: ContactCreateemailThreadIdsInput | string[]
    targetIds?: ContactCreatetargetIdsInput | string[]
  }

  export type EmailCreateManyTeamAccountInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    messageId: string
    emailThreadId: string
  }

  export type EmailThreadCreateManyTeamAccountInput = {
    id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contactIds?: EmailThreadCreatecontactIdsInput | string[]
    targetIds?: EmailThreadCreatetargetIdsInput | string[]
  }

  export type NoteCreateManyTeamAccountInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    subject?: string
    text: string
    teamAccountUserId: string
    githubTargetId?: string | null
  }

  export type TargetContactCreateManyTeamAccountInput = {
    id?: string
    githubTargetId?: string | null
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
  }

  export type EvaluationCreateManyTeamAccountInput = {
    id?: string
    campaignId: string
    accountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type OneTimeCodesUpdateWithoutTeamAccountInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeCodesUncheckedUpdateWithoutTeamAccountInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OneTimeCodesUncheckedUpdateManyWithoutTeamAccountInput = {
    code?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUpdateManyWithoutOwnersNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    ownedTeamAccounts?: TeamAccountUncheckedUpdateManyWithoutOwnersNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
  }

  export type ContactUpdateWithoutCreatingTeamAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    emails?: EmailUpdateManyWithoutContactsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutCreatingTeamAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutContactsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutCreatingTeamAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
  }

  export type EmailUpdateWithoutTeamAccountInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUpdateManyWithoutEmailsNestedInput
    emailThread?: EmailThreadUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateWithoutTeamAccountInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    messageId?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutTeamAccountInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    messageId?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutOwnedTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutTeamAccountUsersNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountUserNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOwnedTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    ownedTeamAccountIds?: UserUpdateownedTeamAccountIdsInput | string[]
    teamAccountIds?: UserUpdateteamAccountIdsInput | string[]
  }

  export type EmailThreadUpdateWithoutTeamAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUpdateManyWithoutEmailThreadNestedInput
    contacts?: ContactUpdateManyWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutTeamAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutEmailThreadNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutTeamAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
  }

  export type CampaignUpdateWithoutTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTeamAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoteUpdateWithoutTeamAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUser?: UserUpdateOneRequiredWithoutNotesNestedInput
    githubTarget?: GithubTargetUpdateOneWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutTeamAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUserId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NoteUncheckedUpdateManyWithoutTeamAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUserId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TargetContactUpdateWithoutTeamAccountInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    githubTarget?: GithubTargetUpdateOneWithoutTargetContactsNestedInput
    campaigns?: CampaignUpdateManyWithoutTargetContactsNestedInput
    customFieldValue?: CustomFieldValueUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateWithoutTeamAccountInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutTargetContactsNestedInput
    customFieldValue?: CustomFieldValueUncheckedUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateManyWithoutTeamAccountInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
  }

  export type EvaluationUpdateWithoutTeamAccountInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutTeamAccountInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutTeamAccountInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmailUpdateWithoutContactsInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailsNestedInput
    emailThread?: EmailThreadUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateWithoutContactsInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailUncheckedUpdateManyWithoutContactsInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    emailThreadId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailThreadUpdateWithoutContactsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUpdateManyWithoutEmailThreadNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailThreadsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutContactsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutEmailThreadNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutContactsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
  }

  export type GithubTargetUpdateWithoutContactsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutContactsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateManyWithoutContactsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
  }

  export type ContactUpdateWithoutEmailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    creatingTeamAccount?: TeamAccountUpdateOneRequiredWithoutContactsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutEmailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutEmailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
  }

  export type EmailCreateManyEmailThreadInput = {
    id?: string
    to?: EmailCreatetoInput | string[]
    bcc?: EmailCreatebccInput | string[]
    cc?: EmailCreateccInput | string[]
    from: string
    subject: string
    text: string
    sentByUser: boolean
    sentAt?: Date | string
    contactIds?: EmailCreatecontactIdsInput | string[]
    teamAccountId: string
    messageId: string
  }

  export type EmailUpdateWithoutEmailThreadInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messageId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUpdateManyWithoutEmailsNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateWithoutEmailThreadInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    contacts?: ContactUncheckedUpdateManyWithoutEmailsNestedInput
  }

  export type EmailUncheckedUpdateManyWithoutEmailThreadInput = {
    to?: EmailUpdatetoInput | string[]
    bcc?: EmailUpdatebccInput | string[]
    cc?: EmailUpdateccInput | string[]
    from?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    sentByUser?: BoolFieldUpdateOperationsInput | boolean
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactUpdateWithoutEmailThreadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    creatingTeamAccount?: TeamAccountUpdateOneRequiredWithoutContactsNestedInput
    emails?: EmailUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutEmailThreadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutContactsNestedInput
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutEmailThreadsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
  }

  export type GithubTargetUpdateWithoutEmailThreadsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutEmailThreadsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
  }

  export type GithubTargetUncheckedUpdateManyWithoutEmailThreadsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
  }

  export type TargetScoutFilterUpdateInput = {
    repoOwners?: NullableStringFieldUpdateOperationsInput | string | null
    repoCreatedDate?: NullableStringFieldUpdateOperationsInput | string | null
    repoStars?: NullableStringFieldUpdateOperationsInput | string | null
    repoForks?: NullableStringFieldUpdateOperationsInput | string | null
    userLocation?: NullableStringFieldUpdateOperationsInput | string | null
    userFollowers?: NullableStringFieldUpdateOperationsInput | string | null
    userRepositories?: NullableStringFieldUpdateOperationsInput | string | null
    userLanguages?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomFieldValueCreateManyCustomFieldInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    targetContactId: string
  }

  export type CustomFieldValueUpdateWithoutCustomFieldInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    targetContact?: TargetContactUpdateOneRequiredWithoutCustomFieldValueNestedInput
  }

  export type CustomFieldValueUncheckedUpdateWithoutCustomFieldInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    targetContactId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutCustomFieldInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    targetContactId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomFieldValueCreateManyTargetContactInput = {
    id?: string
    value_string: string
    value_number: number
    value_date: Date | string
    value_boolean: boolean
    customFieldId: string
  }

  export type CampaignUpdateWithoutTargetContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTargetContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    githubTargets?: GithubTargetUncheckedUpdateManyWithoutCampaignsNestedInput
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutTargetContactsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CustomFieldValueUpdateWithoutTargetContactInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    customField?: CustomFieldUpdateOneWithoutCustomFieldValuesNestedInput
  }

  export type CustomFieldValueUncheckedUpdateWithoutTargetContactInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    customFieldId?: StringFieldUpdateOperationsInput | string
  }

  export type CustomFieldValueUncheckedUpdateManyWithoutTargetContactInput = {
    value_string?: StringFieldUpdateOperationsInput | string
    value_number?: FloatFieldUpdateOperationsInput | number
    value_date?: DateTimeFieldUpdateOperationsInput | Date | string
    value_boolean?: BoolFieldUpdateOperationsInput | boolean
    customFieldId?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationCreateManyGithubTargetInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type TargetContactCreateManyGithubTargetInput = {
    id?: string
    industry?: string | null
    projectOwner?: string | null
    projectName?: string | null
    type: string
    location?: string | null
    teamAccountId: string
    status?: string | null
    campaignIds?: TargetContactCreatecampaignIdsInput | string[]
  }

  export type NoteCreateManyGithubTargetInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamAccountId: string
    subject?: string
    text: string
    teamAccountUserId: string
  }

  export type CampaignUpdateWithoutGithubTargetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamAccounts?: TeamAccountUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutGithubTargetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamAccounts?: TeamAccountUncheckedUpdateManyWithoutCampaignsNestedInput
    targetScouts?: TargetScoutUncheckedUpdateManyWithoutCampaignNestedInput
    trackers?: TrackerUncheckedUpdateManyWithoutCampaignNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutCampaignNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutCampaignsNestedInput
    customFields?: CustomFieldUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutGithubTargetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    targetIds?: CampaignUpdatetargetIdsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dependenciesInfo?: InputJsonValue | InputJsonValue | null
    teamAccountIds?: CampaignUpdateteamAccountIdsInput | string[]
    targetScoutIds?: CampaignUpdatetargetScoutIdsInput | string[]
    budget?: IntFieldUpdateOperationsInput | number
    lightMode?: NullableBoolFieldUpdateOperationsInput | boolean | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targetContactIds?: CampaignUpdatetargetContactIdsInput | string[]
    archived?: BoolFieldUpdateOperationsInput | boolean
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutGithubTargetsInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutGithubTargetsInput = {
    targetIds?: ReportUpdatetargetIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutGithubTargetsInput = {
    targetIds?: ReportUpdatetargetIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluationUpdateWithoutGithubTargetInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutGithubTargetInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutGithubTargetInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactUpdateWithoutGithubTargetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    creatingTeamAccount?: TeamAccountUpdateOneRequiredWithoutContactsNestedInput
    emails?: EmailUpdateManyWithoutContactsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateWithoutGithubTargetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutContactsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutGithubTargetsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmails?: ContactUpdatecontactEmailsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    emailIds?: ContactUpdateemailIdsInput | string[]
    emailThreadIds?: ContactUpdateemailThreadIdsInput | string[]
    targetIds?: ContactUpdatetargetIdsInput | string[]
  }

  export type TargetContactUpdateWithoutGithubTargetInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccount?: TeamAccountUpdateOneRequiredWithoutTargetContactNestedInput
    campaigns?: CampaignUpdateManyWithoutTargetContactsNestedInput
    customFieldValue?: CustomFieldValueUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateWithoutGithubTargetInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutTargetContactsNestedInput
    customFieldValue?: CustomFieldValueUncheckedUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateManyWithoutGithubTargetInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
  }

  export type NoteUpdateWithoutGithubTargetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccount?: TeamAccountUpdateOneRequiredWithoutNotesNestedInput
    teamAccountUser?: UserUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutGithubTargetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUserId?: StringFieldUpdateOperationsInput | string
  }

  export type NoteUncheckedUpdateManyWithoutGithubTargetInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    teamAccountUserId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailThreadUpdateWithoutGithubTargetsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emails?: EmailUpdateManyWithoutEmailThreadNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEmailThreadsNestedInput
    contacts?: ContactUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateWithoutGithubTargetsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
    emails?: EmailUncheckedUpdateManyWithoutEmailThreadNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutEmailThreadsNestedInput
  }

  export type EmailThreadUncheckedUpdateManyWithoutGithubTargetsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: EmailThreadUpdatecontactIdsInput | string[]
    teamAccountId?: StringFieldUpdateOperationsInput | string
    targetIds?: EmailThreadUpdatetargetIdsInput | string[]
  }

  export type TargetScoutCreateManyCampaignInput = {
    id?: string
    dependencyName: string
    dependencyFilename: string
    filter?: XOR<TargetScoutFilterNullableCreateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TrackerCreateManyCampaignInput = {
    id?: string
    trackerName: string
    dependencies?: TrackerCreatedependenciesInput | string[]
    defaultFileNames?: TrackerCreatedefaultFileNamesInput | string[]
    customFileNames?: TrackerCreatecustomFileNamesInput | string[]
  }

  export type EvaluationCreateManyCampaignInput = {
    id?: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type CustomFieldCreateManyCampaignInput = {
    id?: string
    key: string
    bgColor?: string | null
    type: string
    targetType: string
  }

  export type GithubTargetUpdateWithoutCampaignsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutCampaignsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    reports?: ReportUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateManyWithoutCampaignsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
  }

  export type TeamAccountUpdateWithoutCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    inviteCodes?: OneTimeCodesUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutTeamAccountNestedInput
    notes?: NoteUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUpdateManyWithoutTeamAccountNestedInput
    subscription?: SubscriptionUpdateOneWithoutTeamAccountsNestedInput
    whitelist?: WhitelistUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateWithoutCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCodes?: OneTimeCodesUncheckedUpdateManyWithoutTeamAccountNestedInput
    teamAccountUsers?: UserUncheckedUpdateManyWithoutTeamAccountsNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutCreatingTeamAccountNestedInput
    emails?: EmailUncheckedUpdateManyWithoutTeamAccountNestedInput
    owners?: UserUncheckedUpdateManyWithoutOwnedTeamAccountsNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutTeamAccountNestedInput
    notes?: NoteUncheckedUpdateManyWithoutTeamAccountNestedInput
    targetContact?: TargetContactUncheckedUpdateManyWithoutTeamAccountNestedInput
    evaluation?: EvaluationUncheckedUpdateManyWithoutTeamAccountNestedInput
    whitelist?: WhitelistUncheckedUpdateOneWithoutTeamAccountNestedInput
  }

  export type TeamAccountUncheckedUpdateManyWithoutCampaignsInput = {
    name?: StringFieldUpdateOperationsInput | string
    aliasEmail?: StringFieldUpdateOperationsInput | string
    verifiedEmailAddresses?: TeamAccountUpdateverifiedEmailAddressesInput | string[]
    teamAccountUserIds?: TeamAccountUpdateteamAccountUserIdsInput | string[]
    ownerIds?: TeamAccountUpdateownerIdsInput | string[]
    campaignIds?: TeamAccountUpdatecampaignIdsInput | string[]
    subscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TargetScoutUpdateWithoutCampaignInput = {
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutUncheckedUpdateWithoutCampaignInput = {
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TargetScoutUncheckedUpdateManyWithoutCampaignInput = {
    dependencyName?: StringFieldUpdateOperationsInput | string
    dependencyFilename?: StringFieldUpdateOperationsInput | string
    filter?: XOR<TargetScoutFilterNullableUpdateEnvelopeInput, TargetScoutFilterCreateInput> | null
  }

  export type TrackerUpdateWithoutCampaignInput = {
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
    evaluations?: EvaluationUpdateManyWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateWithoutCampaignInput = {
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
    evaluations?: EvaluationUncheckedUpdateManyWithoutTrackerNestedInput
  }

  export type TrackerUncheckedUpdateManyWithoutCampaignInput = {
    trackerName?: StringFieldUpdateOperationsInput | string
    dependencies?: TrackerUpdatedependenciesInput | string[]
    defaultFileNames?: TrackerUpdatedefaultFileNamesInput | string[]
    customFileNames?: TrackerUpdatecustomFileNamesInput | string[]
  }

  export type EvaluationUpdateWithoutCampaignInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutCampaignInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutCampaignInput = {
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TargetContactUpdateWithoutCampaignsInput = {
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    githubTarget?: GithubTargetUpdateOneWithoutTargetContactsNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutTargetContactNestedInput
    customFieldValue?: CustomFieldValueUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateWithoutCampaignsInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
    customFieldValue?: CustomFieldValueUncheckedUpdateManyWithoutTargetContactNestedInput
  }

  export type TargetContactUncheckedUpdateManyWithoutCampaignsInput = {
    githubTargetId?: NullableStringFieldUpdateOperationsInput | string | null
    industry?: NullableStringFieldUpdateOperationsInput | string | null
    projectOwner?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    teamAccountId?: StringFieldUpdateOperationsInput | string
    status?: NullableStringFieldUpdateOperationsInput | string | null
    campaignIds?: TargetContactUpdatecampaignIdsInput | string[]
  }

  export type CustomFieldUpdateWithoutCampaignInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    customFieldValues?: CustomFieldValueUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateWithoutCampaignInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    customFieldValues?: CustomFieldValueUncheckedUpdateManyWithoutCustomFieldNestedInput
  }

  export type CustomFieldUncheckedUpdateManyWithoutCampaignInput = {
    key?: StringFieldUpdateOperationsInput | string
    bgColor?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
  }

  export type EvaluationCreateManyTrackerInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type EvaluationUpdateWithoutTrackerInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    parent?: EvaluationUpdateOneWithoutChildrenNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutTrackerInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutTrackerInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluationCreateManyParentInput = {
    id?: string
    campaignId: string
    accountId: string
    teamAccountId: string
    githubTargetId: string
    type: string
    params?: InputJsonValue | null
    query?: string | null
    queryVariables?: InputJsonValue | null
    paginators?: InputJsonValue | null
    maxPerPage?: number
    dataId?: string | null
    result?: InputJsonValue | null
    status?: string
    error?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    trackerId?: string | null
    userId?: string | null
  }

  export type EvaluationUpdateWithoutParentInput = {
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutEvaluationNestedInput
    account?: AccountUpdateOneRequiredWithoutEvaluationNestedInput
    teamAccount?: TeamAccountUpdateOneRequiredWithoutEvaluationNestedInput
    githubTarget?: GithubTargetUpdateOneRequiredWithoutEvaluationsNestedInput
    children?: EvaluationUpdateManyWithoutParentNestedInput
    tracker?: TrackerUpdateOneWithoutEvaluationsNestedInput
    User?: UserUpdateOneWithoutEvaluationNestedInput
  }

  export type EvaluationUncheckedUpdateWithoutParentInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: EvaluationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EvaluationUncheckedUpdateManyWithoutParentInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    teamAccountId?: StringFieldUpdateOperationsInput | string
    githubTargetId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    params?: InputJsonValue | InputJsonValue | null
    query?: NullableStringFieldUpdateOperationsInput | string | null
    queryVariables?: InputJsonValue | InputJsonValue | null
    paginators?: InputJsonValue | InputJsonValue | null
    maxPerPage?: IntFieldUpdateOperationsInput | number
    dataId?: NullableStringFieldUpdateOperationsInput | string | null
    result?: InputJsonValue | InputJsonValue | null
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    trackerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type GithubTargetUpdateWithoutReportsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateWithoutReportsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
    campaigns?: CampaignUncheckedUpdateManyWithoutGithubTargetsNestedInput
    evaluations?: EvaluationUncheckedUpdateManyWithoutGithubTargetNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutGithubTargetsNestedInput
    targetContacts?: TargetContactUncheckedUpdateManyWithoutGithubTargetNestedInput
    notes?: NoteUncheckedUpdateManyWithoutGithubTargetNestedInput
    emailThreads?: EmailThreadUncheckedUpdateManyWithoutGithubTargetsNestedInput
  }

  export type GithubTargetUncheckedUpdateManyWithoutReportsInput = {
    githubGraphqlId?: StringFieldUpdateOperationsInput | string
    campaignIds?: GithubTargetUpdatecampaignIdsInput | string[]
    reportIds?: GithubTargetUpdatereportIdsInput | string[]
    type?: StringFieldUpdateOperationsInput | string
    metadata?: InputJsonValue | InputJsonValue
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactIds?: GithubTargetUpdatecontactIdsInput | string[]
    emailThreadIds?: GithubTargetUpdateemailThreadIdsInput | string[]
  }

  export type GithubRepositoryBranchUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    commits?: XOR<GithubRepositoryCommitListUpdateEnvelopeInput, GithubRepositoryCommitCreateInput> | GithubRepositoryCommitCreateInput[]
  }

  export type GithubRepositoryCommitWhereInput = {
    AND?: GithubRepositoryCommitWhereInput | GithubRepositoryCommitWhereInput[]
    OR?: GithubRepositoryCommitWhereInput[]
    NOT?: GithubRepositoryCommitWhereInput | GithubRepositoryCommitWhereInput[]
    hash?: StringFilter<"GithubRepositoryCommit"> | string
    date?: StringFilter<"GithubRepositoryCommit"> | string
    message?: StringFilter<"GithubRepositoryCommit"> | string
    additions?: IntFilter<"GithubRepositoryCommit"> | number
    deletions?: IntFilter<"GithubRepositoryCommit"> | number
    filesChanged?: IntFilter<"GithubRepositoryCommit"> | number
    authorName?: StringFilter<"GithubRepositoryCommit"> | string
    authorEmail?: StringFilter<"GithubRepositoryCommit"> | string
  }

  export type GithubRepositoryCommitListUpdateEnvelopeInput = {
    set?: GithubRepositoryCommitCreateInput | GithubRepositoryCommitCreateInput[]
    push?: GithubRepositoryCommitCreateInput | GithubRepositoryCommitCreateInput[]
    updateMany?: GithubRepositoryCommitUpdateManyInput
    deleteMany?: GithubRepositoryCommitDeleteManyInput
  }

  export type GithubRepositoryCommitUpdateManyInput = {
    where: GithubRepositoryCommitWhereInput
    data: GithubRepositoryCommitUpdateInput
  }

  export type GithubRepositoryCommitDeleteManyInput = {
    where: GithubRepositoryCommitWhereInput
  }

  export type GithubRepositoryCommitUpdateInput = {
    hash?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    additions?: IntFieldUpdateOperationsInput | number
    deletions?: IntFieldUpdateOperationsInput | number
    filesChanged?: IntFieldUpdateOperationsInput | number
    authorName?: StringFieldUpdateOperationsInput | string
    authorEmail?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionCountOutputTypeDefaultArgs instead
     */
    export type SubscriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamAccountCountOutputTypeDefaultArgs instead
     */
    export type TeamAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactCountOutputTypeDefaultArgs instead
     */
    export type ContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailCountOutputTypeDefaultArgs instead
     */
    export type EmailCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailThreadCountOutputTypeDefaultArgs instead
     */
    export type EmailThreadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailThreadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomFieldCountOutputTypeDefaultArgs instead
     */
    export type CustomFieldCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomFieldCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TargetContactCountOutputTypeDefaultArgs instead
     */
    export type TargetContactCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TargetContactCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GithubTargetCountOutputTypeDefaultArgs instead
     */
    export type GithubTargetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GithubTargetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrackerCountOutputTypeDefaultArgs instead
     */
    export type TrackerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrackerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationCountOutputTypeDefaultArgs instead
     */
    export type EvaluationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCountOutputTypeDefaultArgs instead
     */
    export type ReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TargetScoutFilterDefaultArgs instead
     */
    export type TargetScoutFilterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TargetScoutFilterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GithubRepositoryBranchDefaultArgs instead
     */
    export type GithubRepositoryBranchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GithubRepositoryBranchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GithubRepositoryCommitDefaultArgs instead
     */
    export type GithubRepositoryCommitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GithubRepositoryCommitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhitelistDefaultArgs instead
     */
    export type WhitelistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhitelistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OneTimeCodesDefaultArgs instead
     */
    export type OneTimeCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OneTimeCodesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubscriptionDefaultArgs instead
     */
    export type SubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamAccountDefaultArgs instead
     */
    export type TeamAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactDefaultArgs instead
     */
    export type ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailDefaultArgs instead
     */
    export type EmailArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailThreadDefaultArgs instead
     */
    export type EmailThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailThreadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoteDefaultArgs instead
     */
    export type NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TargetScoutDefaultArgs instead
     */
    export type TargetScoutArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TargetScoutDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomFieldDefaultArgs instead
     */
    export type CustomFieldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomFieldDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomFieldValueDefaultArgs instead
     */
    export type CustomFieldValueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomFieldValueDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TargetContactDefaultArgs instead
     */
    export type TargetContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TargetContactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GithubTargetDefaultArgs instead
     */
    export type GithubTargetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GithubTargetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrackerDefaultArgs instead
     */
    export type TrackerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrackerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EvaluationDefaultArgs instead
     */
    export type EvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GithubRepositoryDefaultArgs instead
     */
    export type GithubRepositoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GithubRepositoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZapierEventDefaultArgs instead
     */
    export type ZapierEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZapierEventDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}